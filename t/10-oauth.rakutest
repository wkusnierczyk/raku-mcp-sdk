use v6.d;
use Test;
use lib 'lib';

use MCP::OAuth;
use MCP::OAuth::Server;
use MCP::OAuth::Client;
use JSON::Fast;

plan *;

# === 1. PKCE ===
subtest 'PKCE', {
    plan 4;
    my $pkce = PKCE.new;

    my $verifier = $pkce.generate-verifier;
    is $verifier.chars, 64, 'verifier is 64 characters';
    ok $verifier ~~ /^<[A..Za..z0..9\-._~]>+$/, 'verifier uses valid characters';

    my $challenge = $pkce.generate-challenge($verifier);
    ok $challenge.chars > 0, 'challenge is non-empty';
    nok $challenge ~~ /<[+=\/]>/, 'challenge is base64url (no +, =, /)';
};

# === 2. ProtectedResourceMetadata ===
subtest 'ProtectedResourceMetadata', {
    plan 4;
    my $meta = ProtectedResourceMetadata.new(
        resource => 'https://api.example.com',
        authorization-servers => ['https://auth.example.com'],
        scopes-supported => ['read', 'write'],
    );
    is $meta.resource, 'https://api.example.com', 'resource set';
    my %h = $meta.Hash;
    is %h<resource>, 'https://api.example.com', 'Hash roundtrip resource';
    is %h<authorization_servers>[0], 'https://auth.example.com', 'Hash roundtrip auth servers';

    my $from = ProtectedResourceMetadata.from-hash(%h);
    is $from.resource, 'https://api.example.com', 'from-hash roundtrip';
};

# === 3. AuthServerMetadata ===
subtest 'AuthServerMetadata', {
    plan 4;
    my $meta = AuthServerMetadata.new(
        issuer => 'https://auth.example.com',
        authorization-endpoint => 'https://auth.example.com/authorize',
        token-endpoint => 'https://auth.example.com/token',
        grant-types-supported => ['authorization_code'],
        code-challenge-methods-supported => ['S256'],
    );
    is $meta.issuer, 'https://auth.example.com', 'issuer set';
    my %h = $meta.Hash;
    is %h<token_endpoint>, 'https://auth.example.com/token', 'Hash roundtrip token endpoint';

    my $from = AuthServerMetadata.from-hash(%h);
    is $from.issuer, 'https://auth.example.com', 'from-hash roundtrip issuer';
    is $from.token-endpoint, 'https://auth.example.com/token', 'from-hash roundtrip token endpoint';
};

# === 4. TokenResponse ===
subtest 'TokenResponse', {
    plan 4;
    my $token = TokenResponse.new(
        access-token => 'abc123',
        token-type => 'Bearer',
        expires-in => 3600,
        refresh-token => 'refresh456',
        scope => 'read write',
    );
    is $token.access-token, 'abc123', 'access token set';
    nok $token.is-expired, 'fresh token is not expired';

    # Simulate expired token
    my $expired = TokenResponse.new(
        access-token => 'old',
        expires-in => 1,
        created-at => now - 100,
    );
    ok $expired.is-expired, 'old token is expired';

    my $from = TokenResponse.from-hash({
        access_token => 'xyz',
        token_type => 'Bearer',
        expires_in => 7200,
    });
    is $from.access-token, 'xyz', 'from-hash roundtrip';
};

# === 5. OAuthServerHandler ===
subtest 'OAuthServerHandler', {
    plan 5;
    my $handler = OAuthServerHandler.new(
        resource-identifier => 'https://api.example.com',
        authorization-servers => ['https://auth.example.com'],
        scopes-supported => ['read', 'write'],
        token-validator => -> Str $token {
            if $token eq 'valid-token' {
                { valid => True, sub => 'user1' }
            } else {
                { valid => False, message => 'Invalid token' }
            }
        },
    );

    my %meta = $handler.resource-metadata;
    is %meta<resource>, 'https://api.example.com', 'resource-metadata returns correct resource';
    ok %meta<authorization_servers>:exists, 'resource-metadata has auth servers';

    # Mock request with valid token
    my $valid-req = class { method header($n) { 'Bearer valid-token' } }.new;
    my %result = $handler.validate-request($valid-req);
    ok %result<valid>, 'valid token passes validation';

    # Mock request with invalid token
    my $invalid-req = class { method header($n) { 'Bearer bad-token' } }.new;
    dies-ok { $handler.validate-request($invalid-req) }, 'invalid token throws';

    # WWW-Authenticate header format
    my $www = $handler.www-authenticate-header;
    ok $www.contains('Bearer'), 'www-authenticate starts with Bearer';
};

# === 6. OAuthServerHandler scope header and Forbidden path ===
subtest 'OAuthServerHandler www-authenticate-scope-header', {
    plan 3;
    my $handler = OAuthServerHandler.new(
        resource-identifier => 'https://api.example.com',
        authorization-servers => ['https://auth.example.com'],
        scopes-supported => ['read', 'write'],
        token-validator => -> Str $token { { valid => False, scopes => ['read', 'write'], message => 'Insufficient scope' } },
    );

    my $scope-header = $handler.www-authenticate-scope-header(['read', 'write']);
    ok $scope-header.contains('Bearer'), 'scope header starts with Bearer';
    ok $scope-header.contains('insufficient_scope'), 'scope header has error';
    ok $scope-header.contains('read write'), 'scope header has scopes';
};

subtest 'OAuthServerHandler Forbidden with scopes', {
    plan 2;
    my $handler = OAuthServerHandler.new(
        resource-identifier => 'https://api.example.com',
        authorization-servers => ['https://auth.example.com'],
        scopes-supported => ['admin'],
        token-validator => -> Str $token {
            { valid => False, scopes => ['admin'], message => 'Need admin' }
        },
    );

    my $req = class { method header($n) { 'Bearer some-token' } }.new;
    try {
        $handler.validate-request($req);
        CATCH {
            when X::MCP::OAuth::Forbidden {
                ok True, 'Forbidden exception thrown';
                ok .message.contains('Need admin') || .message.contains('Insufficient'), 'Forbidden message';
            }
            default { flunk "Wrong exception: {.^name}" }
        }
    }
};

# === 7. OAuthClientHandler authorization-url ===
subtest 'OAuthClientHandler authorization-url', {
    plan 3;
    use MCP::OAuth::Client;

    my $client-handler = OAuthClientHandler.new(
        resource-url => 'https://api.example.com',
        client-id => 'test-client',
        scopes => ['read'],
        authorization-callback => -> Str $url { 'auth-code-123' },
    );

    # Manually set auth metadata to avoid HTTP calls
    $client-handler.auth-metadata = AuthServerMetadata.new(
        issuer => 'https://auth.example.com',
        authorization-endpoint => 'https://auth.example.com/authorize',
        token-endpoint => 'https://auth.example.com/token',
    );

    my $url = $client-handler.authorization-url;
    ok $url.contains('code_challenge='), 'URL contains code_challenge';
    ok $url.contains('client_id='), 'URL contains client_id';
    ok $url.contains('resource='), 'URL contains resource';
};

# === 7. Transport backwards compatibility ===
subtest 'Transport backwards compatibility', {
    plan 1;
    use MCP::Transport::StreamableHTTP;

    # Server transport without oauth-handler should work fine
    my $transport = StreamableHTTPServerTransport.new(
        path => '/mcp',
    );
    nok $transport.oauth-handler.defined, 'oauth-handler is optional (not defined by default)';
};

# === 10. ClientRegistrationRequest/Response types ===
subtest 'ClientRegistration types', {
    plan 6;

    my $req = ClientRegistrationRequest.new(
        redirect-uris => ['http://localhost:8080/callback'],
        client-name => 'Test App',
        grant-types => ['authorization_code', 'refresh_token'],
        response-types => ['code'],
        token-endpoint-auth-method => 'none',
        scope => 'read write',
    );
    my %h = $req.Hash;
    is %h<redirect_uris>[0], 'http://localhost:8080/callback', 'Hash redirect_uris';
    is %h<client_name>, 'Test App', 'Hash client_name';
    is %h<token_endpoint_auth_method>, 'none', 'Hash auth method';

    my $resp = ClientRegistrationResponse.from-hash({
        client_id => 'dyn-client-001',
        client_secret => 'secret-abc',
        client_secret_expires_at => 0,
        redirect_uris => ['http://localhost:8080/callback'],
        client_name => 'Test App',
        grant_types => ['authorization_code'],
        response_types => ['code'],
        token_endpoint_auth_method => 'none',
        scope => 'read write',
    });
    is $resp.client-id, 'dyn-client-001', 'from-hash client-id';
    is $resp.client-secret, 'secret-abc', 'from-hash client-secret';
    is $resp.scope, 'read write', 'from-hash scope';
};

# === 11. AuthServerMetadata with registration endpoint ===
subtest 'AuthServerMetadata registration endpoint', {
    plan 3;
    my $meta = AuthServerMetadata.new(
        issuer => 'https://auth.example.com',
        authorization-endpoint => 'https://auth.example.com/authorize',
        token-endpoint => 'https://auth.example.com/token',
        registration-endpoint => 'https://auth.example.com/register',
    );
    is $meta.registration-endpoint, 'https://auth.example.com/register', 'registration endpoint set';
    my %h = $meta.Hash;
    is %h<registration_endpoint>, 'https://auth.example.com/register', 'Hash roundtrip';
    my $from = AuthServerMetadata.from-hash(%h);
    is $from.registration-endpoint, 'https://auth.example.com/register', 'from-hash roundtrip';
};

# === 12. OAuthM2MClient construction ===
subtest 'OAuthM2MClient construction', {
    plan 4;
    use MCP::OAuth::Client;

    my $m2m = OAuthM2MClient.new(
        resource-url  => 'https://api.example.com',
        client-id     => 'm2m-client',
        client-secret => 'm2m-secret',
        scopes        => ['read', 'write'],
    );
    is $m2m.resource-url, 'https://api.example.com', 'resource-url set';
    is $m2m.client-id, 'm2m-client', 'client-id set';
    is $m2m.client-secret, 'm2m-secret', 'client-secret set';
    nok $m2m.token.defined, 'no token initially';
};

# === 13. OAuthM2MClient token management ===
subtest 'OAuthM2MClient get-token with pre-set token', {
    plan 2;
    use MCP::OAuth::Client;

    my $m2m = OAuthM2MClient.new(
        resource-url  => 'https://api.example.com',
        client-id     => 'm2m-client',
        client-secret => 'm2m-secret',
    );

    # Pre-set a valid token to test get-token returns it without HTTP calls
    $m2m.token = TokenResponse.new(
        access-token => 'm2m-token-abc',
        expires-in   => 3600,
    );
    my $token = await $m2m.get-token;
    is $token.access-token, 'm2m-token-abc', 'get-token returns cached token';

    my $header = await $m2m.authorization-header;
    is $header, 'Bearer m2m-token-abc', 'authorization-header formats correctly';
};

# === 14. TokenExchangeResponse type ===
subtest 'TokenExchangeResponse', {
    plan 4;
    my $resp = TokenExchangeResponse.from-hash({
        issued_token_type => 'urn:ietf:params:oauth:token-type:id-jag',
        access_token      => 'eyJhbGciOiJSUzI1NiJ9.test',
        token_type        => 'N_A',
        scope             => 'chat.read chat.history',
        expires_in        => 300,
    });
    is $resp.issued-token-type, 'urn:ietf:params:oauth:token-type:id-jag', 'issued-token-type';
    is $resp.access-token, 'eyJhbGciOiJSUzI1NiJ9.test', 'access-token (ID-JAG)';
    is $resp.token-type, 'N_A', 'token-type is N_A';
    is $resp.expires-in, 300, 'expires-in';
};

# === 15. X::MCP::OAuth::TokenExchange ===
subtest 'X::MCP::OAuth::TokenExchange', {
    plan 2;
    my $ex = X::MCP::OAuth::TokenExchange.new(
        error             => 'invalid_grant',
        error-description => 'Audience validation failed',
    );
    ok $ex.message.contains('invalid_grant'), 'message contains error';
    ok $ex.message.contains('Audience validation failed'), 'message contains description';
};

# === 16. OAuthEnterpriseClient construction and token caching ===
subtest 'OAuthEnterpriseClient construction and token caching', {
    plan 5;
    use MCP::OAuth::Client;

    my $ent = OAuthEnterpriseClient.new(
        resource-url       => 'https://mcp.example.com',
        client-id          => 'mcp-client-1',
        idp-token-endpoint => 'https://idp.example.com/oauth2/token',
        idp-client-id      => 'idp-client-1',
        subject-token      => 'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.test-id-token',
        scopes             => ['chat.read'],
    );
    is $ent.resource-url, 'https://mcp.example.com', 'resource-url set';
    is $ent.idp-token-endpoint, 'https://idp.example.com/oauth2/token', 'idp-token-endpoint set';
    is $ent.subject-token-type, 'urn:ietf:params:oauth:token-type:id_token', 'default subject-token-type';
    nok $ent.token.defined, 'no token initially';

    # Pre-set token to test caching
    $ent.token = TokenResponse.new(
        access-token => 'enterprise-token-xyz',
        expires-in   => 3600,
    );
    my $token = await $ent.get-token;
    is $token.access-token, 'enterprise-token-xyz', 'get-token returns cached token';
};


subtest 'OAuth exception messages', {
    my $e1 = X::MCP::OAuth::Unauthorized.new(message => 'No token');
    is $e1.message, 'No token', 'Unauthorized message';

    my $e2 = X::MCP::OAuth::Forbidden.new(message => 'No scope', scopes => ['read']);
    ok $e2.scopes.elems == 1, 'Forbidden scopes';

    my $e3 = X::MCP::OAuth::Discovery.new(message => 'Not found');
    is $e3.message, 'Not found', 'Discovery message';

    my $e4 = X::MCP::OAuth::Registration.new(
        message => 'Failed', error => 'invalid_client', error-description => 'Bad client',
    );
    ok $e4.message.contains('Failed'), 'Registration message';

    my $e5 = X::MCP::OAuth::TokenExchange.new(
        message => 'Failed', error => 'bad_grant', error-description => 'Bad grant',
    );
    ok $e5.message.contains('Failed'), 'TokenExchange message';
};

subtest 'TokenResponse is-expired extended', {
    my $tr = TokenResponse.new(access-token => 'tok', expires-in => 3600);
    nok $tr.is-expired, 'not expired';

    my $tr2 = TokenResponse.new(access-token => 'tok', expires-in => 0);
    ok $tr2.is-expired, 'expired';

    my $tr3 = TokenResponse.new(access-token => 'tok');
    nok $tr3.is-expired, 'no expires-in = not expired';
};

subtest 'OAuthClientHandler get-token with cached valid token', {
    my $handler = OAuthClientHandler.new(
        resource-url => 'https://api.example.com',
        client-id => 'test',
        authorization-callback => -> Str $url { 'code' },
    );

    $handler.token = TokenResponse.new(
        access-token => 'cached-abc',
        expires-in => 3600,
    );
    my $token = await $handler.get-token;
    is $token.access-token, 'cached-abc', 'get-token returns cached token';

    my $header = await $handler.authorization-header;
    is $header, 'Bearer cached-abc', 'authorization-header correct';
};

subtest 'OAuthClientHandler handle-unauthorized resets state', {
    my $handler = OAuthClientHandler.new(
        resource-url => 'https://api.example.com',
        client-id => 'test',
        authorization-callback => -> Str $url { 'code' },
    );

    $handler.token = TokenResponse.new(access-token => 'old', expires-in => 3600);
    $handler.pkce-verifier = 'old-verifier';

    try { await $handler.handle-unauthorized }
    nok $handler.pkce-verifier.defined, 'pkce-verifier reset after handle-unauthorized';
};

subtest 'OAuthM2MClient error paths', {
    my $m2m = OAuthM2MClient.new(
        resource-url => 'https://api.example.com',
        client-id => 'test',
        client-secret => 'secret',
    );

    dies-ok { await $m2m.request-token }, 'request-token without discover dies';
};

subtest 'OAuthEnterpriseClient error paths', {
    my $ent = OAuthEnterpriseClient.new(
        resource-url => 'https://mcp.example.com',
        client-id => 'client-1',
        idp-token-endpoint => 'https://idp.example.com/token',
        idp-client-id => 'idp-1',
    );

    dies-ok { await $ent.exchange-token }, 'exchange-token without subject dies';
    dies-ok { await $ent.request-token }, 'request-token without id-jag dies';

    $ent.subject-token = 'some-token';
    dies-ok { await $ent.exchange-token }, 'exchange-token without metadata dies';
};

subtest 'OAuthEnterpriseClient authorization-header with cached token', {
    my $ent = OAuthEnterpriseClient.new(
        resource-url => 'https://mcp.example.com',
        client-id => 'client-1',
        idp-token-endpoint => 'https://idp.example.com/token',
        idp-client-id => 'idp-1',
    );
    $ent.token = TokenResponse.new(access-token => 'ent-token', expires-in => 3600);
    my $header = await $ent.authorization-header;
    is $header, 'Bearer ent-token', 'enterprise authorization-header';
};

subtest 'ClientRegistrationRequest Hash extended', {
    my $req = ClientRegistrationRequest.new(
        redirect-uris => ['http://localhost/cb'],
        grant-types => ['authorization_code'],
        response-types => ['code'],
        token-endpoint-auth-method => 'none',
        software-version => '1.0',
    );
    my %h = $req.Hash;
    ok %h<redirect_uris>.elems == 1, 'redirect_uris';
    is %h<software_version>, '1.0', 'software_version';
};

subtest 'ClientRegistrationResponse Hash extended', {
    my $resp = ClientRegistrationResponse.new(
        client-id => 'cid', client-secret => 'sec', scope => 'read write',
    );
    my %h = $resp.Hash;
    is %h<client_id>, 'cid', 'client_id';
    is %h<client_secret>, 'sec', 'client_secret';
    is %h<scope>, 'read write', 'scope';
};

subtest 'AuthServerMetadata with all fields Hash', {
    my $asm = AuthServerMetadata.new(
        issuer => 'https://auth.example.com',
        authorization-endpoint => 'https://auth.example.com/auth',
        token-endpoint => 'https://auth.example.com/token',
        registration-endpoint => 'https://auth.example.com/register',
        grant-types-supported => ['authorization_code'],
        response-types-supported => ['code'],
        scopes-supported => ['read', 'write'],
        code-challenge-methods-supported => ['S256'],
    );
    my %h = $asm.Hash;
    ok %h<code_challenge_methods_supported>.elems == 1, 'code challenge methods';
    ok %h<scopes_supported>.elems == 2, 'scopes supported';
};

subtest 'ProtectedResourceMetadata with scopes extended', {
    my $prm = ProtectedResourceMetadata.new(
        resource => 'https://mcp.example.com',
        authorization-servers => ['https://auth.example.com'],
        scopes-supported => ['read', 'write'],
    );
    my %h = $prm.Hash;
    ok %h<scopes_supported>.elems == 2, 'scopes_supported';
};

subtest 'OAuthClientHandler refresh without token dies', {
    my $handler = OAuthClientHandler.new(
        resource-url => 'https://api.example.com',
        client-id => 'test',
        authorization-callback => -> Str $url { 'code' },
    );
    dies-ok { await $handler.refresh }, 'refresh without token dies';
};

subtest 'OAuthClientHandler register without discover dies', {
    my $handler = OAuthClientHandler.new(
        resource-url => 'https://mcp.example.com',
        client-id => 'my-app',
        authorization-callback => -> $url { 'code' },
    );
    dies-ok { await $handler.register }, 'register without discover dies';
};

subtest 'OAuthClientHandler register without registration-endpoint dies', {
    my $handler = OAuthClientHandler.new(
        resource-url => 'https://mcp.example.com',
        client-id => 'my-app',
        authorization-callback => -> $url { 'code' },
    );
    $handler.auth-metadata = AuthServerMetadata.new(
        issuer => 'https://auth.example.com',
        token-endpoint => 'https://auth.example.com/token',
    );
    dies-ok { await $handler.register }, 'register without registration endpoint dies';
};

subtest 'TokenExchangeResponse from-hash extended', {
    my $ter = TokenExchangeResponse.from-hash(%(
        issued_token_type => 'urn:ietf:params:oauth:token-type:id-jag',
        access_token => 'jag-tok',
        token_type => 'N_A',
        scope => 'read',
        expires_in => 300,
    ));
    is $ter.access-token, 'jag-tok', 'access-token';
    is $ter.scope, 'read', 'scope';
    is $ter.expires-in, 300, 'expires-in';
};

# === PKCE SHA256 correctness ===
subtest 'PKCE SHA256 correctness', {
    my $pkce = PKCE.new;

    # Deterministic: same verifier → same challenge
    my $verifier = 'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk';
    my $c1 = $pkce.generate-challenge($verifier);
    my $c2 = $pkce.generate-challenge($verifier);
    is $c1, $c2, 'generate-challenge is deterministic';

    # challenge-method returns S256
    is $pkce.challenge-method, 'S256', 'challenge-method returns S256';

    # Known vector: SHA256("") = e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
    # base64url of that = 47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU
    my $empty-challenge = $pkce.generate-challenge('');
    # SHA256 of empty string is well-known; verify base64url output
    ok $empty-challenge.chars > 0, 'challenge of empty string is non-empty';
    nok $empty-challenge ~~ /<[+=\/]>/, 'challenge is base64url encoded';

    # Known vector: RFC 7636 Appendix B uses verifier "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
    # Expected challenge: E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM
    is $c1, 'E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM',
        'matches RFC 7636 Appendix B known vector';
};

# === Mock Cro HTTP server for OAuth client flow tests ===
subtest 'OAuthClientHandler flows via mock server', {
    use Cro::HTTP::Router;
    use Cro::HTTP::Server;

    my $PORT = 54399;
    my $BASE = "http://localhost:$PORT";

    my $app = route {
        get -> '.well-known', 'oauth-protected-resource' {
            content 'application/json', to-json({
                resource => $BASE,
                authorization_servers => [$BASE],
                scopes_supported => ['read', 'write'],
            });
        }
        get -> '.well-known', 'oauth-authorization-server' {
            content 'application/json', to-json({
                issuer => $BASE,
                authorization_endpoint => "$BASE/authorize",
                token_endpoint => "$BASE/token",
                registration_endpoint => "$BASE/register",
                grant_types_supported => ['authorization_code', 'refresh_token'],
                code_challenge_methods_supported => ['S256'],
            });
        }
        post -> 'token' {
            request-body -> %body {
                if %body<grant_type> eq 'refresh_token' {
                    content 'application/json', to-json({
                        access_token => 'refreshed-token',
                        token_type => 'Bearer',
                        expires_in => 7200,
                        scope => 'read write',
                    });
                } else {
                    content 'application/json', to-json({
                        access_token => 'new-access-token',
                        token_type => 'Bearer',
                        expires_in => 3600,
                        refresh_token => 'new-refresh-token',
                        scope => 'read write',
                    });
                }
            }
        }
        post -> 'register' {
            request-body -> %body {
                content 'application/json', to-json({
                    client_id => 'registered-client-id',
                    client_secret => 'registered-secret',
                    client_secret_expires_at => 0,
                    redirect_uris => %body<redirect_uris> // ['http://localhost:8080/callback'],
                    grant_types => ['authorization_code'],
                    response_types => ['code'],
                    token_endpoint_auth_method => 'none',
                    scope => 'read write',
                });
            }
        }
    };

    my $server = Cro::HTTP::Server.new(:host<localhost>, :port($PORT), application => $app);
    $server.start;
    LEAVE $server.stop;

    # --- discover ---
    subtest 'discover sets metadata', {
        my $handler = OAuthClientHandler.new(
            resource-url => $BASE,
            client-id => 'test-client',
            authorization-callback => -> Str $url { 'code' },
        );
        await $handler.discover;
        ok $handler.resource-metadata.defined, 'resource-metadata set';
        is $handler.resource-metadata.resource, $BASE, 'resource matches';
        ok $handler.auth-metadata.defined, 'auth-metadata set';
        is $handler.auth-metadata.issuer, $BASE, 'issuer matches';
        is $handler.auth-metadata.token-endpoint, "$BASE/token", 'token endpoint set';
    };

    # --- exchange-code ---
    subtest 'exchange-code returns token and clears pkce-verifier', {
        my $handler = OAuthClientHandler.new(
            resource-url => $BASE,
            client-id => 'test-client',
            authorization-callback => -> Str $url { 'code' },
        );
        $handler.auth-metadata = AuthServerMetadata.new(
            issuer => $BASE,
            authorization-endpoint => "$BASE/authorize",
            token-endpoint => "$BASE/token",
        );
        # Set up pkce-verifier as authorization-url would
        $handler.pkce-verifier = 'test-verifier';
        my $token = await $handler.exchange-code('test-code');
        is $token.access-token, 'new-access-token', 'got access token';
        is $token.refresh-token, 'new-refresh-token', 'got refresh token';
        nok $handler.pkce-verifier.defined, 'pkce-verifier cleared';
    };

    # --- refresh ---
    subtest 'refresh returns new token', {
        my $handler = OAuthClientHandler.new(
            resource-url => $BASE,
            client-id => 'test-client',
            authorization-callback => -> Str $url { 'code' },
        );
        $handler.auth-metadata = AuthServerMetadata.new(
            issuer => $BASE,
            token-endpoint => "$BASE/token",
        );
        $handler.token = TokenResponse.new(
            access-token => 'old-token',
            expires-in => 1,
            created-at => now - 100,
            refresh-token => 'old-refresh',
        );
        my $new-token = await $handler.refresh;
        is $new-token.access-token, 'refreshed-token', 'refreshed access token';
    };

    # --- register ---
    subtest 'register sets client-id and client-secret', {
        my $handler = OAuthClientHandler.new(
            resource-url => $BASE,
            client-id => 'pre-register',
            authorization-callback => -> Str $url { 'code' },
        );
        $handler.auth-metadata = AuthServerMetadata.new(
            issuer => $BASE,
            token-endpoint => "$BASE/token",
            registration-endpoint => "$BASE/register",
        );
        my $reg = await $handler.register;
        is $handler.client-id, 'registered-client-id', 'client-id updated from registration';
        is $handler.client-secret, 'registered-secret', 'client-secret set from registration';
    };

    # --- authorization-url with scopes ---
    subtest 'authorization-url includes scope param', {
        my $handler = OAuthClientHandler.new(
            resource-url => $BASE,
            client-id => 'test-client',
            scopes => ['read', 'write'],
            authorization-callback => -> Str $url { 'code' },
        );
        $handler.auth-metadata = AuthServerMetadata.new(
            issuer => $BASE,
            authorization-endpoint => "$BASE/authorize",
            token-endpoint => "$BASE/token",
        );
        my $url = $handler.authorization-url;
        ok $url.contains('scope='), 'URL contains scope param';
    };

    # --- get-token with expired + refresh ---
    subtest 'get-token refreshes expired token', {
        my $handler = OAuthClientHandler.new(
            resource-url => $BASE,
            client-id => 'test-client',
            authorization-callback => -> Str $url { 'code' },
        );
        $handler.auth-metadata = AuthServerMetadata.new(
            issuer => $BASE,
            token-endpoint => "$BASE/token",
        );
        $handler.token = TokenResponse.new(
            access-token => 'expired-tok',
            expires-in => 1,
            created-at => now - 100,
            refresh-token => 'refresh-tok',
        );
        my $token = await $handler.get-token;
        is $token.access-token, 'refreshed-token', 'get-token triggered refresh';
    };

    # --- authenticate full flow ---
    subtest 'authenticate full flow', {
        my $handler = OAuthClientHandler.new(
            resource-url => $BASE,
            client-id => 'test-client',
            authorization-callback => -> Str $url { 'auth-code-from-callback' },
        );
        my $result = await $handler.authenticate;
        ok $result, 'authenticate completed';
        ok $handler.token.defined, 'token set after authenticate';
        is $handler.token.access-token, 'new-access-token', 'got expected token';
    };
};

# === OAuthM2MClient flows via mock server ===
subtest 'OAuthM2MClient flows via mock server', {
    use Cro::HTTP::Router;
    use Cro::HTTP::Server;

    my $PORT = 54400;
    my $BASE = "http://localhost:$PORT";

    my $app = route {
        get -> '.well-known', 'oauth-protected-resource' {
            content 'application/json', to-json({
                resource => $BASE,
                authorization_servers => [$BASE],
            });
        }
        get -> '.well-known', 'oauth-authorization-server' {
            content 'application/json', to-json({
                issuer => $BASE,
                token_endpoint => "$BASE/token",
            });
        }
        post -> 'token' {
            request-body -> %body {
                content 'application/json', to-json({
                    access_token => 'm2m-new-token',
                    token_type => 'Bearer',
                    expires_in => 3600,
                });
            }
        }
    };

    my $server = Cro::HTTP::Server.new(:host<localhost>, :port($PORT), application => $app);
    $server.start;
    LEAVE $server.stop;

    # --- request-token with pre-set metadata ---
    subtest 'request-token with client_credentials', {
        my $m2m = OAuthM2MClient.new(
            resource-url => $BASE,
            client-id => 'm2m-client',
            client-secret => 'm2m-secret',
            scopes => ['read'],
        );
        $m2m.auth-metadata = AuthServerMetadata.new(
            issuer => $BASE,
            token-endpoint => "$BASE/token",
        );
        my $token = await $m2m.request-token;
        is $token.access-token, 'm2m-new-token', 'got m2m token';
    };

    # --- authenticate full flow ---
    subtest 'authenticate discovers and requests token', {
        my $m2m = OAuthM2MClient.new(
            resource-url => $BASE,
            client-id => 'm2m-client',
            client-secret => 'm2m-secret',
        );
        my $result = await $m2m.authenticate;
        ok $result, 'authenticate completed';
        is $m2m.token.access-token, 'm2m-new-token', 'token set after authenticate';
    };

    # --- get-token with expired token re-requests ---
    subtest 'get-token re-requests when expired', {
        my $m2m = OAuthM2MClient.new(
            resource-url => $BASE,
            client-id => 'm2m-client',
            client-secret => 'm2m-secret',
        );
        $m2m.auth-metadata = AuthServerMetadata.new(
            issuer => $BASE,
            token-endpoint => "$BASE/token",
        );
        $m2m.token = TokenResponse.new(
            access-token => 'old-m2m',
            expires-in => 1,
            created-at => now - 100,
        );
        my $token = await $m2m.get-token;
        is $token.access-token, 'm2m-new-token', 'get-token re-requested after expiry';
    };
};

# === OAuthEnterpriseClient flows via mock server ===
subtest 'OAuthEnterpriseClient flows via mock server', {
    use Cro::HTTP::Router;
    use Cro::HTTP::Server;

    my $PORT = 54401;
    my $BASE = "http://localhost:$PORT";

    my $app = route {
        get -> '.well-known', 'oauth-protected-resource' {
            content 'application/json', to-json({
                resource => $BASE,
                authorization_servers => [$BASE],
            });
        }
        get -> '.well-known', 'oauth-authorization-server' {
            content 'application/json', to-json({
                issuer => $BASE,
                token_endpoint => "$BASE/token",
            });
        }
        post -> 'idp', 'token' {
            request-body -> %body {
                if (%body<subject_token> // '') eq 'bad-token' {
                    content 'application/json', to-json({
                        error => 'invalid_grant',
                        error_description => 'Subject token rejected',
                    });
                } else {
                    content 'application/json', to-json({
                        issued_token_type => 'urn:ietf:params:oauth:token-type:id-jag',
                        access_token => 'id-jag-jwt-token',
                        token_type => 'N_A',
                        scope => 'chat.read',
                        expires_in => 300,
                    });
                }
            }
        }
        post -> 'token' {
            request-body -> %body {
                content 'application/json', to-json({
                    access_token => 'enterprise-access-token',
                    token_type => 'Bearer',
                    expires_in => 3600,
                });
            }
        }
    };

    my $server = Cro::HTTP::Server.new(:host<localhost>, :port($PORT), application => $app);
    $server.start;
    LEAVE $server.stop;

    # --- exchange-token success ---
    subtest 'exchange-token returns TokenExchangeResponse', {
        my $ent = OAuthEnterpriseClient.new(
            resource-url => $BASE,
            client-id => 'ent-client',
            idp-token-endpoint => "$BASE/idp/token",
            idp-client-id => 'idp-client',
            subject-token => 'valid-id-token',
            scopes => ['chat.read'],
        );
        $ent.auth-metadata = AuthServerMetadata.new(
            issuer => $BASE,
            token-endpoint => "$BASE/token",
        );
        my $jag = await $ent.exchange-token;
        is $jag.access-token, 'id-jag-jwt-token', 'got ID-JAG token';
        is $jag.issued-token-type, 'urn:ietf:params:oauth:token-type:id-jag', 'correct issued-token-type';
    };

    # --- exchange-token error ---
    subtest 'exchange-token error throws X::MCP::OAuth::TokenExchange', {
        my $ent = OAuthEnterpriseClient.new(
            resource-url => $BASE,
            client-id => 'ent-client',
            idp-token-endpoint => "$BASE/idp/token",
            idp-client-id => 'idp-client',
            subject-token => 'bad-token',
        );
        $ent.auth-metadata = AuthServerMetadata.new(
            issuer => $BASE,
            token-endpoint => "$BASE/token",
        );
        try {
            await $ent.exchange-token;
            flunk 'should have thrown';
            CATCH {
                when X::MCP::OAuth::TokenExchange {
                    ok .message.contains('invalid_grant'), 'error contains invalid_grant';
                }
                default { flunk "wrong exception: {.^name}" }
            }
        }
    };

    # --- request-token with ID-JAG ---
    subtest 'request-token with jwt-bearer grant', {
        my $ent = OAuthEnterpriseClient.new(
            resource-url => $BASE,
            client-id => 'ent-client',
            idp-token-endpoint => "$BASE/idp/token",
            idp-client-id => 'idp-client',
            subject-token => 'valid-id-token',
        );
        $ent.auth-metadata = AuthServerMetadata.new(
            issuer => $BASE,
            token-endpoint => "$BASE/token",
        );
        $ent.id-jag = TokenExchangeResponse.from-hash({
            issued_token_type => 'urn:ietf:params:oauth:token-type:id-jag',
            access_token => 'id-jag-jwt-token',
            token_type => 'N_A',
        });
        my $token = await $ent.request-token;
        is $token.access-token, 'enterprise-access-token', 'got enterprise access token';
    };

    # --- authenticate full 3-step flow ---
    subtest 'authenticate full enterprise flow', {
        my $ent = OAuthEnterpriseClient.new(
            resource-url => $BASE,
            client-id => 'ent-client',
            idp-token-endpoint => "$BASE/idp/token",
            idp-client-id => 'idp-client',
            subject-token => 'valid-id-token',
            scopes => ['chat.read'],
        );
        my $result = await $ent.authenticate;
        ok $result, 'authenticate completed';
        is $ent.token.access-token, 'enterprise-access-token', 'token set after full flow';
    };

    # --- get-token with expired token re-authenticates ---
    subtest 'get-token re-authenticates when expired', {
        my $ent = OAuthEnterpriseClient.new(
            resource-url => $BASE,
            client-id => 'ent-client',
            idp-token-endpoint => "$BASE/idp/token",
            idp-client-id => 'idp-client',
            subject-token => 'valid-id-token',
        );
        $ent.token = TokenResponse.new(
            access-token => 'old-ent-token',
            expires-in => 1,
            created-at => now - 100,
        );
        my $token = await $ent.get-token;
        is $token.access-token, 'enterprise-access-token', 'get-token re-authenticated';
    };
};

# === OAuthServerHandler edge cases ===
subtest 'OAuthServerHandler edge cases', {
    my $handler = OAuthServerHandler.new(
        resource-identifier => 'https://api.example.com',
        authorization-servers => ['https://auth.example.com'],
        token-validator => -> Str $token {
            { valid => False, message => 'Custom invalid message' }
        },
    );

    # Missing Authorization header
    subtest 'missing Authorization header', {
        my $req = class { method header($n) { Nil } }.new;
        try {
            $handler.validate-request($req);
            flunk 'should have thrown';
            CATCH {
                when X::MCP::OAuth::Unauthorized {
                    ok .message.contains('Missing'), 'Unauthorized for missing header';
                }
                default { flunk "wrong exception: {.^name}" }
            }
        }
    };

    # Malformed header (no Bearer prefix)
    subtest 'malformed Authorization header', {
        my $req = class { method header($n) { 'Basic abc123' } }.new;
        try {
            $handler.validate-request($req);
            flunk 'should have thrown';
            CATCH {
                when X::MCP::OAuth::Unauthorized {
                    ok .message.contains('Missing') || .message.contains('invalid'), 'Unauthorized for non-Bearer';
                }
                default { flunk "wrong exception: {.^name}" }
            }
        }
    };

    # Invalid token with custom message, no scopes
    subtest 'invalid token with custom message', {
        my $req = class { method header($n) { 'Bearer some-token' } }.new;
        try {
            $handler.validate-request($req);
            flunk 'should have thrown';
            CATCH {
                when X::MCP::OAuth::Unauthorized {
                    is .message, 'Custom invalid message', 'custom message passed through';
                }
                default { flunk "wrong exception: {.^name}" }
            }
        }
    };
};

# === Type edge cases ===
subtest 'Type edge cases', {
    # ProtectedResourceMetadata minimal (resource only)
    subtest 'ProtectedResourceMetadata minimal', {
        my $prm = ProtectedResourceMetadata.new(resource => 'https://r.example.com');
        is $prm.resource, 'https://r.example.com', 'resource set';
        my %h = $prm.Hash;
        nok %h<authorization_servers>:exists, 'no auth servers key when empty';
        nok %h<scopes_supported>:exists, 'no scopes key when empty';

        my $from = ProtectedResourceMetadata.from-hash({ resource => 'https://r.example.com' });
        is $from.resource, 'https://r.example.com', 'from-hash with minimal fields';
    };

    # AuthServerMetadata with issuer only
    subtest 'AuthServerMetadata issuer only', {
        my $asm = AuthServerMetadata.new(issuer => 'https://auth.example.com');
        my %h = $asm.Hash;
        is %h<issuer>, 'https://auth.example.com', 'issuer in Hash';
        nok %h<authorization_endpoint>:exists, 'no auth endpoint when not set';
        nok %h<token_endpoint>:exists, 'no token endpoint when not set';

        my $from = AuthServerMetadata.from-hash({ issuer => 'https://auth.example.com' });
        is $from.issuer, 'https://auth.example.com', 'from-hash with issuer only';
    };

    # TokenResponse with access_token only
    subtest 'TokenResponse minimal from-hash', {
        my $tr = TokenResponse.from-hash({ access_token => 'tok' });
        is $tr.access-token, 'tok', 'access-token set';
        is $tr.token-type, 'Bearer', 'default token-type';
        nok $tr.is-expired, 'no expires-in means not expired';
    };

    # ClientRegistrationRequest with all optional fields
    subtest 'ClientRegistrationRequest all optional fields', {
        my $req = ClientRegistrationRequest.new(
            redirect-uris => ['http://localhost/cb'],
            client-name => 'My App',
            client-uri => 'https://myapp.example.com',
            logo-uri => 'https://myapp.example.com/logo.png',
            contacts => ['admin@example.com'],
            tos-uri => 'https://myapp.example.com/tos',
            policy-uri => 'https://myapp.example.com/policy',
            grant-types => ['authorization_code'],
            response-types => ['code'],
            token-endpoint-auth-method => 'none',
            scope => 'read write',
            software-id => 'my-software',
            software-version => '2.0',
        );
        my %h = $req.Hash;
        is %h<client_uri>, 'https://myapp.example.com', 'client_uri';
        is %h<logo_uri>, 'https://myapp.example.com/logo.png', 'logo_uri';
        is %h<contacts>[0], 'admin@example.com', 'contacts';
        is %h<tos_uri>, 'https://myapp.example.com/tos', 'tos_uri';
        is %h<policy_uri>, 'https://myapp.example.com/policy', 'policy_uri';
        is %h<software_id>, 'my-software', 'software_id';
    };

    # ClientRegistrationResponse from-hash minimal (client_id only)
    subtest 'ClientRegistrationResponse minimal', {
        my $resp = ClientRegistrationResponse.from-hash({ client_id => 'cid-only' });
        is $resp.client-id, 'cid-only', 'client-id set';
        nok $resp.client-secret.defined, 'no client-secret';
    };

    # X::MCP::OAuth::Registration with error but no description
    subtest 'Registration error without description', {
        my $ex = X::MCP::OAuth::Registration.new(error => 'invalid_client');
        # No error-description → message should not contain colon
        nok $ex.message.contains(':'), 'no colon when no description';
        ok $ex.message.contains('registration') || $ex.message.contains('Registration') || $ex.message eq 'Dynamic client registration failed',
            'default message used';
    };

    # X::MCP::OAuth::TokenExchange with error but no description
    subtest 'TokenExchange error without description', {
        my $ex = X::MCP::OAuth::TokenExchange.new(error => 'bad_grant');
        nok $ex.message.contains(':'), 'no colon when no description';
        ok $ex.message.contains('exchange') || $ex.message.contains('Exchange') || $ex.message eq 'Token exchange failed',
            'default message used';
    };
};

done-testing;
