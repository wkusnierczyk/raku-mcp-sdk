use v6.d;
use Test;
use lib 'lib';

use MCP::OAuth;
use MCP::OAuth::Server;

plan 11;

# === 1. PKCE ===
subtest 'PKCE', {
    plan 4;
    my $pkce = PKCE.new;

    my $verifier = $pkce.generate-verifier;
    is $verifier.chars, 64, 'verifier is 64 characters';
    ok $verifier ~~ /^<[A..Za..z0..9\-._~]>+$/, 'verifier uses valid characters';

    my $challenge = $pkce.generate-challenge($verifier);
    ok $challenge.chars > 0, 'challenge is non-empty';
    nok $challenge ~~ /<[+=\/]>/, 'challenge is base64url (no +, =, /)';
};

# === 2. ProtectedResourceMetadata ===
subtest 'ProtectedResourceMetadata', {
    plan 4;
    my $meta = ProtectedResourceMetadata.new(
        resource => 'https://api.example.com',
        authorization-servers => ['https://auth.example.com'],
        scopes-supported => ['read', 'write'],
    );
    is $meta.resource, 'https://api.example.com', 'resource set';
    my %h = $meta.Hash;
    is %h<resource>, 'https://api.example.com', 'Hash roundtrip resource';
    is %h<authorization_servers>[0], 'https://auth.example.com', 'Hash roundtrip auth servers';

    my $from = ProtectedResourceMetadata.from-hash(%h);
    is $from.resource, 'https://api.example.com', 'from-hash roundtrip';
};

# === 3. AuthServerMetadata ===
subtest 'AuthServerMetadata', {
    plan 4;
    my $meta = AuthServerMetadata.new(
        issuer => 'https://auth.example.com',
        authorization-endpoint => 'https://auth.example.com/authorize',
        token-endpoint => 'https://auth.example.com/token',
        grant-types-supported => ['authorization_code'],
        code-challenge-methods-supported => ['S256'],
    );
    is $meta.issuer, 'https://auth.example.com', 'issuer set';
    my %h = $meta.Hash;
    is %h<token_endpoint>, 'https://auth.example.com/token', 'Hash roundtrip token endpoint';

    my $from = AuthServerMetadata.from-hash(%h);
    is $from.issuer, 'https://auth.example.com', 'from-hash roundtrip issuer';
    is $from.token-endpoint, 'https://auth.example.com/token', 'from-hash roundtrip token endpoint';
};

# === 4. TokenResponse ===
subtest 'TokenResponse', {
    plan 4;
    my $token = TokenResponse.new(
        access-token => 'abc123',
        token-type => 'Bearer',
        expires-in => 3600,
        refresh-token => 'refresh456',
        scope => 'read write',
    );
    is $token.access-token, 'abc123', 'access token set';
    nok $token.is-expired, 'fresh token is not expired';

    # Simulate expired token
    my $expired = TokenResponse.new(
        access-token => 'old',
        expires-in => 1,
        created-at => now - 100,
    );
    ok $expired.is-expired, 'old token is expired';

    my $from = TokenResponse.from-hash({
        access_token => 'xyz',
        token_type => 'Bearer',
        expires_in => 7200,
    });
    is $from.access-token, 'xyz', 'from-hash roundtrip';
};

# === 5. OAuthServerHandler ===
subtest 'OAuthServerHandler', {
    plan 5;
    my $handler = OAuthServerHandler.new(
        resource-identifier => 'https://api.example.com',
        authorization-servers => ['https://auth.example.com'],
        scopes-supported => ['read', 'write'],
        token-validator => -> Str $token {
            if $token eq 'valid-token' {
                { valid => True, sub => 'user1' }
            } else {
                { valid => False, message => 'Invalid token' }
            }
        },
    );

    my %meta = $handler.resource-metadata;
    is %meta<resource>, 'https://api.example.com', 'resource-metadata returns correct resource';
    ok %meta<authorization_servers>:exists, 'resource-metadata has auth servers';

    # Mock request with valid token
    my $valid-req = class { method header($n) { 'Bearer valid-token' } }.new;
    my %result = $handler.validate-request($valid-req);
    ok %result<valid>, 'valid token passes validation';

    # Mock request with invalid token
    my $invalid-req = class { method header($n) { 'Bearer bad-token' } }.new;
    dies-ok { $handler.validate-request($invalid-req) }, 'invalid token throws';

    # WWW-Authenticate header format
    my $www = $handler.www-authenticate-header;
    ok $www.contains('Bearer'), 'www-authenticate starts with Bearer';
};

# === 6. OAuthServerHandler scope header and Forbidden path ===
subtest 'OAuthServerHandler www-authenticate-scope-header', {
    plan 3;
    my $handler = OAuthServerHandler.new(
        resource-identifier => 'https://api.example.com',
        authorization-servers => ['https://auth.example.com'],
        scopes-supported => ['read', 'write'],
        token-validator => -> Str $token { { valid => False, scopes => ['read', 'write'], message => 'Insufficient scope' } },
    );

    my $scope-header = $handler.www-authenticate-scope-header(['read', 'write']);
    ok $scope-header.contains('Bearer'), 'scope header starts with Bearer';
    ok $scope-header.contains('insufficient_scope'), 'scope header has error';
    ok $scope-header.contains('read write'), 'scope header has scopes';
};

subtest 'OAuthServerHandler Forbidden with scopes', {
    plan 2;
    my $handler = OAuthServerHandler.new(
        resource-identifier => 'https://api.example.com',
        authorization-servers => ['https://auth.example.com'],
        scopes-supported => ['admin'],
        token-validator => -> Str $token {
            { valid => False, scopes => ['admin'], message => 'Need admin' }
        },
    );

    my $req = class { method header($n) { 'Bearer some-token' } }.new;
    try {
        $handler.validate-request($req);
        CATCH {
            when X::MCP::OAuth::Forbidden {
                ok True, 'Forbidden exception thrown';
                ok .message.contains('Need admin') || .message.contains('Insufficient'), 'Forbidden message';
            }
            default { flunk "Wrong exception: {.^name}" }
        }
    }
};

# === 7. OAuthClientHandler authorization-url ===
subtest 'OAuthClientHandler authorization-url', {
    plan 3;
    use MCP::OAuth::Client;

    my $client-handler = OAuthClientHandler.new(
        resource-url => 'https://api.example.com',
        client-id => 'test-client',
        scopes => ['read'],
        authorization-callback => -> Str $url { 'auth-code-123' },
    );

    # Manually set auth metadata to avoid HTTP calls
    $client-handler.auth-metadata = AuthServerMetadata.new(
        issuer => 'https://auth.example.com',
        authorization-endpoint => 'https://auth.example.com/authorize',
        token-endpoint => 'https://auth.example.com/token',
    );

    my $url = $client-handler.authorization-url;
    ok $url.contains('code_challenge='), 'URL contains code_challenge';
    ok $url.contains('client_id='), 'URL contains client_id';
    ok $url.contains('resource='), 'URL contains resource';
};

# === 7. Transport backwards compatibility ===
subtest 'Transport backwards compatibility', {
    plan 1;
    use MCP::Transport::StreamableHTTP;

    # Server transport without oauth-handler should work fine
    my $transport = StreamableHTTPServerTransport.new(
        path => '/mcp',
    );
    nok $transport.oauth-handler.defined, 'oauth-handler is optional (not defined by default)';
};

# === 10. ClientRegistrationRequest/Response types ===
subtest 'ClientRegistration types', {
    plan 6;

    my $req = ClientRegistrationRequest.new(
        redirect-uris => ['http://localhost:8080/callback'],
        client-name => 'Test App',
        grant-types => ['authorization_code', 'refresh_token'],
        response-types => ['code'],
        token-endpoint-auth-method => 'none',
        scope => 'read write',
    );
    my %h = $req.Hash;
    is %h<redirect_uris>[0], 'http://localhost:8080/callback', 'Hash redirect_uris';
    is %h<client_name>, 'Test App', 'Hash client_name';
    is %h<token_endpoint_auth_method>, 'none', 'Hash auth method';

    my $resp = ClientRegistrationResponse.from-hash({
        client_id => 'dyn-client-001',
        client_secret => 'secret-abc',
        client_secret_expires_at => 0,
        redirect_uris => ['http://localhost:8080/callback'],
        client_name => 'Test App',
        grant_types => ['authorization_code'],
        response_types => ['code'],
        token_endpoint_auth_method => 'none',
        scope => 'read write',
    });
    is $resp.client-id, 'dyn-client-001', 'from-hash client-id';
    is $resp.client-secret, 'secret-abc', 'from-hash client-secret';
    is $resp.scope, 'read write', 'from-hash scope';
};

# === 11. AuthServerMetadata with registration endpoint ===
subtest 'AuthServerMetadata registration endpoint', {
    plan 3;
    my $meta = AuthServerMetadata.new(
        issuer => 'https://auth.example.com',
        authorization-endpoint => 'https://auth.example.com/authorize',
        token-endpoint => 'https://auth.example.com/token',
        registration-endpoint => 'https://auth.example.com/register',
    );
    is $meta.registration-endpoint, 'https://auth.example.com/register', 'registration endpoint set';
    my %h = $meta.Hash;
    is %h<registration_endpoint>, 'https://auth.example.com/register', 'Hash roundtrip';
    my $from = AuthServerMetadata.from-hash(%h);
    is $from.registration-endpoint, 'https://auth.example.com/register', 'from-hash roundtrip';
};

done-testing;
