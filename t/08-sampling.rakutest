use v6.d;
use Test;
use lib 'lib';
use lib 't/lib';

use MCP::Client;
use MCP::Types;
need MCP::JSONRPC;
need TestTransport;

=begin pod
=head1 NAME

08-sampling.rakutest - Tests for sampling support

=head1 DESCRIPTION

Exercises client-side handling of sampling/createMessage requests.

=end pod

sub respond-to-init(TestTransport::TestTransport $transport) {
    my $req = $transport.sent[0];
    $transport.emit(MCP::JSONRPC::Response.success($req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'ready'
    }));
}

sub wait-for-response(TestTransport::TestTransport $transport, Int $id, Int $timeout = 100) {
    for ^($timeout * 20) {
        my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
        my $resp = @responses.first({ .id.Str eq $id.Str });
        return $resp if $resp;
        sleep 0.05;
    }
    Nil
}

subtest 'Sampling handler returns result', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        capabilities => MCP::Types::ClientCapabilities.new(
            sampling => MCP::Types::SamplingCapability.new(tools => True)
        ),
        transport => $transport,
        sampling-handler => -> %params {
            MCP::Types::CreateMessageResult.new(
                role => 'assistant',
                model => 'test-model',
                content => [ MCP::Types::TextContent.new(text => 'ok') ]
            )
        }
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    respond-to-init($transport);
    await $connect;

    $transport.clear-sent;
    my $req = MCP::JSONRPC::Request.new(
        id => 42,
        method => 'sampling/createMessage',
        params => {
            messages => [
                { role => 'user', content => [ { type => 'text', text => 'hi' } ] }
            ],
            maxTokens => 4,
            modelPreferences => {
                hints => [ { name => 'test-model' } ]
            }
        }
    );
    $transport.emit($req);

    my $resp = wait-for-response($transport, 42);
    unless $resp.defined {
        flunk 'response emitted';
        diag 'sampling response not received in time';
        return;
    }
    isa-ok $resp, MCP::JSONRPC::Response, 'response emitted';
    if $resp.error {
        diag "sampling error: {$resp.error.code} {$resp.error.message}";
    }
    ok !$resp.error, 'no error';
    is $resp.result<model>, 'test-model', 'model returned';
    is $resp.result<role>, 'assistant', 'role returned';
    is $resp.result<content>[0]<type>, 'text', 'content type';
};

subtest 'Sampling rejects tools when capability missing', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        capabilities => MCP::Types::ClientCapabilities.new(
            sampling => MCP::Types::SamplingCapability.new
        ),
        transport => $transport,
        sampling-handler => -> %params { { role => 'assistant', model => 'x', content => [ { type => 'text', text => 'ok' } ] } }
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    respond-to-init($transport);
    await $connect;

    $transport.clear-sent;
    my $req = MCP::JSONRPC::Request.new(
        id => 7,
        method => 'sampling/createMessage',
        params => {
            messages => [
                { role => 'user', content => [ { type => 'text', text => 'hi' } ] }
            ],
            tools => [ { name => 't', description => 'd', inputSchema => { type => 'object' } } ]
        }
    );
    $transport.emit($req);

    my $resp = wait-for-response($transport, 7);
    unless $resp.defined {
        flunk 'response emitted';
        diag 'sampling error response not received in time';
        return;
    }
    isa-ok $resp, MCP::JSONRPC::Response, 'response emitted';
    if $resp.error {
        diag "sampling error (tool result): {$resp.error.code} {$resp.error.message}";
    }
    ok $resp.error.defined, 'error returned';
    is $resp.error.code, MCP::JSONRPC::InvalidParams.value, 'invalid params';
};

subtest 'Sampling enforces tool result placement', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        capabilities => MCP::Types::ClientCapabilities.new(
            sampling => MCP::Types::SamplingCapability.new(tools => True)
        ),
        transport => $transport,
        sampling-handler => -> %params { { role => 'assistant', model => 'x', content => [ { type => 'text', text => 'ok' } ] } }
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    respond-to-init($transport);
    await $connect;

    $transport.clear-sent;
    my $req = MCP::JSONRPC::Request.new(
        id => 9,
        method => 'sampling/createMessage',
        params => {
            messages => [
                { role => 'assistant', content => [ { type => 'tool_result', toolUseId => 'x', content => [ { type => 'text', text => 'bad' } ] } ] }
            ]
        }
    );
    $transport.emit($req);

    my $resp = wait-for-response($transport, 9);
    unless $resp.defined {
        flunk 'response emitted';
        diag 'sampling error response not received in time';
        return;
    }
    isa-ok $resp, MCP::JSONRPC::Response, 'response emitted';
    ok $resp.error.defined, 'error returned';
    is $resp.error.code, MCP::JSONRPC::InvalidParams.value, 'invalid params';
};

subtest 'Sampling with tools passes tools to handler', {
    my $transport = TestTransport::TestTransport.new;
    my $received-tools;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        capabilities => MCP::Types::ClientCapabilities.new(
            sampling => MCP::Types::SamplingCapability.new(tools => True)
        ),
        transport => $transport,
        sampling-handler => -> %params {
            $received-tools = %params<tools>;
            MCP::Types::CreateMessageResult.new(
                role => 'assistant',
                model => 'test-model',
                content => [ MCP::Types::TextContent.new(text => 'used tool') ],
                stopReason => 'tool_use',
            )
        }
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    respond-to-init($transport);
    await $connect;

    $transport.clear-sent;
    my $req = MCP::JSONRPC::Request.new(
        id => 50,
        method => 'sampling/createMessage',
        params => {
            messages => [
                { role => 'user', content => [ { type => 'text', text => 'use a tool' } ] }
            ],
            tools => [
                %( name => 'calculator', description => 'Math', inputSchema => %( type => 'object', properties => %( expr => %( type => 'string' ) ) ) ),
            ],
            toolChoice => %( mode => 'auto' ),
        }
    );
    $transport.emit($req);

    my $resp = wait-for-response($transport, 50);
    unless $resp.defined {
        flunk 'response emitted';
        diag 'sampling response not received in time';
        return;
    }
    ok !$resp.error, 'no error with tools';
    ok $received-tools.defined, 'handler received tools';
    is $received-tools[0]<name>, 'calculator', 'tool name passed through';
    is $resp.result<stopReason>, 'tool_use', 'stopReason preserved';
};

subtest 'Sampling validates tool definitions', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        capabilities => MCP::Types::ClientCapabilities.new(
            sampling => MCP::Types::SamplingCapability.new(tools => True)
        ),
        transport => $transport,
        sampling-handler => -> %params { { role => 'assistant', model => 'x', content => [ { type => 'text', text => 'ok' } ] } }
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    respond-to-init($transport);
    await $connect;

    # Missing inputSchema
    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 60,
        method => 'sampling/createMessage',
        params => {
            messages => [ { role => 'user', content => [ { type => 'text', text => 'hi' } ] } ],
            tools => [ %( name => 'bad-tool' ), ],
        }
    ));
    my $resp = wait-for-response($transport, 60);
    unless $resp.defined {
        flunk 'response emitted';
        diag 'sampling error response not received in time';
        return;
    }
    ok $resp.error.defined, 'error for missing inputSchema';
    is $resp.error.code, MCP::JSONRPC::InvalidParams.value, 'invalid params code';

    # Missing name
    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 61,
        method => 'sampling/createMessage',
        params => {
            messages => [ { role => 'user', content => [ { type => 'text', text => 'hi' } ] } ],
            tools => [ %( inputSchema => %( type => 'object' ) ), ],
        }
    ));
    my $resp2 = wait-for-response($transport, 61);
    unless $resp2.defined {
        flunk 'response emitted';
        diag 'sampling error response not received in time';
        return;
    }
    ok $resp2.error.defined, 'error for missing name';
};

subtest 'Sampling rejects includeContext without capability', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        capabilities => MCP::Types::ClientCapabilities.new(
            sampling => MCP::Types::SamplingCapability.new
        ),
        transport => $transport,
        sampling-handler => -> %params { { role => 'assistant', model => 'x', content => [ { type => 'text', text => 'ok' } ] } }
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    respond-to-init($transport);
    await $connect;

    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 70,
        method => 'sampling/createMessage',
        params => {
            messages => [ { role => 'user', content => [ { type => 'text', text => 'hi' } ] } ],
            includeContext => 'allServers',
        }
    ));
    my $resp = wait-for-response($transport, 70);
    unless $resp.defined {
        flunk 'response emitted';
        diag 'sampling error response not received in time';
        return;
    }
    ok $resp.error.defined, 'error when includeContext without capability';
    is $resp.error.code, MCP::JSONRPC::InvalidParams.value, 'invalid params';
};

subtest 'Sampling accepts includeContext with capability', {
    my $transport = TestTransport::TestTransport.new;
    my $received-context;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        capabilities => MCP::Types::ClientCapabilities.new(
            sampling => MCP::Types::SamplingCapability.new(context => True)
        ),
        transport => $transport,
        sampling-handler => -> %params {
            $received-context = %params<includeContext>;
            { role => 'assistant', model => 'x', content => [ { type => 'text', text => 'ok' } ] }
        }
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    respond-to-init($transport);
    await $connect;

    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 80,
        method => 'sampling/createMessage',
        params => {
            messages => [ { role => 'user', content => [ { type => 'text', text => 'hi' } ] } ],
            includeContext => 'allServers',
        }
    ));
    my $resp = wait-for-response($transport, 80);
    unless $resp.defined {
        flunk 'response emitted';
        diag 'sampling response not received in time';
        return;
    }
    ok !$resp.error, 'no error with includeContext capability';
    is $received-context, 'allServers', 'includeContext passed to handler';
};

subtest 'SamplingCapability Hash includes context', {
    my $cap = MCP::Types::SamplingCapability.new(tools => True, context => True);
    my %h = $cap.Hash;
    ok %h<tools>:exists, 'tools in Hash';
    ok %h<context>:exists, 'context in Hash';

    my $cap2 = MCP::Types::SamplingCapability.new;
    my %h2 = $cap2.Hash;
    nok %h2<tools>:exists, 'no tools when not set';
    nok %h2<context>:exists, 'no context when not set';
};

done-testing;
