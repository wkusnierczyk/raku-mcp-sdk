use v6.d;
use Test;
use lib 'lib';
use lib 't/lib';

use MCP::Server;
use MCP::Client;
use MCP::Types;
need MCP::JSONRPC;
use MCP::Server::Tool;
use MCP::Server::Resource;
use MCP::Server::Prompt;
need TestTransport;
use JSON::Fast;

=begin pod
=head1 NAME

18-coverage-gaps.rakutest - Tests for previously uncovered functionality

=head1 DESCRIPTION

Covers gaps identified in coverage analysis: server create-message,
handler exceptions, builder edge cases, type round-trips, client
content parsing, and more.

=end pod

use MONKEY-TYPING;
augment class MCP::Server::Server {
    method handle-message-public($msg) { self!handle-message($msg) }
    method handle-response-public($msg) { self!handle-response($msg) }
}

# =============================================================================
# Server create-message
# =============================================================================

subtest 'Server create-message', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $transport.clear-sent;
    my $msg-promise = $server.create-message(
        messages => [
            SamplingMessage.new(role => 'user', content => TextContent.new(text => 'Hello')),
        ],
        maxTokens => 100,
        systemPrompt => 'Be concise',
        modelPreferences => ModelPreferences.new(
            hints => [ModelHint.new(name => 'fast')],
            speedPriority => 0.9e0,
        ),
    );

    my @requests = $transport.sent.grep(MCP::JSONRPC::Request);
    is @requests.elems, 1, 'create-message sends request';
    is @requests[0].method, 'sampling/createMessage', 'method is sampling/createMessage';
    is @requests[0].params<maxTokens>, 100, 'maxTokens passed';
    is @requests[0].params<systemPrompt>, 'Be concise', 'systemPrompt passed';
    ok @requests[0].params<modelPreferences>.defined, 'modelPreferences passed';
    ok @requests[0].params<messages>.elems == 1, 'messages passed';

    # Simulate response
    $server.handle-response-public(MCP::JSONRPC::Response.success(@requests[0].id, {
        role => 'assistant',
        model => 'test-model',
        content => { type => 'text', text => 'Hi there' },
        stopReason => 'endTurn',
    }));

    my $result = await $msg-promise;
    isa-ok $result, CreateMessageResult, 'returns CreateMessageResult';
    is $result.role, 'assistant', 'role correct';
    is $result.model, 'test-model', 'model correct';
};

subtest 'Server create-message with tools and toolChoice', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $transport.clear-sent;
    my $p = $server.create-message(
        messages => [
            SamplingMessage.new(role => 'user', content => TextContent.new(text => 'calc')),
        ],
        tools => [
            Tool.new(name => 'calc', inputSchema => { type => 'object' }),
        ],
        toolChoice => ToolChoice.new(mode => 'tool', name => 'calc'),
    );

    my @requests = $transport.sent.grep(MCP::JSONRPC::Request);
    ok @requests[0].params<tools>.elems == 1, 'tools passed';
    is @requests[0].params<tools>[0]<name>, 'calc', 'tool name serialized';
    is @requests[0].params<toolChoice><mode>, 'tool', 'toolChoice serialized';

    $server.handle-response-public(MCP::JSONRPC::Response.success(@requests[0].id, {
        role => 'assistant', model => 'm', stopReason => 'endTurn', content => { type => 'text', text => 'ok' },
    }));
    await $p;
    pass 'create-message with tools completes';
};

# =============================================================================
# Client content parsing for all types
# =============================================================================

subtest 'Client parses all content types', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, {
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => '',
    }));
    await $connect;

    # Call tool that returns various content types
    $transport.clear-sent;
    my $call-p = $client.call-tool('multi');
    $transport.await-sent;

    my @req = $transport.sent.grep(MCP::JSONRPC::Request);
    $transport.emit(MCP::JSONRPC::Response.success(@req[0].id, {
        content => [
            { type => 'text', text => 'hello' },
            { type => 'image', data => 'abc', mimeType => 'image/png' },
            { type => 'audio', data => 'wav', mimeType => 'audio/wav' },
            { type => 'resource', resource => { uri => 'file:///x', mimeType => 'text/plain', text => 'embedded' } },
            { type => 'resource_link', name => 'doc', uri => 'file:///doc', title => 'Doc', description => 'A doc', mimeType => 'application/pdf', size => 1024 },
            { type => 'tool_use', id => 'tu-1', name => 'calc', input => { x => 1 } },
            { type => 'tool_result', toolUseId => 'tu-1', content => [{ type => 'text', text => 'result' }], isError => False },
        ],
    }));

    my $result = await $call-p;
    is $result.content.elems, 7, '7 content items parsed';

    isa-ok $result.content[0], TextContent, 'text parsed';
    is $result.content[0].text, 'hello', 'text value';

    isa-ok $result.content[1], ImageContent, 'image parsed';
    is $result.content[1].mimeType, 'image/png', 'image mimeType';

    isa-ok $result.content[2], AudioContent, 'audio parsed';
    is $result.content[2].mimeType, 'audio/wav', 'audio mimeType';

    isa-ok $result.content[3], EmbeddedResource, 'embedded resource parsed';
    is $result.content[3].resource.text, 'embedded', 'embedded text';

    isa-ok $result.content[4], ResourceLink, 'resource link parsed';
    is $result.content[4].name, 'doc', 'resource link name';
    is $result.content[4].size, 1024, 'resource link size';

    isa-ok $result.content[5], ToolUseContent, 'tool_use parsed';
    is $result.content[5].id, 'tu-1', 'tool_use id';

    isa-ok $result.content[6], ToolResultContent, 'tool_result parsed';
    is $result.content[6].toolUseId, 'tu-1', 'tool_result toolUseId';
    ok $result.content[6].content.elems >= 1, 'tool_result has nested content';
};

# =============================================================================
# Builder: task-support / execution
# =============================================================================

subtest 'Tool builder task-support', {
    my $t = tool()
        .name('async-tool')
        .task-support('required')
        .handler(-> { 'ok' })
        .build;

    ok $t.execution.defined, 'execution set';
    is $t.execution.taskSupport, TaskRequired, 'taskSupport is required';

    my $tool-def = $t.to-tool;
    ok $tool-def.execution.defined, 'execution on Tool definition';

    my %h = $tool-def.Hash;
    ok %h<execution>.defined, 'execution in Hash';
    is %h<execution><taskSupport>, 'required', 'taskSupport serialized';

    # Test all levels
    for <forbidden optional required> -> $level {
        my $b = tool().name("t-$level").task-support($level).handler(-> { 'ok' }).build;
        ok $b.execution.defined, "execution set for $level";
    }
};

# =============================================================================
# Handler dispatch fallback chain
# =============================================================================

subtest 'Handler dispatch fallback signatures', {
    # Handler with no params
    my $no-args = RegisteredTool.new(
        name => 'no-args',
        handler => -> { 'no-args-result' }
    );
    is $no-args.call({}).content[0].text, 'no-args-result', 'no-args handler works';

    # Handler with Hash positional
    my $hash-arg = RegisteredTool.new(
        name => 'hash-arg',
        handler => -> %h { "got: %h<x>" }
    );
    is $hash-arg.call({ x => 42 }).content[0].text, 'got: 42', 'Hash positional handler works';

    # Handler with :params named pair
    my $named = RegisteredTool.new(
        name => 'named',
        handler => -> :%params { "named: %params<y>" }
    );
    is $named.call({ y => 7 }).content[0].text, 'named: 7', ':params named handler works';
};

subtest 'Prompt generator dispatch fallback', {
    # Generator with no params
    my $no-args = RegisteredPrompt.new(
        name => 'no-args',
        generator => -> { 'static message' }
    );
    is $no-args.get({})[0].content.text, 'static message', 'no-args generator';

    # Generator with Hash positional
    my $hash-gen = RegisteredPrompt.new(
        name => 'hash-gen',
        generator => -> %h { "topic: %h<topic>" }
    );
    is $hash-gen.get({ topic => 'raku' })[0].content.text, 'topic: raku', 'Hash positional generator';
};

# =============================================================================
# Type round-trips
# =============================================================================

subtest 'ElicitationResponse round-trip', {
    my $resp = ElicitationResponse.new(
        action => ElicitAccept,
        content => { name => 'test', age => 25 }
    );
    my %h = $resp.Hash;
    my $restored = ElicitationResponse.from-hash(%h);
    is $restored.action, ElicitAccept, 'action survives round-trip';
    is $restored.content<name>, 'test', 'content survives round-trip';

    # Decline round-trip
    my $decline = ElicitationResponse.new(action => ElicitDecline);
    my $d2 = ElicitationResponse.from-hash($decline.Hash);
    is $d2.action, ElicitDecline, 'decline round-trip';
};

subtest 'Task type round-trip', {
    my $task = Task.new(
        taskId => 'task-abc',
        status => TaskWorking,
        createdAt => '2025-01-01T00:00:00Z',
        lastUpdatedAt => '2025-01-01T00:00:01Z',
        ttl => 30000,
        pollInterval => 1000,
    );
    my %h = $task.Hash;
    is %h<taskId>, 'task-abc', 'taskId in Hash';
    is %h<status>, 'working', 'status serialized';
    ok %h<ttl>.defined, 'ttl in Hash';

    my $restored = Task.from-hash(%h);
    is $restored.taskId, 'task-abc', 'from-hash taskId';
    is $restored.status, TaskWorking, 'from-hash status';
    nok $restored.is-terminal, 'working is not terminal';

    # Terminal states
    ok Task.new(taskId => 'x', status => TaskCompleted).is-terminal, 'completed is terminal';
    ok Task.new(taskId => 'x', status => TaskFailed).is-terminal, 'failed is terminal';
    ok Task.new(taskId => 'x', status => TaskCancelled).is-terminal, 'cancelled is terminal';
    nok Task.new(taskId => 'x', status => TaskInputRequired).is-terminal, 'input-required is not terminal';
};

subtest 'ResourceTemplate type round-trip', {
    my $rt = ResourceTemplate.new(
        uriTemplate => 'file:///{path}',
        name => 'Files',
        description => 'File access',
        mimeType => 'text/plain',
        title => 'File Browser',
    );
    my %h = $rt.Hash;
    is %h<uriTemplate>, 'file:///{path}', 'uriTemplate in Hash';
    is %h<title>, 'File Browser', 'title in Hash';

    my $restored = ResourceTemplate.from-hash(%h);
    is $restored.uriTemplate, 'file:///{path}', 'from-hash uriTemplate';
    is $restored.title, 'File Browser', 'from-hash title';
};

subtest 'SamplingMessage and CreateMessageResult round-trip', {
    my $msg = SamplingMessage.new(
        role => 'user',
        content => TextContent.new(text => 'hi'),
    );
    my %h = $msg.Hash;
    is %h<role>, 'user', 'role in Hash';
    is %h<content><text>, 'hi', 'content in Hash';

    my $result = CreateMessageResult.new(
        role => 'assistant',
        model => 'test',
        content => { type => 'text', text => 'reply' },
        stopReason => 'endTurn',
    );
    my %rh = $result.Hash;
    is %rh<role>, 'assistant', 'result role';
    is %rh<model>, 'test', 'result model';
    is %rh<stopReason>, 'endTurn', 'result stopReason';
};

# =============================================================================
# Server: notify-resources-list-changed, notify-prompts-list-changed
# =============================================================================

subtest 'Resource and prompt list change notifications', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $transport.clear-sent;
    $server.notify-resources-list-changed();
    $server.notify-prompts-list-changed();

    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 2, 'two notifications sent';
    is @notifications[0].method, 'notifications/resources/list_changed', 'resource list changed';
    is @notifications[1].method, 'notifications/prompts/list_changed', 'prompt list changed';
};

# =============================================================================
# Server: logging with logger field
# =============================================================================

subtest 'Logging with logger field', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $transport.clear-sent;
    $server.log(Info, 'test data', logger => 'myapp');

    my @notifs = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifs.elems, 1, 'log notification sent';
    is @notifs[0].params<level>, 'info', 'level correct';
    is @notifs[0].params<data>, 'test data', 'data correct';
    is @notifs[0].params<logger>, 'myapp', 'logger field present';

    # Without logger
    $transport.clear-sent;
    $server.log(Warning, 'warn msg');
    @notifs = $transport.sent.grep(MCP::JSONRPC::Notification);
    nok @notifs[0].params<logger>:exists, 'no logger when not provided';
};

# =============================================================================
# Server: logging/setLevel missing param
# =============================================================================

subtest 'logging/setLevel missing level param', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $transport.clear-sent;
    $server.handle-message-public(MCP::JSONRPC::Request.new(
        id => 'log-1',
        method => 'logging/setLevel',
        params => {}
    ));

    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @responses[0].error.defined, 'missing level returns error';
    is @responses[0].error.code, MCP::JSONRPC::InvalidParams.value, 'InvalidParams error';
};

# =============================================================================
# Server: remove-resource-template
# =============================================================================

subtest 'Server remove-resource-template', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $server.add-resource-template(
        uri-template => 'file:///{path}',
        name => 'files',
        reader => -> %p { 'content' }
    );

    my $list = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1, method => 'resources/templates/list'
    ));
    is $list<resourceTemplates>.elems, 1, 'template registered';

    $server.remove-resource-template('files');

    my $list2 = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 2, method => 'resources/templates/list'
    ));
    is $list2<resourceTemplates>.elems, 0, 'template removed';
};

# =============================================================================
# Server: unregister-extension
# =============================================================================

subtest 'Server unregister-extension', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $server.register-extension(name => 'test/ext', version => '1.0');
    my $caps = $server.capabilities;
    ok $caps.experimental.defined, 'extension in capabilities';
    ok $caps.experimental<test/ext>:exists, 'test/ext registered';

    $server.unregister-extension('test/ext');
    my $caps2 = $server.capabilities;
    # After removing last extension, experimental may be empty
    my $still = $caps2.experimental.defined && ($caps2.experimental<test/ext>:exists);
    nok $still, 'test/ext unregistered';
};

# =============================================================================
# Client: elicitation handler exception
# =============================================================================

subtest 'Client elicitation handler exception', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport,
        elicitation-handler => -> %params { die "Elicitation failed!" },
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, {
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => '',
    }));
    await $connect;
    $transport.clear-sent;

    # Server sends elicitation request
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 'e-1',
        method => 'elicitation/create',
        params => { mode => 'form', message => 'Enter name', requestedSchema => {} }
    ));

    sleep 0.3;
    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @responses.elems >= 1, 'response sent';
    ok @responses[0].error.defined, 'error response for failed handler';
    is @responses[0].error.code, MCP::JSONRPC::InternalError.value, 'InternalError code';
};

# =============================================================================
# Client: no elicitation handler
# =============================================================================

subtest 'Client without elicitation handler', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport,
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, {
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => '',
    }));
    await $connect;
    $transport.clear-sent;

    $transport.emit(MCP::JSONRPC::Request.new(
        id => 'e-2',
        method => 'elicitation/create',
        params => { mode => 'form', message => 'test' }
    ));

    sleep 0.3;
    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @responses.elems >= 1, 'response sent';
    ok @responses[0].error.defined, 'error for missing handler';
    is @responses[0].error.code, MCP::JSONRPC::MethodNotFound.value, 'MethodNotFound';
};

# =============================================================================
# Client: unknown server request method
# =============================================================================

subtest 'Client rejects unknown server request', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport,
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, {
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => '',
    }));
    await $connect;
    $transport.clear-sent;

    $transport.emit(MCP::JSONRPC::Request.new(
        id => 'unk-1',
        method => 'unknown/serverMethod',
        params => {}
    ));

    sleep 0.3;
    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @responses.elems >= 1, 'response sent';
    ok @responses[0].error.defined, 'error for unknown method';
    is @responses[0].error.code, MCP::JSONRPC::MethodNotFound.value, 'MethodNotFound';
};

# =============================================================================
# Server: handler exception propagation
# =============================================================================

subtest 'Server tool handler exception types', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    # Tool that throws a structured MCP error
    $server.add-tool(
        name => 'mcp-error',
        handler => -> {
            die X::MCP::JSONRPC.new(
                error => MCP::JSONRPC::Error.from-code(
                    MCP::JSONRPC::InvalidParams,
                    "Bad input: missing field"
                )
            );
        }
    );

    $transport.clear-sent;
    $server.handle-message-public(MCP::JSONRPC::Request.new(
        id => 'err-mcp',
        method => 'tools/call',
        params => { name => 'mcp-error', arguments => {} }
    ));

    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @responses[0].error.defined, 'MCP error propagated';
    is @responses[0].error.code, MCP::JSONRPC::InvalidParams.value, 'InvalidParams code preserved';
    ok @responses[0].error.message.contains('Bad input'), 'custom message preserved';
};

# =============================================================================
# Server: is-cancelled edge cases
# =============================================================================

subtest 'Server is-cancelled and cancel-request edge cases', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    # Unknown request
    nok $server.is-cancelled('nonexistent'), 'is-cancelled returns False for nonexistent ID';

    # cancel-request for unknown ID still sends notification
    $transport.clear-sent;
    $server.cancel-request('unknown-req');
    my @notifs = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifs.elems, 1, 'cancel-request sends notification even for unknown ID';
};

# =============================================================================
# Server: is-subscribed
# =============================================================================

subtest 'Server is-subscribed', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    nok $server.is-subscribed('file://x'), 'not subscribed initially';

    $server.add-resource(uri => 'file://x', name => 'X', reader => { 'data' });
    $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1, method => 'resources/subscribe', params => { uri => 'file://x' }
    ));
    ok $server.is-subscribed('file://x'), 'subscribed after subscribe';
};

# =============================================================================
# Resource template URI matching edge cases
# =============================================================================

subtest 'Resource template URI matching', {
    my $template = resource-template()
        .uri-template('https://api.example.com/users/{userId}/posts/{postId}')
        .name('user-posts')
        .reader(-> %p { "user=%p<userId> post=%p<postId>" })
        .build;

    # Match
    my $match = $template.match-uri('https://api.example.com/users/123/posts/456');
    ok $match.defined, 'multi-variable match';
    is $match<userId>, '123', 'first variable extracted';
    is $match<postId>, '456', 'second variable extracted';

    # No match - wrong prefix
    my $no-match = $template.match-uri('https://other.com/users/1/posts/2');
    nok $no-match.defined, 'different host does not match';

    # No match - missing segment
    nok $template.match-uri('https://api.example.com/users/123').defined, 'incomplete URI no match';

    # Last variable is greedy - consumes trailing content
    my $greedy = $template.match-uri('https://api.example.com/users/123/posts/456/extra');
    ok $greedy.defined, 'last variable is greedy';
    is $greedy<postId>, '456/extra', 'greedy captures trailing content';

    # Read through template
    my @contents = $template.read({ userId => 'u1', postId => 'p1' });
    is @contents[0].text, 'user=u1 post=p1', 'template reader receives params';
};

# =============================================================================
# Object-param builder method
# =============================================================================

subtest 'Tool builder object-param', {
    my $t = tool()
        .name('obj-tool')
        .handler(-> { 'ok' });

    # object-param is defined in the pod but let's check if it's implemented
    if $t.can('object-param') {
        $t.object-param('config', description => 'Config object', :required);
        my $built = $t.build;
        ok $built.inputSchema<properties><config>:exists, 'object param added';
        is $built.inputSchema<properties><config><type>, 'object', 'type is object';
    } else {
        skip 'object-param not implemented', 1;
    }
};

# =============================================================================
# Server: tasks/list
# =============================================================================

subtest 'Server tasks/list', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    # Register a tool
    $server.add-tool(
        name => 'slow',
        handler => -> { sleep 0.5; 'done' }
    );

    # Create a task
    my $create = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1,
        method => 'tools/call',
        params => { name => 'slow', arguments => {}, task => { ttl => 5000 } }
    ));
    ok $create<task>.defined, 'task created';
    my $task-id = $create<task><taskId>;
    ok $task-id.defined, 'task has ID';

    # List tasks
    my $list = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 2, method => 'tasks/list'
    ));
    ok $list<tasks>.elems >= 1, 'tasks/list returns at least 1 task';
    ok $list<tasks>.grep(*<taskId> eq $task-id).elems == 1, 'created task in list';
};

# =============================================================================
# Server: error response for unknown resource read
# =============================================================================

subtest 'Server resources/read unknown resource', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $transport.clear-sent;
    $server.handle-message-public(MCP::JSONRPC::Request.new(
        id => 'read-1',
        method => 'resources/read',
        params => { uri => 'file://nonexistent' }
    ));

    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @responses[0].error.defined, 'unknown resource returns error';
    ok @responses[0].error.message.contains('Unknown resource'), 'error message mentions unknown';
};

# =============================================================================
# Client: sampling handler exception
# =============================================================================

subtest 'Client sampling handler exception', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport,
        capabilities => ClientCapabilities.new(
            sampling => SamplingCapability.new,
        ),
        sampling-handler => -> %params { die "Handler crashed!" },
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, {
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => '',
    }));
    await $connect;
    $transport.clear-sent;

    $transport.emit(MCP::JSONRPC::Request.new(
        id => 's-1',
        method => 'sampling/createMessage',
        params => {
            messages => [{ role => 'user', content => { type => 'text', text => 'hi' } }],
            maxTokens => 100,
        }
    ));

    sleep 0.3;
    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @responses.elems >= 1, 'response sent';
    ok @responses[0].error.defined, 'error response for crashed handler';
    is @responses[0].error.code, MCP::JSONRPC::InternalError.value, 'InternalError code';
};

# =============================================================================
# Content annotations round-trip
# =============================================================================

subtest 'TextContent with annotations Hash round-trip', {
    my $tc = TextContent.new(
        text => 'annotated',
        annotations => Annotations.new(audience => ['user'], priority => 0.7e0),
    );
    my %h = $tc.Hash;
    is %h<type>, 'text', 'type preserved';
    is %h<text>, 'annotated', 'text preserved';
    ok %h<annotations>:exists, 'annotations in Hash';
    is %h<annotations><priority>, 0.7e0, 'priority in annotations';
    is-deeply %h<annotations><audience>, ['user'], 'audience in annotations';
};

# =============================================================================
# Server: response to error from pending request
# =============================================================================

subtest 'Server handles error response from client', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $transport.clear-sent;
    my $p = $server.request('sampling/createMessage', { messages => [] });
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    my $req-id = @reqs[0].id;

    # Simulate error response
    $server.handle-response-public(MCP::JSONRPC::Response.error($req-id,
        MCP::JSONRPC::Error.from-code(MCP::JSONRPC::MethodNotFound, 'Not supported')
    ));

    dies-ok { await $p }, 'error response breaks promise';
};

# =============================================================================
# JSONRPC: Error with data field in Hash
# =============================================================================

subtest 'JSONRPC Error Hash with and without data', {
    my $with-data = MCP::JSONRPC::Error.new(
        code => -32600,
        message => 'Bad request',
        data => { detail => 'missing field' },
    );
    my %h1 = $with-data.Hash;
    is %h1<code>, -32600, 'code in Hash';
    is %h1<data><detail>, 'missing field', 'data in Hash';

    my $no-data = MCP::JSONRPC::Error.new(code => -32601, message => 'Not found');
    my %h2 = $no-data.Hash;
    nok %h2<data>:exists, 'no data when not set';
};

done-testing;
