use v6.d;

=begin pod
=head1 NAME

01-types.rakutest - Tests for MCP type definitions

=head1 DESCRIPTION

Validates core MCP type constructors and serialization behavior.

=end pod

use Test;
use lib 'lib';

use MCP::Types;

plan 45;

# Test Implementation
subtest 'Implementation', {
    my $impl = Implementation.new(name => 'test', version => '1.0');
    is $impl.name, 'test', 'name is correct';
    is $impl.version, '1.0', 'version is correct';

    my %h = $impl.Hash;
    is %h<name>, 'test', 'Hash has name';
    is %h<version>, '1.0', 'Hash has version';
};

# Test TextContent
subtest 'TextContent', {
    my $content = TextContent.new(text => 'Hello, World!');
    is $content.text, 'Hello, World!', 'text is correct';
    is $content.type, 'text', 'type is text';

    my %h = $content.Hash;
    is %h<type>, 'text', 'Hash has type';
    is %h<text>, 'Hello, World!', 'Hash has text';
};

# Test ImageContent
subtest 'ImageContent', {
    my $content = ImageContent.new(data => 'base64data', mimeType => 'image/png');
    is $content.data, 'base64data', 'data is correct';
    is $content.mimeType, 'image/png', 'mimeType is correct';
    is $content.type, 'image', 'type is image';
};

# Test Tool
subtest 'Tool', {
    my $tool = Tool.new(
        name => 'test_tool',
        description => 'A test tool',
        inputSchema => { type => 'object', properties => {} },
    );
    is $tool.name, 'test_tool', 'name is correct';
    is $tool.description, 'A test tool', 'description is correct';

    my %h = $tool.Hash;
    is %h<name>, 'test_tool', 'Hash has name';
    is %h<description>, 'A test tool', 'Hash has description';
};

# Test Tool with outputSchema
subtest 'Tool outputSchema', {
    my $schema = { type => 'object', properties => { temp => { type => 'number' } } };
    my $tool = Tool.new(
        name => 'weather',
        description => 'Get weather',
        outputSchema => $schema,
    );
    ok $tool.outputSchema.defined, 'outputSchema is defined';
    is $tool.outputSchema<type>, 'object', 'outputSchema type correct';

    # Hash serialization
    my %h = $tool.Hash;
    ok %h<outputSchema>:exists, 'Hash has outputSchema';
    is %h<outputSchema><type>, 'object', 'Hash outputSchema type';

    # from-hash roundtrip
    my $restored = Tool.from-hash(%h);
    ok $restored.outputSchema.defined, 'from-hash restores outputSchema';
    is $restored.outputSchema<properties><temp><type>, 'number', 'from-hash preserves schema detail';

    # Tool without outputSchema
    my $no-schema = Tool.new(name => 'plain');
    my %h2 = $no-schema.Hash;
    nok %h2<outputSchema>:exists, 'no outputSchema when not set';

    my $restored2 = Tool.from-hash(%h2);
    nok $restored2.outputSchema.defined, 'from-hash without outputSchema';
};

# Test CallToolResult with structuredContent
subtest 'CallToolResult structuredContent', {
    my $result = CallToolResult.new(
        content => [TextContent.new(text => 'fallback')],
        structuredContent => { temperature => 72, conditions => 'sunny' },
    );
    ok $result.structuredContent.defined, 'structuredContent defined';
    is $result.structuredContent<temperature>, 72, 'structuredContent value';

    my %h = $result.Hash;
    ok %h<structuredContent>:exists, 'Hash has structuredContent';
    is %h<structuredContent><conditions>, 'sunny', 'Hash structuredContent value';
    ok %h<content>.elems >= 1, 'Hash also has content';

    # Without structuredContent
    my $plain = CallToolResult.new(
        content => [TextContent.new(text => 'ok')],
    );
    nok $plain.structuredContent.defined, 'no structuredContent when not set';
    my %h2 = $plain.Hash;
    nok %h2<structuredContent>:exists, 'Hash has no structuredContent';
};

# Test ToolAnnotations
subtest 'ToolAnnotations', {
    my $ann = ToolAnnotations.new(
        title => 'Test Tool',
        readOnlyHint => True,
        destructiveHint => False,
    );
    is $ann.title, 'Test Tool', 'title is correct';
    is $ann.readOnlyHint, True, 'readOnlyHint is correct';
    is $ann.destructiveHint, False, 'destructiveHint is correct';
};

# Test CallToolResult
subtest 'CallToolResult', {
    my $result = CallToolResult.new(
        content => [TextContent.new(text => 'Result')],
        isError => False,
    );
    is $result.content.elems, 1, 'has one content item';
    is $result.isError, False, 'isError is false';
};

# Test Resource
subtest 'Resource', {
    my $res = Resource.new(
        uri => 'file:///test.txt',
        name => 'Test File',
        description => 'A test file',
        mimeType => 'text/plain',
    );
    is $res.uri, 'file:///test.txt', 'uri is correct';
    is $res.name, 'Test File', 'name is correct';
    is $res.mimeType, 'text/plain', 'mimeType is correct';
};

# Test ResourceContents
subtest 'ResourceContents', {
    my $contents = ResourceContents.new(
        uri => 'file:///test.txt',
        mimeType => 'text/plain',
        text => 'File contents',
    );
    is $contents.uri, 'file:///test.txt', 'uri is correct';
    is $contents.text, 'File contents', 'text is correct';
};

# Test PromptArgument
subtest 'PromptArgument', {
    my $arg = PromptArgument.new(
        name => 'topic',
        description => 'The topic to discuss',
        required => True,
    );
    is $arg.name, 'topic', 'name is correct';
    is $arg.required, True, 'required is correct';
};

# Test Prompt
subtest 'Prompt', {
    my $prompt = Prompt.new(
        name => 'explain',
        description => 'Explain a concept',
        arguments => [
            PromptArgument.new(name => 'topic', required => True),
        ],
    );
    is $prompt.name, 'explain', 'name is correct';
    is $prompt.arguments.elems, 1, 'has one argument';
};

# Test PromptMessage
subtest 'PromptMessage', {
    my $msg = PromptMessage.new(
        role => 'user',
        content => TextContent.new(text => 'Hello'),
    );
    is $msg.role, 'user', 'role is correct';
    isa-ok $msg.content, TextContent, 'content is TextContent';
};

# Test ServerCapabilities
subtest 'ServerCapabilities', {
    my $caps = ServerCapabilities.new(
        tools => ToolsCapability.new(listChanged => True),
        resources => ResourcesCapability.new(subscribe => True),
    );
    ok $caps.tools.defined, 'tools defined';
    ok $caps.resources.defined, 'resources defined';
    is $caps.tools.listChanged, True, 'tools.listChanged is true';
};

# Test ClientCapabilities
subtest 'ClientCapabilities', {
    my $caps = ClientCapabilities.new(
        roots => RootsCapability.new(listChanged => True),
        sampling => SamplingCapability.new,
    );
    ok $caps.roots.defined, 'roots defined';
    ok $caps.sampling.defined, 'sampling defined';
};

# Test Progress
subtest 'Progress', {
    my $progress = Progress.new(
        progressToken => 'task-1',
        progress => 50e0,
        total => 100e0,
        message => 'Processing...',
    );
    is $progress.progressToken, 'task-1', 'token is correct';
    is $progress.progress, 50e0, 'progress is correct';
    is $progress.total, 100e0, 'total is correct';
};

# Test LogLevel
subtest 'LogLevel', {
    is Debug.value, 'debug', 'Debug value';
    is Info.value, 'info', 'Info value';
    is Warning.value, 'warning', 'Warning value';
    is Error.value, 'error', 'Error value';

    # parse-log-level
    is parse-log-level('debug'), Debug, 'parse debug';
    is parse-log-level('warning'), Warning, 'parse warning';
    is parse-log-level('emergency'), Emergency, 'parse emergency';
    dies-ok { parse-log-level('nonexistent') }, 'parse invalid level dies';

    # log-level-at-or-above
    ok log-level-at-or-above(Warning, Debug), 'Warning >= Debug';
    ok log-level-at-or-above(Warning, Warning), 'Warning >= Warning';
    nok log-level-at-or-above(Debug, Warning), 'Debug < Warning';
    ok log-level-at-or-above(Emergency, Emergency), 'Emergency >= Emergency';
    nok log-level-at-or-above(Alert, Emergency), 'Alert < Emergency';
};

# Test LogEntry
subtest 'LogEntry', {
    my $entry = LogEntry.new(
        level => Info,
        logger => 'test',
        data => 'Test message',
    );
    is $entry.level, Info, 'level is correct';
    is $entry.logger, 'test', 'logger is correct';
    is $entry.data, 'Test message', 'data is correct';
};

# Test Protocol Version Constants
subtest 'Protocol Constants', {
    ok LATEST_PROTOCOL_VERSION.defined, 'LATEST_PROTOCOL_VERSION defined';
    ok SUPPORTED_PROTOCOL_VERSIONS.elems > 0, 'SUPPORTED_PROTOCOL_VERSIONS has items';
    ok LATEST_PROTOCOL_VERSION (elem) SUPPORTED_PROTOCOL_VERSIONS,
        'Latest version is in supported list';
};

# Test Annotations
subtest 'Annotations', {
    my $ann = Annotations.new(
        audience => ['user', 'assistant'],
        priority => 0.5e0,
    );
    is $ann.audience.elems, 2, 'has two audience items';
    is $ann.priority, 0.5e0, 'priority is correct';
};

# Test Tool with annotations
subtest 'Tool with Annotations', {
    my $ann = ToolAnnotations.new(
        title => 'Calculator',
        readOnlyHint => True,
        idempotentHint => True,
    );
    my $tool = Tool.new(
        name => 'add',
        description => 'Add numbers',
        annotations => $ann,
    );
    ok $tool.annotations.defined, 'has annotations';
    is $tool.annotations.title, 'Calculator', 'annotation title correct';
};

# Test serialization round-trip
subtest 'Hash serialization', {
    use JSON::Fast;

    my $tool = Tool.new(
        name => 'test',
        description => 'Test tool',
        inputSchema => { type => 'object', properties => { x => { type => 'number' } } },
    );

    my $json = to-json($tool.Hash);
    my %restored = from-json($json);

    is %restored<name>, 'test', 'name survives round-trip';
    is %restored<description>, 'Test tool', 'description survives round-trip';
    ok %restored<inputSchema>:exists, 'inputSchema survives round-trip';
};

# Test empty capabilities
subtest 'Empty capabilities', {
    my $caps = ServerCapabilities.new();
    my %h = $caps.Hash;
    is %h.keys.elems, 0, 'empty capabilities has no keys';
};

# Test Content role
subtest 'Content role', {
    my $text = TextContent.new(text => 'hello');
    my $image = ImageContent.new(data => 'abc', mimeType => 'image/png');

    ok $text ~~ Content, 'TextContent does Content role';
    ok $image ~~ Content, 'ImageContent does Content role';
};

# Test ResourceContents with blob
subtest 'ResourceContents with blob', {
    my $blob = Buf.new(0x48, 0x65, 0x6c, 0x6c, 0x6f);  # "Hello"
    my $contents = ResourceContents.new(
        uri => 'file:///binary.bin',
        mimeType => 'application/octet-stream',
        blob => $blob,
    );
    ok $contents.blob.defined, 'blob is defined';
    is $contents.blob.elems, 5, 'blob has correct size';
};

# Test Root type
subtest 'Root', {
    my $root = Root.new(
        uri => 'file:///home/user/project',
        name => 'Project Root',
    );
    is $root.uri, 'file:///home/user/project', 'uri is correct';
    is $root.name, 'Project Root', 'name is correct';

    my %h = $root.Hash;
    is %h<uri>, 'file:///home/user/project', 'Hash has uri';
    is %h<name>, 'Project Root', 'Hash has name';

    # Test without optional name
    my $root-no-name = Root.new(uri => 'file:///tmp');
    my %h2 = $root-no-name.Hash;
    is %h2<uri>, 'file:///tmp', 'Hash has uri without name';
    nok %h2<name>:exists, 'Hash has no name when not provided';

    # Test from-hash
    my $restored = Root.from-hash({ uri => 'file:///restored', name => 'Restored' });
    is $restored.uri, 'file:///restored', 'from-hash restores uri';
    is $restored.name, 'Restored', 'from-hash restores name';
};

# Test CompletionsCapability
subtest 'CompletionsCapability', {
    my $cap = CompletionsCapability.new;
    my %h = $cap.Hash;
    is %h.keys.elems, 0, 'empty hash';
};

# Test CompletionResult
subtest 'CompletionResult', {
    my $result = CompletionResult.new(
        values => <alpha beta gamma>,
        total => 10,
        hasMore => True,
    );
    is $result.values.elems, 3, 'has 3 values';
    is $result.total, 10, 'total is 10';
    ok $result.hasMore, 'hasMore is true';

    my %h = $result.Hash;
    is %h<values>.elems, 3, 'Hash has values';
    is %h<total>, 10, 'Hash has total';
    ok %h<hasMore>, 'Hash hasMore';

    # from-hash
    my $restored = CompletionResult.from-hash(%h);
    is $restored.values.elems, 3, 'from-hash restores values';
    is $restored.total, 10, 'from-hash restores total';

    # Without optional fields
    my $minimal = CompletionResult.new(values => ['x']);
    my %h2 = $minimal.Hash;
    nok %h2<total>:exists, 'no total when not set';
    nok %h2<hasMore>:exists, 'no hasMore when not set';
};

# Test ElicitationAction enum
subtest 'ElicitationAction', {
    is ElicitAccept.value, 'accept', 'accept value';
    is ElicitDecline.value, 'decline', 'decline value';
    is ElicitCancel.value, 'cancel', 'cancel value';
};

# Test ElicitationCapability
subtest 'ElicitationCapability', {
    # Default (form only)
    my $cap-default = ElicitationCapability.new;
    ok $cap-default.supports-form, 'default supports form';
    nok $cap-default.supports-url, 'default does not support url';
    my %h-default = $cap-default.Hash;
    ok %h-default<form>:exists, 'default Hash has form';
    nok %h-default<url>:exists, 'default Hash has no url';

    # Both modes
    my $cap-both = ElicitationCapability.new(:form, :url);
    ok $cap-both.supports-form, 'both supports form';
    ok $cap-both.supports-url, 'both supports url';
    my %h-both = $cap-both.Hash;
    ok %h-both<form>:exists, 'both Hash has form';
    ok %h-both<url>:exists, 'both Hash has url';

    # from-hash
    my $from-empty = ElicitationCapability.from-hash({});
    ok $from-empty.supports-form, 'empty hash defaults to form';
    nok $from-empty.supports-url, 'empty hash has no url';

    my $from-url = ElicitationCapability.from-hash({ url => {} });
    ok $from-url.supports-url, 'from-hash with url';
};

# Test ElicitationResponse
subtest 'ElicitationResponse', {
    # Accept with content
    my $accept = ElicitationResponse.new(
        action => ElicitAccept,
        content => { name => 'test', age => 25 }
    );
    is $accept.action, ElicitAccept, 'accept action';
    is $accept.content<name>, 'test', 'accept has content';
    my %h-accept = $accept.Hash;
    is %h-accept<action>, 'accept', 'Hash has action';
    is %h-accept<content><name>, 'test', 'Hash has content';

    # Decline
    my $decline = ElicitationResponse.new(action => ElicitDecline);
    is $decline.action, ElicitDecline, 'decline action';
    my %h-decline = $decline.Hash;
    is %h-decline<action>, 'decline', 'decline Hash';
    nok %h-decline<content>:exists, 'decline has no content';

    # Cancel
    my $cancel = ElicitationResponse.new(action => ElicitCancel);
    is $cancel.action, ElicitCancel, 'cancel action';

    # from-hash
    my $restored = ElicitationResponse.from-hash({
        action => 'accept',
        content => { email => 'test@example.com' }
    });
    is $restored.action, ElicitAccept, 'from-hash restores accept';
    is $restored.content<email>, 'test@example.com', 'from-hash restores content';
};

# Test ImageContent Hash serialization
subtest 'ImageContent Hash', {
    my $img = ImageContent.new(data => 'abc123', mimeType => 'image/png');
    my %h = $img.Hash;
    is %h<type>, 'image', 'type is image';
    is %h<data>, 'abc123', 'data preserved';
    is %h<mimeType>, 'image/png', 'mimeType preserved';
    nok %h<annotations>:exists, 'no annotations when not set';

    my $with-ann = ImageContent.new(
        data => 'x', mimeType => 'image/jpeg',
        annotations => Annotations.new(audience => ['user'], priority => 0.8e0),
    );
    my %h2 = $with-ann.Hash;
    ok %h2<annotations>:exists, 'annotations included';
    is %h2<annotations><priority>, 0.8e0, 'annotation priority';
};

# Test AudioContent Hash serialization
subtest 'AudioContent Hash', {
    my $audio = AudioContent.new(data => 'audiodata', mimeType => 'audio/wav');
    my %h = $audio.Hash;
    is %h<type>, 'audio', 'type is audio';
    is %h<data>, 'audiodata', 'data preserved';
    is %h<mimeType>, 'audio/wav', 'mimeType preserved';

    my $with-ann = AudioContent.new(
        data => 'x', mimeType => 'audio/mp3',
        annotations => Annotations.new(audience => ['assistant']),
    );
    ok $with-ann.Hash<annotations>:exists, 'annotations included';
};

# Test EmbeddedResource Hash serialization
subtest 'EmbeddedResource Hash', {
    my $rc = ResourceContents.new(uri => 'file:///test', mimeType => 'text/plain', text => 'hi');
    my $er = EmbeddedResource.new(resource => $rc);
    my %h = $er.Hash;
    is %h<type>, 'resource', 'type is resource';
    is %h<resource><uri>, 'file:///test', 'resource uri';
    nok %h<annotations>:exists, 'no annotations';

    my $with-ann = EmbeddedResource.new(
        resource => $rc,
        annotations => Annotations.new(priority => 0.3e0),
    );
    ok $with-ann.Hash<annotations>:exists, 'annotations included';
};

# Test ResourceLink Hash serialization
subtest 'ResourceLink Hash', {
    my $rl = ResourceLink.new(name => 'doc', uri => 'file:///doc.pdf',
        title => 'Doc', description => 'A doc', mimeType => 'application/pdf', size => 1024);
    my %h = $rl.Hash;
    is %h<type>, 'resource_link', 'type';
    is %h<name>, 'doc', 'name';
    is %h<uri>, 'file:///doc.pdf', 'uri';
    is %h<title>, 'Doc', 'title';
    is %h<description>, 'A doc', 'description';
    is %h<mimeType>, 'application/pdf', 'mimeType';
    is %h<size>, 1024, 'size';

    # Minimal
    my $min = ResourceLink.new(name => 'x', uri => 'y');
    my %h2 = $min.Hash;
    nok %h2<title>:exists, 'no title';
    nok %h2<size>:exists, 'no size';
};

# Test ToolUseContent Hash
subtest 'ToolUseContent Hash', {
    my $tu = ToolUseContent.new(id => 'call-1', name => 'calc', input => { expr => '1+1' });
    my %h = $tu.Hash;
    is %h<type>, 'tool_use', 'type';
    is %h<id>, 'call-1', 'id';
    is %h<name>, 'calc', 'name';
    is %h<input><expr>, '1+1', 'input';
};

# Test ToolResultContent Hash
subtest 'ToolResultContent Hash', {
    my $tr = ToolResultContent.new(
        toolUseId => 'call-1',
        content => [TextContent.new(text => 'result')],
        isError => True,
        structuredContent => { val => 42 },
        meta => { requestId => 'r1' },
    );
    my %h = $tr.Hash;
    is %h<type>, 'tool_result', 'type';
    is %h<toolUseId>, 'call-1', 'toolUseId';
    ok %h<isError>, 'isError';
    is %h<structuredContent><val>, 42, 'structuredContent';
    is %h<_meta><requestId>, 'r1', 'meta';
    is %h<content>[0]<type>, 'text', 'content serialized';
};

# Test ModelHint Hash
subtest 'ModelHint Hash', {
    my $hint = ModelHint.new(name => 'claude-3');
    my %h = $hint.Hash;
    is %h<name>, 'claude-3', 'name in Hash';
};

# Test ModelPreferences Hash
subtest 'ModelPreferences Hash', {
    my $prefs = ModelPreferences.new(
        hints => [ModelHint.new(name => 'fast')],
        costPriority => 0.5e0,
        speedPriority => 0.8e0,
        intelligencePriority => 0.3e0,
    );
    my %h = $prefs.Hash;
    is %h<hints>[0]<name>, 'fast', 'hint name';
    is %h<costPriority>, 0.5e0, 'costPriority';
    is %h<speedPriority>, 0.8e0, 'speedPriority';
    is %h<intelligencePriority>, 0.3e0, 'intelligencePriority';

    # Minimal
    my $min = ModelPreferences.new;
    my %h2 = $min.Hash;
    nok %h2<hints>:exists, 'no hints';
    nok %h2<costPriority>:exists, 'no costPriority';
};

# Test ToolChoice Hash
subtest 'ToolChoice Hash', {
    my $tc = ToolChoice.new(mode => 'tool', name => 'calc');
    my %h = $tc.Hash;
    is %h<mode>, 'tool', 'mode';
    is %h<name>, 'calc', 'name';

    my $auto = ToolChoice.new(mode => 'auto');
    my %h2 = $auto.Hash;
    is %h2<mode>, 'auto', 'auto mode';
    nok %h2<name>:exists, 'no name for auto';
};

# Test ServerCapabilities from-hash roundtrip
subtest 'ServerCapabilities from-hash', {
    my $caps = ServerCapabilities.new(
        experimental => { 'test/ext' => {} },
        logging => LoggingCapability.new,
        prompts => PromptsCapability.new(listChanged => True),
        resources => ResourcesCapability.new(subscribe => True, listChanged => True),
        tools => ToolsCapability.new(listChanged => True),
        completions => CompletionsCapability.new,
        tasks => { list => {} },
    );
    my %h = $caps.Hash;
    ok %h<experimental>:exists, 'experimental in Hash';
    ok %h<tasks>:exists, 'tasks in Hash';

    my $restored = ServerCapabilities.from-hash(%h);
    ok $restored.tools.defined, 'from-hash restores tools';
    ok $restored.tasks.defined, 'from-hash restores tasks';
};

# Test IconDefinition
subtest 'IconDefinition', {
    my $icon = IconDefinition.new(
        src => 'https://example.com/icon.png',
        mimeType => 'image/png',
        sizes => ['48x48', '96x96'],
    );
    is $icon.src, 'https://example.com/icon.png', 'src correct';
    is $icon.mimeType, 'image/png', 'mimeType correct';
    is $icon.sizes.elems, 2, 'sizes count';

    my %h = $icon.Hash;
    is %h<src>, 'https://example.com/icon.png', 'Hash src';
    is %h<mimeType>, 'image/png', 'Hash mimeType';
    is %h<sizes>.elems, 2, 'Hash sizes';

    # from-hash round-trip
    my $restored = IconDefinition.from-hash(%h);
    is $restored.src, $icon.src, 'from-hash src';
    is $restored.mimeType, $icon.mimeType, 'from-hash mimeType';
    is $restored.sizes.elems, 2, 'from-hash sizes';

    # Minimal (src only)
    my $min = IconDefinition.new(src => 'data:image/svg+xml,...');
    my %h2 = $min.Hash;
    is %h2<src>, 'data:image/svg+xml,...', 'minimal src';
    nok %h2<mimeType>:exists, 'no mimeType when not set';
    nok %h2<sizes>:exists, 'no sizes when empty';
};

# Test icons and title on Tool
subtest 'Tool with icons and title', {
    my $icon = IconDefinition.new(src => 'https://example.com/tool.png', mimeType => 'image/png');
    my $tool = Tool.new(
        name => 'icon_tool',
        title => 'Icon Tool',
        icons => [$icon],
    );
    is $tool.title, 'Icon Tool', 'title correct';
    is $tool.icons.elems, 1, 'icons count';

    my %h = $tool.Hash;
    is %h<title>, 'Icon Tool', 'Hash title';
    is %h<icons>[0]<src>, 'https://example.com/tool.png', 'Hash icon src';

    my $restored = Tool.from-hash(%h);
    is $restored.title, 'Icon Tool', 'from-hash title';
    is $restored.icons.elems, 1, 'from-hash icons';
    is $restored.icons[0].src, 'https://example.com/tool.png', 'from-hash icon src';

    # Without title/icons
    my $plain = Tool.new(name => 'plain');
    my %h2 = $plain.Hash;
    nok %h2<title>:exists, 'no title when not set';
    nok %h2<icons>:exists, 'no icons when empty';
};

# Test icons and title on Resource and Prompt
subtest 'Resource and Prompt with icons and title', {
    my $icon = IconDefinition.new(src => 'https://example.com/res.png');
    my $res = Resource.new(uri => 'file:///x', name => 'X', title => 'X Resource', icons => [$icon]);
    is $res.title, 'X Resource', 'resource title';
    my %rh = $res.Hash;
    is %rh<title>, 'X Resource', 'resource Hash title';
    is %rh<icons>[0]<src>, 'https://example.com/res.png', 'resource Hash icon';

    my $res2 = Resource.from-hash(%rh);
    is $res2.title, 'X Resource', 'resource from-hash title';
    is $res2.icons[0].src, 'https://example.com/res.png', 'resource from-hash icon';

    my $prompt = Prompt.new(name => 'p', title => 'Prompt Title', icons => [$icon]);
    is $prompt.title, 'Prompt Title', 'prompt title';
    my %ph = $prompt.Hash;
    is %ph<title>, 'Prompt Title', 'prompt Hash title';

    my $prompt2 = Prompt.from-hash(%ph);
    is $prompt2.title, 'Prompt Title', 'prompt from-hash title';
};

# Test icons and title on Implementation
subtest 'Implementation with icons and title', {
    my $icon = IconDefinition.new(src => 'https://example.com/server.png', mimeType => 'image/png');
    my $impl = Implementation.new(name => 'srv', version => '1.0', title => 'My Server', icons => [$icon]);
    is $impl.title, 'My Server', 'title correct';
    is $impl.icons[0].src, 'https://example.com/server.png', 'icon src';

    my %h = $impl.Hash;
    is %h<title>, 'My Server', 'Hash title';
    is %h<icons>[0]<src>, 'https://example.com/server.png', 'Hash icon';

    my $restored = Implementation.from-hash(%h);
    is $restored.title, 'My Server', 'from-hash title';
    is $restored.icons[0].src, 'https://example.com/server.png', 'from-hash icon';

    # Without title/icons
    my $plain = Implementation.new(name => 'x', version => '0.1');
    my %h2 = $plain.Hash;
    nok %h2<title>:exists, 'no title';
    nok %h2<icons>:exists, 'no icons';
};

done-testing;
