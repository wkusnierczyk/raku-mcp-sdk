use v6.d;

=begin pod
=head1 NAME

01-types.rakutest - Tests for MCP type definitions

=head1 DESCRIPTION

Validates core MCP type constructors and serialization behavior.

=end pod

use Test;
use lib 'lib';

use MCP::Types;

plan 27;

# Test Implementation
subtest 'Implementation', {
    my $impl = Implementation.new(name => 'test', version => '1.0');
    is $impl.name, 'test', 'name is correct';
    is $impl.version, '1.0', 'version is correct';

    my %h = $impl.Hash;
    is %h<name>, 'test', 'Hash has name';
    is %h<version>, '1.0', 'Hash has version';
};

# Test TextContent
subtest 'TextContent', {
    my $content = TextContent.new(text => 'Hello, World!');
    is $content.text, 'Hello, World!', 'text is correct';
    is $content.type, 'text', 'type is text';

    my %h = $content.Hash;
    is %h<type>, 'text', 'Hash has type';
    is %h<text>, 'Hello, World!', 'Hash has text';
};

# Test ImageContent
subtest 'ImageContent', {
    my $content = ImageContent.new(data => 'base64data', mimeType => 'image/png');
    is $content.data, 'base64data', 'data is correct';
    is $content.mimeType, 'image/png', 'mimeType is correct';
    is $content.type, 'image', 'type is image';
};

# Test Tool
subtest 'Tool', {
    my $tool = Tool.new(
        name => 'test_tool',
        description => 'A test tool',
        inputSchema => { type => 'object', properties => {} },
    );
    is $tool.name, 'test_tool', 'name is correct';
    is $tool.description, 'A test tool', 'description is correct';

    my %h = $tool.Hash;
    is %h<name>, 'test_tool', 'Hash has name';
    is %h<description>, 'A test tool', 'Hash has description';
};

# Test ToolAnnotations
subtest 'ToolAnnotations', {
    my $ann = ToolAnnotations.new(
        title => 'Test Tool',
        readOnlyHint => True,
        destructiveHint => False,
    );
    is $ann.title, 'Test Tool', 'title is correct';
    is $ann.readOnlyHint, True, 'readOnlyHint is correct';
    is $ann.destructiveHint, False, 'destructiveHint is correct';
};

# Test CallToolResult
subtest 'CallToolResult', {
    my $result = CallToolResult.new(
        content => [TextContent.new(text => 'Result')],
        isError => False,
    );
    is $result.content.elems, 1, 'has one content item';
    is $result.isError, False, 'isError is false';
};

# Test Resource
subtest 'Resource', {
    my $res = Resource.new(
        uri => 'file:///test.txt',
        name => 'Test File',
        description => 'A test file',
        mimeType => 'text/plain',
    );
    is $res.uri, 'file:///test.txt', 'uri is correct';
    is $res.name, 'Test File', 'name is correct';
    is $res.mimeType, 'text/plain', 'mimeType is correct';
};

# Test ResourceContents
subtest 'ResourceContents', {
    my $contents = ResourceContents.new(
        uri => 'file:///test.txt',
        mimeType => 'text/plain',
        text => 'File contents',
    );
    is $contents.uri, 'file:///test.txt', 'uri is correct';
    is $contents.text, 'File contents', 'text is correct';
};

# Test PromptArgument
subtest 'PromptArgument', {
    my $arg = PromptArgument.new(
        name => 'topic',
        description => 'The topic to discuss',
        required => True,
    );
    is $arg.name, 'topic', 'name is correct';
    is $arg.required, True, 'required is correct';
};

# Test Prompt
subtest 'Prompt', {
    my $prompt = Prompt.new(
        name => 'explain',
        description => 'Explain a concept',
        arguments => [
            PromptArgument.new(name => 'topic', required => True),
        ],
    );
    is $prompt.name, 'explain', 'name is correct';
    is $prompt.arguments.elems, 1, 'has one argument';
};

# Test PromptMessage
subtest 'PromptMessage', {
    my $msg = PromptMessage.new(
        role => 'user',
        content => TextContent.new(text => 'Hello'),
    );
    is $msg.role, 'user', 'role is correct';
    isa-ok $msg.content, TextContent, 'content is TextContent';
};

# Test ServerCapabilities
subtest 'ServerCapabilities', {
    my $caps = ServerCapabilities.new(
        tools => ToolsCapability.new(listChanged => True),
        resources => ResourcesCapability.new(subscribe => True),
    );
    ok $caps.tools.defined, 'tools defined';
    ok $caps.resources.defined, 'resources defined';
    is $caps.tools.listChanged, True, 'tools.listChanged is true';
};

# Test ClientCapabilities
subtest 'ClientCapabilities', {
    my $caps = ClientCapabilities.new(
        roots => RootsCapability.new(listChanged => True),
        sampling => SamplingCapability.new,
    );
    ok $caps.roots.defined, 'roots defined';
    ok $caps.sampling.defined, 'sampling defined';
};

# Test Progress
subtest 'Progress', {
    my $progress = Progress.new(
        progressToken => 'task-1',
        progress => 50e0,
        total => 100e0,
        message => 'Processing...',
    );
    is $progress.progressToken, 'task-1', 'token is correct';
    is $progress.progress, 50e0, 'progress is correct';
    is $progress.total, 100e0, 'total is correct';
};

# Test LogLevel
subtest 'LogLevel', {
    is Debug.value, 'debug', 'Debug value';
    is Info.value, 'info', 'Info value';
    is Warning.value, 'warning', 'Warning value';
    is Error.value, 'error', 'Error value';
};

# Test LogEntry
subtest 'LogEntry', {
    my $entry = LogEntry.new(
        level => Info,
        logger => 'test',
        data => 'Test message',
    );
    is $entry.level, Info, 'level is correct';
    is $entry.logger, 'test', 'logger is correct';
    is $entry.data, 'Test message', 'data is correct';
};

# Test Protocol Version Constants
subtest 'Protocol Constants', {
    ok LATEST_PROTOCOL_VERSION.defined, 'LATEST_PROTOCOL_VERSION defined';
    ok SUPPORTED_PROTOCOL_VERSIONS.elems > 0, 'SUPPORTED_PROTOCOL_VERSIONS has items';
    ok LATEST_PROTOCOL_VERSION (elem) SUPPORTED_PROTOCOL_VERSIONS,
        'Latest version is in supported list';
};

# Test Annotations
subtest 'Annotations', {
    my $ann = Annotations.new(
        audience => ['user', 'assistant'],
        priority => 0.5e0,
    );
    is $ann.audience.elems, 2, 'has two audience items';
    is $ann.priority, 0.5e0, 'priority is correct';
};

# Test Tool with annotations
subtest 'Tool with Annotations', {
    my $ann = ToolAnnotations.new(
        title => 'Calculator',
        readOnlyHint => True,
        idempotentHint => True,
    );
    my $tool = Tool.new(
        name => 'add',
        description => 'Add numbers',
        annotations => $ann,
    );
    ok $tool.annotations.defined, 'has annotations';
    is $tool.annotations.title, 'Calculator', 'annotation title correct';
};

# Test serialization round-trip
subtest 'Hash serialization', {
    use JSON::Fast;

    my $tool = Tool.new(
        name => 'test',
        description => 'Test tool',
        inputSchema => { type => 'object', properties => { x => { type => 'number' } } },
    );

    my $json = to-json($tool.Hash);
    my %restored = from-json($json);

    is %restored<name>, 'test', 'name survives round-trip';
    is %restored<description>, 'Test tool', 'description survives round-trip';
    ok %restored<inputSchema>:exists, 'inputSchema survives round-trip';
};

# Test empty capabilities
subtest 'Empty capabilities', {
    my $caps = ServerCapabilities.new();
    my %h = $caps.Hash;
    is %h.keys.elems, 0, 'empty capabilities has no keys';
};

# Test Content role
subtest 'Content role', {
    my $text = TextContent.new(text => 'hello');
    my $image = ImageContent.new(data => 'abc', mimeType => 'image/png');

    ok $text ~~ Content, 'TextContent does Content role';
    ok $image ~~ Content, 'ImageContent does Content role';
};

# Test ResourceContents with blob
subtest 'ResourceContents with blob', {
    my $blob = Buf.new(0x48, 0x65, 0x6c, 0x6c, 0x6f);  # "Hello"
    my $contents = ResourceContents.new(
        uri => 'file:///binary.bin',
        mimeType => 'application/octet-stream',
        blob => $blob,
    );
    ok $contents.blob.defined, 'blob is defined';
    is $contents.blob.elems, 5, 'blob has correct size';
};

# Test Root type
subtest 'Root', {
    my $root = Root.new(
        uri => 'file:///home/user/project',
        name => 'Project Root',
    );
    is $root.uri, 'file:///home/user/project', 'uri is correct';
    is $root.name, 'Project Root', 'name is correct';

    my %h = $root.Hash;
    is %h<uri>, 'file:///home/user/project', 'Hash has uri';
    is %h<name>, 'Project Root', 'Hash has name';

    # Test without optional name
    my $root-no-name = Root.new(uri => 'file:///tmp');
    my %h2 = $root-no-name.Hash;
    is %h2<uri>, 'file:///tmp', 'Hash has uri without name';
    nok %h2<name>:exists, 'Hash has no name when not provided';

    # Test from-hash
    my $restored = Root.from-hash({ uri => 'file:///restored', name => 'Restored' });
    is $restored.uri, 'file:///restored', 'from-hash restores uri';
    is $restored.name, 'Restored', 'from-hash restores name';
};

# Test ElicitationAction enum
subtest 'ElicitationAction', {
    is ElicitAccept.value, 'accept', 'accept value';
    is ElicitDecline.value, 'decline', 'decline value';
    is ElicitCancel.value, 'cancel', 'cancel value';
};

# Test ElicitationCapability
subtest 'ElicitationCapability', {
    # Default (form only)
    my $cap-default = ElicitationCapability.new;
    ok $cap-default.supports-form, 'default supports form';
    nok $cap-default.supports-url, 'default does not support url';
    my %h-default = $cap-default.Hash;
    ok %h-default<form>:exists, 'default Hash has form';
    nok %h-default<url>:exists, 'default Hash has no url';

    # Both modes
    my $cap-both = ElicitationCapability.new(:form, :url);
    ok $cap-both.supports-form, 'both supports form';
    ok $cap-both.supports-url, 'both supports url';
    my %h-both = $cap-both.Hash;
    ok %h-both<form>:exists, 'both Hash has form';
    ok %h-both<url>:exists, 'both Hash has url';

    # from-hash
    my $from-empty = ElicitationCapability.from-hash({});
    ok $from-empty.supports-form, 'empty hash defaults to form';
    nok $from-empty.supports-url, 'empty hash has no url';

    my $from-url = ElicitationCapability.from-hash({ url => {} });
    ok $from-url.supports-url, 'from-hash with url';
};

# Test ElicitationResponse
subtest 'ElicitationResponse', {
    # Accept with content
    my $accept = ElicitationResponse.new(
        action => ElicitAccept,
        content => { name => 'test', age => 25 }
    );
    is $accept.action, ElicitAccept, 'accept action';
    is $accept.content<name>, 'test', 'accept has content';
    my %h-accept = $accept.Hash;
    is %h-accept<action>, 'accept', 'Hash has action';
    is %h-accept<content><name>, 'test', 'Hash has content';

    # Decline
    my $decline = ElicitationResponse.new(action => ElicitDecline);
    is $decline.action, ElicitDecline, 'decline action';
    my %h-decline = $decline.Hash;
    is %h-decline<action>, 'decline', 'decline Hash';
    nok %h-decline<content>:exists, 'decline has no content';

    # Cancel
    my $cancel = ElicitationResponse.new(action => ElicitCancel);
    is $cancel.action, ElicitCancel, 'cancel action';

    # from-hash
    my $restored = ElicitationResponse.from-hash({
        action => 'accept',
        content => { email => 'test@example.com' }
    });
    is $restored.action, ElicitAccept, 'from-hash restores accept';
    is $restored.content<email>, 'test@example.com', 'from-hash restores content';
};

done-testing;
