use v6.d;

=begin pod
=head1 NAME

01-types.rakutest - Tests for MCP type definitions

=head1 DESCRIPTION

Validates core MCP type constructors and serialization behavior.

=end pod

use Test;
use lib 'lib';

use MCP::Types;
use JSON::Fast;

sub j(%h) { $(from-json(to-json(%h))) }

plan *;

# Test Implementation
subtest 'Implementation', {
    my $impl = Implementation.new(name => 'test', version => '1.0');
    is $impl.name, 'test', 'name is correct';
    is $impl.version, '1.0', 'version is correct';

    my %h = $impl.Hash;
    is %h<name>, 'test', 'Hash has name';
    is %h<version>, '1.0', 'Hash has version';
};

# Test TextContent
subtest 'TextContent', {
    my $content = TextContent.new(text => 'Hello, World!');
    is $content.text, 'Hello, World!', 'text is correct';
    is $content.type, 'text', 'type is text';

    my %h = $content.Hash;
    is %h<type>, 'text', 'Hash has type';
    is %h<text>, 'Hello, World!', 'Hash has text';
};

# Test ImageContent
subtest 'ImageContent', {
    my $content = ImageContent.new(data => 'base64data', mimeType => 'image/png');
    is $content.data, 'base64data', 'data is correct';
    is $content.mimeType, 'image/png', 'mimeType is correct';
    is $content.type, 'image', 'type is image';
};

# Test Tool
subtest 'Tool', {
    my $tool = Tool.new(
        name => 'test_tool',
        description => 'A test tool',
        inputSchema => { type => 'object', properties => {} },
    );
    is $tool.name, 'test_tool', 'name is correct';
    is $tool.description, 'A test tool', 'description is correct';

    my %h = $tool.Hash;
    is %h<name>, 'test_tool', 'Hash has name';
    is %h<description>, 'A test tool', 'Hash has description';
};

# Test Tool with outputSchema
subtest 'Tool outputSchema', {
    my $schema = { type => 'object', properties => { temp => { type => 'number' } } };
    my $tool = Tool.new(
        name => 'weather',
        description => 'Get weather',
        outputSchema => $schema,
    );
    ok $tool.outputSchema.defined, 'outputSchema is defined';
    is $tool.outputSchema<type>, 'object', 'outputSchema type correct';

    # Hash serialization
    my %h = $tool.Hash;
    ok %h<outputSchema>:exists, 'Hash has outputSchema';
    is %h<outputSchema><type>, 'object', 'Hash outputSchema type';

    # from-hash roundtrip
    my $restored = Tool.from-hash(%h);
    ok $restored.outputSchema.defined, 'from-hash restores outputSchema';
    is $restored.outputSchema<properties><temp><type>, 'number', 'from-hash preserves schema detail';

    # Tool without outputSchema
    my $no-schema = Tool.new(name => 'plain');
    my %h2 = $no-schema.Hash;
    nok %h2<outputSchema>:exists, 'no outputSchema when not set';

    my $restored2 = Tool.from-hash(%h2);
    nok $restored2.outputSchema.defined, 'from-hash without outputSchema';
};

# Test CallToolResult with structuredContent
subtest 'CallToolResult structuredContent', {
    my $result = CallToolResult.new(
        content => [TextContent.new(text => 'fallback')],
        structuredContent => { temperature => 72, conditions => 'sunny' },
    );
    ok $result.structuredContent.defined, 'structuredContent defined';
    is $result.structuredContent<temperature>, 72, 'structuredContent value';

    my %h = $result.Hash;
    ok %h<structuredContent>:exists, 'Hash has structuredContent';
    is %h<structuredContent><conditions>, 'sunny', 'Hash structuredContent value';
    ok %h<content>.elems >= 1, 'Hash also has content';

    # Without structuredContent
    my $plain = CallToolResult.new(
        content => [TextContent.new(text => 'ok')],
    );
    nok $plain.structuredContent.defined, 'no structuredContent when not set';
    my %h2 = $plain.Hash;
    nok %h2<structuredContent>:exists, 'Hash has no structuredContent';
};

# Test ToolAnnotations
subtest 'ToolAnnotations', {
    my $ann = ToolAnnotations.new(
        title => 'Test Tool',
        readOnlyHint => True,
        destructiveHint => False,
    );
    is $ann.title, 'Test Tool', 'title is correct';
    is $ann.readOnlyHint, True, 'readOnlyHint is correct';
    is $ann.destructiveHint, False, 'destructiveHint is correct';
};

# Test CallToolResult
subtest 'CallToolResult', {
    my $result = CallToolResult.new(
        content => [TextContent.new(text => 'Result')],
        isError => False,
    );
    is $result.content.elems, 1, 'has one content item';
    is $result.isError, False, 'isError is false';
};

# Test Resource
subtest 'Resource', {
    my $res = Resource.new(
        uri => 'file:///test.txt',
        name => 'Test File',
        description => 'A test file',
        mimeType => 'text/plain',
    );
    is $res.uri, 'file:///test.txt', 'uri is correct';
    is $res.name, 'Test File', 'name is correct';
    is $res.mimeType, 'text/plain', 'mimeType is correct';
};

# Test ResourceContents
subtest 'ResourceContents', {
    my $contents = ResourceContents.new(
        uri => 'file:///test.txt',
        mimeType => 'text/plain',
        text => 'File contents',
    );
    is $contents.uri, 'file:///test.txt', 'uri is correct';
    is $contents.text, 'File contents', 'text is correct';
};

# Test PromptArgument
subtest 'PromptArgument', {
    my $arg = PromptArgument.new(
        name => 'topic',
        description => 'The topic to discuss',
        required => True,
    );
    is $arg.name, 'topic', 'name is correct';
    is $arg.required, True, 'required is correct';
};

# Test Prompt
subtest 'Prompt', {
    my $prompt = Prompt.new(
        name => 'explain',
        description => 'Explain a concept',
        arguments => [
            PromptArgument.new(name => 'topic', required => True),
        ],
    );
    is $prompt.name, 'explain', 'name is correct';
    is $prompt.arguments.elems, 1, 'has one argument';
};

# Test PromptMessage
subtest 'PromptMessage', {
    my $msg = PromptMessage.new(
        role => 'user',
        content => TextContent.new(text => 'Hello'),
    );
    is $msg.role, 'user', 'role is correct';
    isa-ok $msg.content, TextContent, 'content is TextContent';
};

# Test ServerCapabilities
subtest 'ServerCapabilities', {
    my $caps = ServerCapabilities.new(
        tools => ToolsCapability.new(listChanged => True),
        resources => ResourcesCapability.new(subscribe => True),
    );
    ok $caps.tools.defined, 'tools defined';
    ok $caps.resources.defined, 'resources defined';
    is $caps.tools.listChanged, True, 'tools.listChanged is true';
};

# Test ClientCapabilities
subtest 'ClientCapabilities', {
    my $caps = ClientCapabilities.new(
        roots => RootsCapability.new(listChanged => True),
        sampling => SamplingCapability.new,
    );
    ok $caps.roots.defined, 'roots defined';
    ok $caps.sampling.defined, 'sampling defined';
};

# Test Progress
subtest 'Progress', {
    my $progress = Progress.new(
        progressToken => 'task-1',
        progress => 50e0,
        total => 100e0,
        message => 'Processing...',
    );
    is $progress.progressToken, 'task-1', 'token is correct';
    is $progress.progress, 50e0, 'progress is correct';
    is $progress.total, 100e0, 'total is correct';
};

# Test LogLevel
subtest 'LogLevel', {
    is Debug.value, 'debug', 'Debug value';
    is Info.value, 'info', 'Info value';
    is Warning.value, 'warning', 'Warning value';
    is Error.value, 'error', 'Error value';

    # parse-log-level
    is parse-log-level('debug'), Debug, 'parse debug';
    is parse-log-level('warning'), Warning, 'parse warning';
    is parse-log-level('emergency'), Emergency, 'parse emergency';
    dies-ok { parse-log-level('nonexistent') }, 'parse invalid level dies';

    # log-level-at-or-above
    ok log-level-at-or-above(Warning, Debug), 'Warning >= Debug';
    ok log-level-at-or-above(Warning, Warning), 'Warning >= Warning';
    nok log-level-at-or-above(Debug, Warning), 'Debug < Warning';
    ok log-level-at-or-above(Emergency, Emergency), 'Emergency >= Emergency';
    nok log-level-at-or-above(Alert, Emergency), 'Alert < Emergency';
};

# Test LogEntry
subtest 'LogEntry', {
    my $entry = LogEntry.new(
        level => Info,
        logger => 'test',
        data => 'Test message',
    );
    is $entry.level, Info, 'level is correct';
    is $entry.logger, 'test', 'logger is correct';
    is $entry.data, 'Test message', 'data is correct';
};

# Test Protocol Version Constants
subtest 'Protocol Constants', {
    ok LATEST_PROTOCOL_VERSION.defined, 'LATEST_PROTOCOL_VERSION defined';
    ok SUPPORTED_PROTOCOL_VERSIONS.elems > 0, 'SUPPORTED_PROTOCOL_VERSIONS has items';
    ok LATEST_PROTOCOL_VERSION (elem) SUPPORTED_PROTOCOL_VERSIONS,
        'Latest version is in supported list';
};

# Test Annotations
subtest 'Annotations', {
    my $ann = Annotations.new(
        audience => ['user', 'assistant'],
        priority => 0.5e0,
    );
    is $ann.audience.elems, 2, 'has two audience items';
    is $ann.priority, 0.5e0, 'priority is correct';
};

# Test Tool with annotations
subtest 'Tool with Annotations', {
    my $ann = ToolAnnotations.new(
        title => 'Calculator',
        readOnlyHint => True,
        idempotentHint => True,
    );
    my $tool = Tool.new(
        name => 'add',
        description => 'Add numbers',
        annotations => $ann,
    );
    ok $tool.annotations.defined, 'has annotations';
    is $tool.annotations.title, 'Calculator', 'annotation title correct';
};

# Test serialization round-trip
subtest 'Hash serialization', {
    use JSON::Fast;

    my $tool = Tool.new(
        name => 'test',
        description => 'Test tool',
        inputSchema => { type => 'object', properties => { x => { type => 'number' } } },
    );

    my $json = to-json($tool.Hash);
    my %restored = from-json($json);

    is %restored<name>, 'test', 'name survives round-trip';
    is %restored<description>, 'Test tool', 'description survives round-trip';
    ok %restored<inputSchema>:exists, 'inputSchema survives round-trip';
};

# Test empty capabilities
subtest 'Empty capabilities', {
    my $caps = ServerCapabilities.new();
    my %h = $caps.Hash;
    is %h.keys.elems, 0, 'empty capabilities has no keys';
};

# Test Content role
subtest 'Content role', {
    my $text = TextContent.new(text => 'hello');
    my $image = ImageContent.new(data => 'abc', mimeType => 'image/png');

    ok $text ~~ Content, 'TextContent does Content role';
    ok $image ~~ Content, 'ImageContent does Content role';
};

# Test ResourceContents with blob
subtest 'ResourceContents with blob', {
    my $blob = Buf.new(0x48, 0x65, 0x6c, 0x6c, 0x6f);  # "Hello"
    my $contents = ResourceContents.new(
        uri => 'file:///binary.bin',
        mimeType => 'application/octet-stream',
        blob => $blob,
    );
    ok $contents.blob.defined, 'blob is defined';
    is $contents.blob.elems, 5, 'blob has correct size';
};

# Test Root type
subtest 'Root', {
    my $root = Root.new(
        uri => 'file:///home/user/project',
        name => 'Project Root',
    );
    is $root.uri, 'file:///home/user/project', 'uri is correct';
    is $root.name, 'Project Root', 'name is correct';

    my %h = $root.Hash;
    is %h<uri>, 'file:///home/user/project', 'Hash has uri';
    is %h<name>, 'Project Root', 'Hash has name';

    # Test without optional name
    my $root-no-name = Root.new(uri => 'file:///tmp');
    my %h2 = $root-no-name.Hash;
    is %h2<uri>, 'file:///tmp', 'Hash has uri without name';
    nok %h2<name>:exists, 'Hash has no name when not provided';

    # Test from-hash
    my $restored = Root.from-hash({ uri => 'file:///restored', name => 'Restored' });
    is $restored.uri, 'file:///restored', 'from-hash restores uri';
    is $restored.name, 'Restored', 'from-hash restores name';
};

# Test CompletionsCapability
subtest 'CompletionsCapability', {
    my $cap = CompletionsCapability.new;
    my %h = $cap.Hash;
    is %h.keys.elems, 0, 'empty hash';
};

# Test CompletionResult
subtest 'CompletionResult', {
    my $result = CompletionResult.new(
        values => <alpha beta gamma>,
        total => 10,
        hasMore => True,
    );
    is $result.values.elems, 3, 'has 3 values';
    is $result.total, 10, 'total is 10';
    ok $result.hasMore, 'hasMore is true';

    my %h = $result.Hash;
    is %h<values>.elems, 3, 'Hash has values';
    is %h<total>, 10, 'Hash has total';
    ok %h<hasMore>, 'Hash hasMore';

    # from-hash
    my $restored = CompletionResult.from-hash(%h);
    is $restored.values.elems, 3, 'from-hash restores values';
    is $restored.total, 10, 'from-hash restores total';

    # Without optional fields
    my $minimal = CompletionResult.new(values => ['x']);
    my %h2 = $minimal.Hash;
    nok %h2<total>:exists, 'no total when not set';
    nok %h2<hasMore>:exists, 'no hasMore when not set';
};

# Test ElicitationAction enum
subtest 'ElicitationAction', {
    is ElicitAccept.value, 'accept', 'accept value';
    is ElicitDecline.value, 'decline', 'decline value';
    is ElicitCancel.value, 'cancel', 'cancel value';
};

# Test ElicitationCapability
subtest 'ElicitationCapability', {
    # Default (form only)
    my $cap-default = ElicitationCapability.new;
    ok $cap-default.supports-form, 'default supports form';
    nok $cap-default.supports-url, 'default does not support url';
    my %h-default = $cap-default.Hash;
    ok %h-default<form>:exists, 'default Hash has form';
    nok %h-default<url>:exists, 'default Hash has no url';

    # Both modes
    my $cap-both = ElicitationCapability.new(:form, :url);
    ok $cap-both.supports-form, 'both supports form';
    ok $cap-both.supports-url, 'both supports url';
    my %h-both = $cap-both.Hash;
    ok %h-both<form>:exists, 'both Hash has form';
    ok %h-both<url>:exists, 'both Hash has url';

    # from-hash
    my $from-empty = ElicitationCapability.from-hash({});
    ok $from-empty.supports-form, 'empty hash defaults to form';
    nok $from-empty.supports-url, 'empty hash has no url';

    my $from-url = ElicitationCapability.from-hash({ url => {} });
    ok $from-url.supports-url, 'from-hash with url';
};

# Test ElicitationResponse
subtest 'ElicitationResponse', {
    # Accept with content
    my $accept = ElicitationResponse.new(
        action => ElicitAccept,
        content => { name => 'test', age => 25 }
    );
    is $accept.action, ElicitAccept, 'accept action';
    is $accept.content<name>, 'test', 'accept has content';
    my %h-accept = $accept.Hash;
    is %h-accept<action>, 'accept', 'Hash has action';
    is %h-accept<content><name>, 'test', 'Hash has content';

    # Decline
    my $decline = ElicitationResponse.new(action => ElicitDecline);
    is $decline.action, ElicitDecline, 'decline action';
    my %h-decline = $decline.Hash;
    is %h-decline<action>, 'decline', 'decline Hash';
    nok %h-decline<content>:exists, 'decline has no content';

    # Cancel
    my $cancel = ElicitationResponse.new(action => ElicitCancel);
    is $cancel.action, ElicitCancel, 'cancel action';

    # from-hash
    my $restored = ElicitationResponse.from-hash({
        action => 'accept',
        content => { email => 'test@example.com' }
    });
    is $restored.action, ElicitAccept, 'from-hash restores accept';
    is $restored.content<email>, 'test@example.com', 'from-hash restores content';
};

# Test ImageContent Hash serialization
subtest 'ImageContent Hash', {
    my $img = ImageContent.new(data => 'abc123', mimeType => 'image/png');
    my %h = $img.Hash;
    is %h<type>, 'image', 'type is image';
    is %h<data>, 'abc123', 'data preserved';
    is %h<mimeType>, 'image/png', 'mimeType preserved';
    nok %h<annotations>:exists, 'no annotations when not set';

    my $with-ann = ImageContent.new(
        data => 'x', mimeType => 'image/jpeg',
        annotations => Annotations.new(audience => ['user'], priority => 0.8e0),
    );
    my %h2 = $with-ann.Hash;
    ok %h2<annotations>:exists, 'annotations included';
    is %h2<annotations><priority>, 0.8e0, 'annotation priority';
};

# Test AudioContent Hash serialization
subtest 'AudioContent Hash', {
    my $audio = AudioContent.new(data => 'audiodata', mimeType => 'audio/wav');
    my %h = $audio.Hash;
    is %h<type>, 'audio', 'type is audio';
    is %h<data>, 'audiodata', 'data preserved';
    is %h<mimeType>, 'audio/wav', 'mimeType preserved';

    my $with-ann = AudioContent.new(
        data => 'x', mimeType => 'audio/mp3',
        annotations => Annotations.new(audience => ['assistant']),
    );
    ok $with-ann.Hash<annotations>:exists, 'annotations included';
};

# Test EmbeddedResource Hash serialization
subtest 'EmbeddedResource Hash', {
    my $rc = ResourceContents.new(uri => 'file:///test', mimeType => 'text/plain', text => 'hi');
    my $er = EmbeddedResource.new(resource => $rc);
    my %h = $er.Hash;
    is %h<type>, 'resource', 'type is resource';
    is %h<resource><uri>, 'file:///test', 'resource uri';
    nok %h<annotations>:exists, 'no annotations';

    my $with-ann = EmbeddedResource.new(
        resource => $rc,
        annotations => Annotations.new(priority => 0.3e0),
    );
    ok $with-ann.Hash<annotations>:exists, 'annotations included';
};

# Test ResourceLink Hash serialization
subtest 'ResourceLink Hash', {
    my $rl = ResourceLink.new(name => 'doc', uri => 'file:///doc.pdf',
        title => 'Doc', description => 'A doc', mimeType => 'application/pdf', size => 1024);
    my %h = $rl.Hash;
    is %h<type>, 'resource_link', 'type';
    is %h<name>, 'doc', 'name';
    is %h<uri>, 'file:///doc.pdf', 'uri';
    is %h<title>, 'Doc', 'title';
    is %h<description>, 'A doc', 'description';
    is %h<mimeType>, 'application/pdf', 'mimeType';
    is %h<size>, 1024, 'size';

    # Minimal
    my $min = ResourceLink.new(name => 'x', uri => 'y');
    my %h2 = $min.Hash;
    nok %h2<title>:exists, 'no title';
    nok %h2<size>:exists, 'no size';
};

# Test ToolUseContent Hash
subtest 'ToolUseContent Hash', {
    my $tu = ToolUseContent.new(id => 'call-1', name => 'calc', input => { expr => '1+1' });
    my %h = $tu.Hash;
    is %h<type>, 'tool_use', 'type';
    is %h<id>, 'call-1', 'id';
    is %h<name>, 'calc', 'name';
    is %h<input><expr>, '1+1', 'input';
};

# Test ToolResultContent Hash
subtest 'ToolResultContent Hash', {
    my $tr = ToolResultContent.new(
        toolUseId => 'call-1',
        content => [TextContent.new(text => 'result')],
        isError => True,
        structuredContent => { val => 42 },
        meta => { requestId => 'r1' },
    );
    my %h = $tr.Hash;
    is %h<type>, 'tool_result', 'type';
    is %h<toolUseId>, 'call-1', 'toolUseId';
    ok %h<isError>, 'isError';
    is %h<structuredContent><val>, 42, 'structuredContent';
    is %h<_meta><requestId>, 'r1', 'meta';
    is %h<content>[0]<type>, 'text', 'content serialized';
};

# Test ModelHint Hash
subtest 'ModelHint Hash', {
    my $hint = ModelHint.new(name => 'claude-3');
    my %h = $hint.Hash;
    is %h<name>, 'claude-3', 'name in Hash';
};

# Test ModelPreferences Hash
subtest 'ModelPreferences Hash', {
    my $prefs = ModelPreferences.new(
        hints => [ModelHint.new(name => 'fast')],
        costPriority => 0.5e0,
        speedPriority => 0.8e0,
        intelligencePriority => 0.3e0,
    );
    my %h = $prefs.Hash;
    is %h<hints>[0]<name>, 'fast', 'hint name';
    is %h<costPriority>, 0.5e0, 'costPriority';
    is %h<speedPriority>, 0.8e0, 'speedPriority';
    is %h<intelligencePriority>, 0.3e0, 'intelligencePriority';

    # Minimal
    my $min = ModelPreferences.new;
    my %h2 = $min.Hash;
    nok %h2<hints>:exists, 'no hints';
    nok %h2<costPriority>:exists, 'no costPriority';
};

# Test ToolChoice Hash
subtest 'ToolChoice Hash', {
    my $tc = ToolChoice.new(mode => 'tool', name => 'calc');
    my %h = $tc.Hash;
    is %h<mode>, 'tool', 'mode';
    is %h<name>, 'calc', 'name';

    my $auto = ToolChoice.new(mode => 'auto');
    my %h2 = $auto.Hash;
    is %h2<mode>, 'auto', 'auto mode';
    nok %h2<name>:exists, 'no name for auto';
};

# Test ServerCapabilities from-hash roundtrip
subtest 'ServerCapabilities from-hash', {
    my $caps = ServerCapabilities.new(
        experimental => { 'test/ext' => {} },
        logging => LoggingCapability.new,
        prompts => PromptsCapability.new(listChanged => True),
        resources => ResourcesCapability.new(subscribe => True, listChanged => True),
        tools => ToolsCapability.new(listChanged => True),
        completions => CompletionsCapability.new,
        tasks => { list => {} },
    );
    my %h = $caps.Hash;
    ok %h<experimental>:exists, 'experimental in Hash';
    ok %h<tasks>:exists, 'tasks in Hash';

    my $restored = ServerCapabilities.from-hash(%h);
    ok $restored.tools.defined, 'from-hash restores tools';
    ok $restored.tasks.defined, 'from-hash restores tasks';
};

# Test IconDefinition
subtest 'IconDefinition', {
    my $icon = IconDefinition.new(
        src => 'https://example.com/icon.png',
        mimeType => 'image/png',
        sizes => ['48x48', '96x96'],
    );
    is $icon.src, 'https://example.com/icon.png', 'src correct';
    is $icon.mimeType, 'image/png', 'mimeType correct';
    is $icon.sizes.elems, 2, 'sizes count';

    my %h = $icon.Hash;
    is %h<src>, 'https://example.com/icon.png', 'Hash src';
    is %h<mimeType>, 'image/png', 'Hash mimeType';
    is %h<sizes>.elems, 2, 'Hash sizes';

    # from-hash round-trip
    my $restored = IconDefinition.from-hash(%h);
    is $restored.src, $icon.src, 'from-hash src';
    is $restored.mimeType, $icon.mimeType, 'from-hash mimeType';
    is $restored.sizes.elems, 2, 'from-hash sizes';

    # Minimal (src only)
    my $min = IconDefinition.new(src => 'data:image/svg+xml,...');
    my %h2 = $min.Hash;
    is %h2<src>, 'data:image/svg+xml,...', 'minimal src';
    nok %h2<mimeType>:exists, 'no mimeType when not set';
    nok %h2<sizes>:exists, 'no sizes when empty';
};

# Test icons and title on Tool
subtest 'Tool with icons and title', {
    my $icon = IconDefinition.new(src => 'https://example.com/tool.png', mimeType => 'image/png');
    my $tool = Tool.new(
        name => 'icon_tool',
        title => 'Icon Tool',
        icons => [$icon],
    );
    is $tool.title, 'Icon Tool', 'title correct';
    is $tool.icons.elems, 1, 'icons count';

    my %h = $tool.Hash;
    is %h<title>, 'Icon Tool', 'Hash title';
    is %h<icons>[0]<src>, 'https://example.com/tool.png', 'Hash icon src';

    my $restored = Tool.from-hash(%h);
    is $restored.title, 'Icon Tool', 'from-hash title';
    is $restored.icons.elems, 1, 'from-hash icons';
    is $restored.icons[0].src, 'https://example.com/tool.png', 'from-hash icon src';

    # Without title/icons
    my $plain = Tool.new(name => 'plain');
    my %h2 = $plain.Hash;
    nok %h2<title>:exists, 'no title when not set';
    nok %h2<icons>:exists, 'no icons when empty';
};

# Test icons and title on Resource and Prompt
subtest 'Resource and Prompt with icons and title', {
    my $icon = IconDefinition.new(src => 'https://example.com/res.png');
    my $res = Resource.new(uri => 'file:///x', name => 'X', title => 'X Resource', icons => [$icon]);
    is $res.title, 'X Resource', 'resource title';
    my %rh = $res.Hash;
    is %rh<title>, 'X Resource', 'resource Hash title';
    is %rh<icons>[0]<src>, 'https://example.com/res.png', 'resource Hash icon';

    my $res2 = Resource.from-hash(%rh);
    is $res2.title, 'X Resource', 'resource from-hash title';
    is $res2.icons[0].src, 'https://example.com/res.png', 'resource from-hash icon';

    my $prompt = Prompt.new(name => 'p', title => 'Prompt Title', icons => [$icon]);
    is $prompt.title, 'Prompt Title', 'prompt title';
    my %ph = $prompt.Hash;
    is %ph<title>, 'Prompt Title', 'prompt Hash title';

    my $prompt2 = Prompt.from-hash(%ph);
    is $prompt2.title, 'Prompt Title', 'prompt from-hash title';
};

# Test icons and title on Implementation
subtest 'Implementation with icons and title', {
    my $icon = IconDefinition.new(src => 'https://example.com/server.png', mimeType => 'image/png');
    my $impl = Implementation.new(name => 'srv', version => '1.0', title => 'My Server', icons => [$icon]);
    is $impl.title, 'My Server', 'title correct';
    is $impl.icons[0].src, 'https://example.com/server.png', 'icon src';

    my %h = $impl.Hash;
    is %h<title>, 'My Server', 'Hash title';
    is %h<icons>[0]<src>, 'https://example.com/server.png', 'Hash icon';

    my $restored = Implementation.from-hash(%h);
    is $restored.title, 'My Server', 'from-hash title';
    is $restored.icons[0].src, 'https://example.com/server.png', 'from-hash icon';

    # Without title/icons
    my $plain = Implementation.new(name => 'x', version => '0.1');
    my %h2 = $plain.Hash;
    nok %h2<title>:exists, 'no title';
    nok %h2<icons>:exists, 'no icons';
};


subtest 'ResourceTemplate type round-trip', {
    my $rt = ResourceTemplate.new(
        uriTemplate => 'file:///{path}',
        name => 'Files',
        description => 'File access',
        mimeType => 'text/plain',
        title => 'File Browser',
    );
    my %h = $rt.Hash;
    is %h<uriTemplate>, 'file:///{path}', 'uriTemplate in Hash';
    is %h<title>, 'File Browser', 'title in Hash';

    my $restored = ResourceTemplate.from-hash(%h);
    is $restored.uriTemplate, 'file:///{path}', 'from-hash uriTemplate';
    is $restored.title, 'File Browser', 'from-hash title';
};

subtest 'SamplingMessage and CreateMessageResult round-trip', {
    my $msg = SamplingMessage.new(
        role => 'user',
        content => TextContent.new(text => 'hi'),
    );
    my %h = $msg.Hash;
    is %h<role>, 'user', 'role in Hash';
    is %h<content><text>, 'hi', 'content in Hash';

    my $result = CreateMessageResult.new(
        role => 'assistant',
        model => 'test',
        content => { type => 'text', text => 'reply' },
        stopReason => 'endTurn',
    );
    my %rh = $result.Hash;
    is %rh<role>, 'assistant', 'result role';
    is %rh<model>, 'test', 'result model';
    is %rh<stopReason>, 'endTurn', 'result stopReason';
};

subtest 'IconDefinition round-trip extended', {
    my $icon = IconDefinition.new(src => 'icon.png', mimeType => 'image/png', sizes => ['16x16', '32x32']);
    my %h = $icon.Hash;
    my $from = IconDefinition.from-hash(%h);
    is $from.src, 'icon.png', 'from-hash src';
};

subtest 'Implementation with title and icons extended', {
    my $impl = Implementation.new(
        name => 'srv', version => '1.0', title => 'My Server',
        icons => [IconDefinition.new(src => 'logo.svg')],
    );
    my %h = $impl.Hash;
    is %h<title>, 'My Server', 'title in Hash';
    ok %h<icons>.elems == 1, 'icons in Hash';

    my $from = Implementation.from-hash(%h);
    is $from.title, 'My Server', 'from-hash title';
};

subtest 'Content type Hash methods extended', {
    # EmbeddedResource Hash
    my $rc = ResourceContents.new(uri => 'file:///x', text => 'hello');
    my $er = EmbeddedResource.new(resource => $rc);
    my %eh = $er.Hash;
    is %eh<type>, 'resource', 'embedded resource type';
    is %eh<resource><text>, 'hello', 'embedded resource text';

    # ToolResultContent Hash with all fields
    my $tr = ToolResultContent.new(toolUseId => 'tu-1',
        content => [TextContent.new(text => 'result')],
        isError => True, structuredContent => { val => 42 }, meta => { id => 'x' });
    my %trh = $tr.Hash;
    is %trh<isError>, True, 'isError in Hash';
    ok %trh<structuredContent><val> == 42, 'structuredContent in Hash';
    ok %trh<_meta><id> eq 'x', 'meta in Hash';
};

subtest 'Prompt from-hash with arguments and icons', {
    my $p = Prompt.from-hash({
        name => 'test',
        description => 'Test prompt',
        title => 'Test',
        icons => [j(%( src => 'icon.png' ))],
        arguments => [j(%( name => 'text', description => 'The text', required => True ))],
    });
    is $p.name, 'test', 'name from-hash';
    is $p.title, 'Test', 'title from-hash';
    ok $p.icons.elems == 1, 'icons from-hash';
    ok $p.arguments.elems == 1, 'arguments from-hash';
    is $p.arguments[0].name, 'text', 'argument name';
};

subtest 'Resource from-hash with all fields', {
    my $r = Resource.from-hash({
        uri => 'file:///x', name => 'x', description => 'A file',
        title => 'File X', mimeType => 'text/plain',
        icons => [j(%( src => 'file.png' ))],
    });
    is $r.title, 'File X', 'title from-hash';
    is $r.mimeType, 'text/plain', 'mimeType from-hash';
    ok $r.icons.elems == 1, 'icons from-hash';
};

subtest 'Tool from-hash with all fields', {
    my $t = Tool.from-hash({
        name => 'calc', description => 'Calculate', title => 'Calculator',
        inputSchema => { type => 'object' },
        outputSchema => { type => 'object', properties => { result => { type => 'number' } } },
        annotations => { readOnlyHint => True },
        execution => { taskSupport => 'required' },
        icons => [j(%( src => 'calc.png' ))],
    });
    is $t.title, 'Calculator', 'title from-hash';
    ok $t.outputSchema.defined, 'outputSchema from-hash';
    ok $t.annotations.readOnlyHint, 'annotations from-hash';
    is $t.execution.taskSupport, TaskRequired, 'execution from-hash';
    ok $t.icons.elems == 1, 'icons from-hash';
};

subtest 'ServerCapabilities from-hash full', {
    my $caps = ServerCapabilities.from-hash(%(
        logging => %(),
        prompts => %( listChanged => True ),
        resources => %( subscribe => True, listChanged => True ),
        tools => %( listChanged => True ),
        completions => %(),
        experimental => %( 'custom/ext' => %( version => '1' ) ),
        tasks => %( supported => True ),
    ));
    ok $caps.prompts.listChanged, 'prompts listChanged';
    ok $caps.resources.subscribe, 'resources subscribe';
    ok $caps.tools.listChanged, 'tools listChanged';
    ok $caps.experimental<custom/ext>:exists, 'experimental';
    ok $caps.tasks.defined, 'tasks capability';

    my %h = $caps.Hash;
    ok %h<prompts><listChanged>, 'prompts in Hash';
    ok %h<tasks>:exists, 'tasks in Hash';
};

subtest 'Extension round-trip', {
    my $ext = Extension.new(name => 'test/ext', version => '1.0', settings => { foo => 'bar' });
    my %h = $ext.Hash;
    is %h<name>, 'test/ext', 'name in Hash';
    is %h<version>, '1.0', 'version in Hash';

    my $from = Extension.from-hash(%h);
    is $from.name, 'test/ext', 'from-hash name';
    is $from.settings<foo>, 'bar', 'from-hash settings';
};

subtest 'Root from-hash extended', {
    my $r = Root.from-hash({ uri => 'file:///home', name => 'home' });
    is $r.uri, 'file:///home', 'uri';
    is $r.name, 'home', 'name';
    my %h = $r.Hash;
    is %h<name>, 'home', 'name in Hash';
};

subtest 'Progress Hash extended', {
    my $p = Progress.new(progressToken => 'tok1', progress => 5e0, total => 10e0, message => 'halfway');
    my %h = $p.Hash;
    is %h<progressToken>, 'tok1', 'token in Hash';
    is %h<total>, 10, 'total in Hash';
    is %h<message>, 'halfway', 'message in Hash';
};

subtest 'LogEntry Hash extended', {
    my $le = LogEntry.new(level => Info, logger => 'main', data => 'hello');
    my %h = $le.Hash;
    is %h<level>, 'info', 'level in Hash';
    is %h<logger>, 'main', 'logger in Hash';
    is %h<data>, 'hello', 'data in Hash';
};

subtest 'log-level-at-or-above and parse-log-level extended', {
    ok log-level-at-or-above(Error, Warning), 'error >= warning';
    ok log-level-at-or-above(Warning, Warning), 'warning >= warning';
    nok log-level-at-or-above(Debug, Warning), 'debug < warning';

    is parse-log-level('info'), Info, 'parse info';
    is parse-log-level('emergency'), Emergency, 'parse emergency';
    dies-ok { parse-log-level('bogus') }, 'parse unknown level dies';
};

subtest 'CreateMessageResult Hash extended', {
    my $cmr = CreateMessageResult.new(
        content => TextContent.new(text => 'hi'),
        model => 'claude', role => 'assistant',
        stopReason => 'endTurn', meta => { id => 'x' },
    );
    my %h = $cmr.Hash;
    is %h<model>, 'claude', 'model in Hash';
    is %h<stopReason>, 'endTurn', 'stopReason in Hash';
    ok %h<_meta><id> eq 'x', 'meta in Hash';
};

subtest 'CreateTaskResult Hash extended', {
    my $task = Task.new(taskId => 't1', status => TaskWorking);
    my $ctr = CreateTaskResult.new(task => $task);
    my %h = $ctr.Hash;
    is %h<task><taskId>, 't1', 'task in Hash';
};

subtest 'Task with all optional fields', {
    my $t = Task.new(
        taskId => 't1', status => TaskWorking,
        statusMessage => 'processing', createdAt => '2025-01-01',
        lastUpdatedAt => '2025-01-02', ttl => 30000, pollInterval => 1000,
    );
    my %h = $t.Hash;
    is %h<statusMessage>, 'processing', 'statusMessage';
    is %h<createdAt>, '2025-01-01', 'createdAt';
    is %h<lastUpdatedAt>, '2025-01-02', 'lastUpdatedAt';
    is %h<pollInterval>, 1000, 'pollInterval';

    my $from = Task.from-hash(%h);
    is $from.statusMessage, 'processing', 'from-hash statusMessage';
    is $from.pollInterval, 1000, 'from-hash pollInterval';
};

subtest 'TextContent from-hash', {
    my $tc = TextContent.from-hash(%(text => 'hello'));
    is $tc.text, 'hello', 'text from plain hash';

    my $tc2 = TextContent.from-hash(%(
        text => 'annotated',
        annotations => %( priority => 0.5e0, audience => ['user'] ),
    ));
    is $tc2.text, 'annotated', 'text with annotations';
    ok $tc2.annotations.defined, 'annotations present';
};

subtest 'Content types with annotations', {
    my $ann = Annotations.new(audience => ['user', 'assistant'], priority => 0.7e0);

    my $img = ImageContent.new(data => 'x', mimeType => 'image/png', annotations => $ann);
    my %ih = $img.Hash;
    ok %ih<annotations><priority> == 0.7, 'image annotations in Hash';

    my $aud = AudioContent.new(data => 'y', mimeType => 'audio/wav', annotations => $ann);
    my %ah = $aud.Hash;
    ok %ah<annotations><audience>.elems == 2, 'audio annotations audience';

    my $rc = ResourceContents.new(uri => 'x://y', text => 'z');
    my $er = EmbeddedResource.new(resource => $rc, annotations => $ann);
    my %eh = $er.Hash;
    ok %eh<annotations>:exists, 'embedded resource annotations';

    my $rl = ResourceLink.new(name => 'n', uri => 'u://x', annotations => $ann);
    my %rh = $rl.Hash;
    ok %rh<annotations>:exists, 'resource link annotations';
};

subtest 'PromptMessage Hash with Positional content', {
    my @content = (TextContent.new(text => 'a'), TextContent.new(text => 'b'));
    my $pm = PromptMessage.new(role => 'user', content => @content);
    my %h = $pm.Hash;
    is %h<content>.elems, 2, 'positional content in Hash';
};

subtest 'SamplingMessage Hash with Positional content', {
    my @content = (TextContent.new(text => 'x'),);
    my $sm = SamplingMessage.new(role => 'user', content => @content);
    my %h = $sm.Hash;
    ok %h<content>.elems >= 1, 'sampling message content in Hash';
};

subtest 'CreateMessageResult Hash with Positional content', {
    my @content = (TextContent.new(text => 'x'),);
    my $cmr = CreateMessageResult.new(
        content => @content, model => 'm', role => 'assistant',
    );
    my %h = $cmr.Hash;
    ok %h<content>.elems >= 1, 'result positional content';
};

subtest 'LoggingCapability Hash', {
    my $lc = LoggingCapability.new;
    my %h = $lc.Hash;
    isa-ok %h, Hash, 'logging capability returns Hash';
};

subtest 'PromptsCapability Hash', {
    my $pc = PromptsCapability.new(listChanged => True);
    my %h = $pc.Hash;
    ok %h<listChanged>, 'prompts listChanged in Hash';
};

subtest 'ResourcesCapability Hash', {
    my $rc = ResourcesCapability.new(subscribe => True, listChanged => True);
    my %h = $rc.Hash;
    ok %h<subscribe>, 'subscribe in Hash';
    ok %h<listChanged>, 'listChanged in Hash';
};

subtest 'ToolsCapability Hash', {
    my $tc = ToolsCapability.new(listChanged => True);
    my %h = $tc.Hash;
    ok %h<listChanged>, 'tools listChanged in Hash';
};

subtest 'RootsCapability Hash', {
    my $rc = RootsCapability.new(listChanged => True);
    my %h = $rc.Hash;
    ok %h<listChanged>, 'roots listChanged in Hash';
};

subtest 'SamplingCapability Hash', {
    my $sc = SamplingCapability.new(tools => True, context => True);
    my %h = $sc.Hash;
    ok %h<tools>:exists, 'tools in Hash';
    ok %h<context>:exists, 'context in Hash';
};

subtest 'ServerCapabilities Hash with filled sub-capabilities', {
    my $caps = ServerCapabilities.new(
        logging => LoggingCapability.new,
        prompts => PromptsCapability.new(listChanged => True),
        resources => ResourcesCapability.new(subscribe => True),
        tools => ToolsCapability.new(listChanged => True),
        completions => CompletionsCapability.new,
        experimental => %( 'test/ext' => %( v => '1' ) ),
        tasks => %( supported => True ),
    );
    my %h = $caps.Hash;
    ok %h<logging>:exists, 'logging in Hash';
    ok %h<prompts>:exists, 'prompts in Hash';
    ok %h<resources>:exists, 'resources in Hash';
    ok %h<tools>:exists, 'tools in Hash';
    ok %h<completions>:exists, 'completions in Hash';
    ok %h<experimental>:exists, 'experimental in Hash';
    ok %h<tasks>:exists, 'tasks in Hash';
};

subtest 'ResourceTemplate Hash with all fields', {
    my $rt = ResourceTemplate.new(
        uriTemplate => 'file:///{path}',
        name => 'files',
        description => 'Access files',
        title => 'Files',
        mimeType => 'text/plain',
        annotations => Annotations.new(audience => ['user'], priority => 0.5e0),
        icons => [IconDefinition.new(src => 'file.png')],
    );
    my %h = $rt.Hash;
    ok %h<title> eq 'Files', 'title in Hash';
    ok %h<annotations><priority> == 0.5, 'annotations in Hash';
    ok %h<icons>.elems == 1, 'icons in Hash';
};

subtest 'Resource Hash with annotations extended', {
    my $r = Resource.new(
        uri => 'x://y', name => 'y',
        annotations => Annotations.new(audience => ['user']),
        icons => [IconDefinition.new(src => 'icon.png')],
    );
    my %h = $r.Hash;
    ok %h<annotations><audience>.elems == 1, 'annotations in Hash';
    ok %h<icons>.elems == 1, 'icons in Hash';
};

subtest 'CallToolResult Hash with structuredContent extended', {
    my $ctr = CallToolResult.new(
        content => [TextContent.new(text => 'x')],
        isError => False,
        structuredContent => %( value => 42 ),
    );
    my %h = $ctr.Hash;
    ok %h<structuredContent><value> == 42, 'structuredContent in Hash';
};


subtest 'Content type() methods', {
    is TextContent.new(text => 'a').type, 'text', 'TextContent.type';
    is ImageContent.new(data => 'x', mimeType => 'image/png').type, 'image', 'ImageContent.type';
    is AudioContent.new(data => 'y', mimeType => 'audio/wav').type, 'audio', 'AudioContent.type';
    is EmbeddedResource.new(resource => ResourceContents.new(uri => 'x')).type, 'resource', 'EmbeddedResource.type';
    is ResourceLink.new(name => 'a', uri => 'b').type, 'resource_link', 'ResourceLink.type';
    is ToolUseContent.new(id => '1', name => 't', input => %()).type, 'tool_use', 'ToolUseContent.type';
    is ToolResultContent.new(toolUseId => '1').type, 'tool_result', 'ToolResultContent.type';
};

subtest 'ToolAnnotations openWorldHint', {
    my $ta = ToolAnnotations.new(openWorldHint => True);
    ok $ta.Hash<openWorldHint>, 'openWorldHint';
};

subtest 'PromptArgument required', {
    my $pa = PromptArgument.new(name => 'topic', description => 'The topic', required => True);
    my %h = $pa.Hash;
    ok %h<required>, 'required field';
    is %h<description>, 'The topic', 'description';
};

subtest 'TaskExecution enum coverage', {
    for <forbidden optional required> -> $v {
        my $te = TaskExecution.from-hash(%( taskSupport => $v ));
        is $te.Hash<taskSupport>, $v, "TaskExecution $v";
    }
    my $te = TaskExecution.from-hash(%( taskSupport => 'unknown' ));
    is $te.Hash<taskSupport>, 'optional', 'TaskExecution default';
};

subtest 'Task from-hash all statuses', {
    for <working input_required completed failed cancelled> -> $s {
        my $t = Task.from-hash(%( taskId => 'tid', status => $s ));
        is $t.Hash<status>, $s, "Task status $s";
    }
    my $t = Task.from-hash(%( taskId => 'tid', status => 'bogus' ));
    is $t.Hash<status>, 'working', 'Task default status';
};

subtest 'Tool with execution and all fields', {
    my $te = TaskExecution.new(taskSupport => TaskOptional);
    my $ta = ToolAnnotations.new(title => 'T', readOnlyHint => True);
    my $icon = IconDefinition.new(src => 'https://x/icon.png');
    my $tool = Tool.new(
        name => 'calc', description => 'Calculate',
        title => 'Calculator', icons => [$icon],
        inputSchema => %( type => 'object' ),
        outputSchema => %( type => 'number' ),
        annotations => $ta, execution => $te,
    );
    my %h = $tool.Hash;
    ok %h<execution><taskSupport> eq 'optional', 'execution in Hash';
    ok %h<outputSchema><type> eq 'number', 'outputSchema in Hash';
    ok %h<icons>.elems == 1, 'icons in Hash';

    my $t2 = Tool.from-hash(%(
        name => 'calc',
        execution => j(%( taskSupport => 'required' )),
        outputSchema => j(%( type => 'number' )),
        icons => [j(%( src => 'https://x/icon.png' ))],
    ));
    is $t2.execution.Hash<taskSupport>, 'required', 'from-hash execution';
};

subtest 'ModelHint and ModelPreferences extended', {
    my $hint = ModelHint.new(name => 'claude-3');
    is $hint.Hash<name>, 'claude-3', 'ModelHint name';

    my $prefs = ModelPreferences.new(
        hints => [$hint],
        costPriority => 0.3e0,
        speedPriority => 0.5e0,
        intelligencePriority => 0.9e0,
    );
    my %h = $prefs.Hash;
    ok %h<intelligencePriority> == 0.9, 'intelligencePriority';
    ok %h<hints>.elems == 1, 'hints';
};

subtest 'CompletionResult with hasMore extended', {
    my $cr = CompletionResult.new(values => <a b>, total => 5, hasMore => True);
    my %h = $cr.Hash;
    ok %h<hasMore>, 'hasMore in Hash';
    is %h<total>, 5, 'total';

    my $cr2 = CompletionResult.from-hash(%( values => ['a'], total => 10, hasMore => True ));
    ok $cr2.hasMore, 'from-hash hasMore';
};

subtest 'ResourceLink with size', {
    my $rl = ResourceLink.new(name => 'doc', uri => 'file:///x', size => 42);
    my %h = $rl.Hash;
    is %h<size>, 42, 'size in Hash';
};

subtest 'ClientCapabilities Hash extended', {
    my $caps = ClientCapabilities.new(
        roots => RootsCapability.new(listChanged => True),
        sampling => SamplingCapability.new(tools => True, context => True),
        elicitation => ElicitationCapability.new(form => True, url => True),
        experimental => { 'test/ext' => {} },
        tasks => { supported => True },
    );
    my %h = $caps.Hash;
    ok %h<roots><listChanged>, 'roots in Hash';
    ok %h<sampling><tools>:exists, 'sampling tools in Hash';
    ok %h<elicitation><form>:exists, 'elicitation form in Hash';
    ok %h<experimental>:exists, 'experimental in Hash';
    ok %h<tasks>:exists, 'tasks in Hash';
};

subtest 'ElicitationResponse from-hash variants', {
    my $fr = ElicitationResponse.from-hash(%( action => 'decline' ));
    is $fr.action, ElicitDecline, 'from-hash decline';

    my $fr2 = ElicitationResponse.from-hash(%( action => 'bogus' ));
    is $fr2.action, ElicitCancel, 'from-hash default cancel';
};

subtest 'ElicitationCapability from-hash extended', {
    my $ec = ElicitationCapability.from-hash({ form => {}, url => {} });
    ok $ec.supports-form, 'supports-form';
    ok $ec.supports-url, 'supports-url';

    my $ec2 = ElicitationCapability.from-hash({});
    ok $ec2.supports-form, 'empty hash defaults to form';
    nok $ec2.supports-url, 'empty hash no url';
};

done-testing;
