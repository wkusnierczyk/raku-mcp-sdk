use v6.d;
use Test;
use lib 'lib';
use lib 't/lib';

use MCP::Client;
use MCP::Types;
need MCP::JSONRPC;
need TestTransport;

=begin pod
=head1 NAME

06-client.rakutest - Tests for client behavior

=head1 DESCRIPTION

Covers initialization, request/response handling, and content parsing.

=end pod

sub respond-to-last(TestTransport::TestTransport $transport, $payload) {
    my $req;
    for $transport.sent.reverse -> $msg {
        if $msg ~~ MCP::JSONRPC::Request {
            $req = $msg;
            last;
        }
    }
    die "No request to respond to" unless $req.defined;
    $transport.emit(MCP::JSONRPC::Response.success($req.id, $payload));
}

subtest 'Client connect and requests', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    # Wait for initialize request
    for ^10 {
        last if $transport.sent.elems > 0;
        sleep 0.1;
    }
    my $init-req = $transport.sent[0];
    isa-ok $init-req, MCP::JSONRPC::Request, 'initialize request sent';

    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'hello'
    }));
    await $connect;

    ok $client.server-capabilities.defined, 'server capabilities set';
    is $client.server-instructions, 'hello', 'server instructions set';
    ok $client.notifications.defined, 'notifications supply available';

    my $tools-p = $client.list-tools;
    my %tool = name => 't', description => 'd', inputSchema => { type => 'object' };
    respond-to-last($transport, {
        tools => [ %tool.item ]
    });
    my $tools-result = await $tools-p;
    is $tools-result<tools>[0].name, 't', 'list-tools returns Tool';
    nok $tools-result<nextCursor>.defined, 'list-tools has no nextCursor when not paginated';

    my $call-p = $client.call-tool('add', arguments => { a => 1, b => 2 });
    my %content = type => 'text', text => 'ok';
    respond-to-last($transport, {
        content => [ %content.item ],
        isError => False
    });
    my $call = await $call-p;
    is $call.content[0].text, 'ok', 'call-tool parses content';

    my $res-p = $client.list-resources;
    my %resource = uri => 'info://x', name => 'X', mimeType => 'text/plain';
    respond-to-last($transport, {
        resources => [ %resource.item ]
    });
    my $res-result = await $res-p;
    is $res-result<resources>[0].uri, 'info://x', 'list-resources returns Resource';
    nok $res-result<nextCursor>.defined, 'list-resources has no nextCursor when not paginated';

    my $read-p = $client.read-resource('info://x');
    my %contents = uri => 'info://x', mimeType => 'text/plain', text => 'hello';
    respond-to-last($transport, {
        contents => [ %contents.item ]
    });
    my @contents = await $read-p;
    is @contents[0].text, 'hello', 'read-resource returns contents';

    my $prompts-p = $client.list-prompts;
    my %prompt = name => 'p', description => 'desc', arguments => [];
    respond-to-last($transport, {
        prompts => [ %prompt.item ]
    });
    my $prompts-result = await $prompts-p;
    is $prompts-result<prompts>[0].name, 'p', 'list-prompts returns Prompt';
    nok $prompts-result<nextCursor>.defined, 'list-prompts has no nextCursor when not paginated';

    my $prompt-p = $client.get-prompt('p', arguments => { });
    my %msg = role => 'user', content => { type => 'text', text => 'hi' };
    respond-to-last($transport, {
        description => 'desc',
        messages => [ %msg.item ]
    });
    my $prompt = await $prompt-p;
    is $prompt<messages>[0].content.text, 'hi', 'get-prompt parses messages';

    my $ping-p = $client.ping;
    respond-to-last($transport, {});
    ok await($ping-p), 'ping resolves true';

    my $bad = $client.request('bad');
    my $bad-req = $transport.sent[*-1];
    $transport.emit(MCP::JSONRPC::Response.error(
        $bad-req.id,
        MCP::JSONRPC::Error.from-code(MCP::JSONRPC::InvalidRequest, 'bad')
    ));
    dies-ok { await $bad }, 'error response rejects promise';

    my $note = Promise.new;
    $client.notifications.tap(-> $n { $note.keep($n) });
    $transport.emit(MCP::JSONRPC::Notification.new(method => 'note', params => {}));
    isa-ok await($note), MCP::JSONRPC::Notification, 'notifications emit';

    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(id => 99, method => 'server/request'));
    ok $transport.sent.grep(MCP::JSONRPC::Response).elems == 1, 'client responds to server request';
};

subtest 'Client pagination support', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    for ^10 {
        last if $transport.sent.elems > 0;
        sleep 0.1;
    }
    my $init-req = $transport.sent[0];
    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'test'
    }));
    await $connect;

    # Test list-tools with nextCursor
    my $tools-p = $client.list-tools;
    my %tool = name => 't1', description => 'd', inputSchema => { type => 'object' };
    respond-to-last($transport, {
        tools => [ %tool.item ],
        nextCursor => 'cursor123'
    });
    my $tools-result = await $tools-p;
    is $tools-result<tools>[0].name, 't1', 'list-tools returns Tool';
    is $tools-result<nextCursor>, 'cursor123', 'list-tools includes nextCursor';

    # Test list-tools with cursor parameter
    my $tools-p2 = $client.list-tools(cursor => 'cursor123');
    my $req = $transport.sent[*-1];
    is $req.params<cursor>, 'cursor123', 'list-tools sends cursor parameter';
    my %tool2 = name => 't2', description => 'd2', inputSchema => { type => 'object' };
    respond-to-last($transport, {
        tools => [ %tool2.item ]
    });
    my $tools-result2 = await $tools-p2;
    is $tools-result2<tools>[0].name, 't2', 'list-tools with cursor returns next page';
    nok $tools-result2<nextCursor>.defined, 'last page has no nextCursor';

    # Test list-resources with cursor
    my $res-p = $client.list-resources(cursor => 'rescursor');
    my $res-req = $transport.sent[*-1];
    is $res-req.params<cursor>, 'rescursor', 'list-resources sends cursor parameter';
    my %res = uri => 'info://x', name => 'X', mimeType => 'text/plain';
    respond-to-last($transport, {
        resources => [ %res.item ],
        nextCursor => 'rescursor2'
    });
    my $res-result = await $res-p;
    is $res-result<nextCursor>, 'rescursor2', 'list-resources includes nextCursor';

    # Test list-prompts with cursor
    my $prompts-p = $client.list-prompts(cursor => 'promptcursor');
    my $prompts-req = $transport.sent[*-1];
    is $prompts-req.params<cursor>, 'promptcursor', 'list-prompts sends cursor parameter';
    my %pmt = name => 'p', description => 'desc', arguments => [];
    respond-to-last($transport, {
        prompts => [ %pmt.item ],
        nextCursor => 'promptcursor2'
    });
    my $prompts-result = await $prompts-p;
    is $prompts-result<nextCursor>, 'promptcursor2', 'list-prompts includes nextCursor';
};

subtest 'Client cancellation support', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    for ^10 {
        last if $transport.sent.elems > 0;
        sleep 0.1;
    }
    my $init-req = $transport.sent[0];
    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'test'
    }));
    await $connect;

    # Test cancel-request sends notification
    $transport.clear-sent;
    $client.cancel-request('req-789', reason => 'User cancelled');
    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'cancel-request sends notification';
    is @notifications[0].method, 'notifications/cancelled', 'notification method is correct';
    is @notifications[0].params<requestId>, 'req-789', 'notification has correct requestId';
    is @notifications[0].params<reason>, 'User cancelled', 'notification has correct reason';

    # Test cancel-request for pending request breaks the promise
    $transport.clear-sent;
    my $pending = $client.request('some/method');
    my $req = $transport.sent.grep(MCP::JSONRPC::Request)[*-1];
    $client.cancel-request($req.id, reason => 'Cancelled by test');

    # The promise should be broken
    dies-ok { await $pending }, 'cancelled request breaks promise';

    # And a notification should have been sent
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    ok @notifications.elems >= 1, 'cancellation notification was sent';
    my $cancel-notif = @notifications.first({ $_.method eq 'notifications/cancelled' });
    ok $cancel-notif.defined, 'notifications/cancelled was sent';
};

subtest 'Client resource subscription support', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    for ^10 {
        last if $transport.sent.elems > 0;
        sleep 0.1;
    }
    my $init-req = $transport.sent[0];
    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => { resources => { subscribe => True } },
        instructions => 'test'
    }));
    await $connect;

    # Test subscribe-resource sends request
    $transport.clear-sent;
    my $sub-p = $client.subscribe-resource('file://test.txt');
    my $sub-req = $transport.sent.grep(MCP::JSONRPC::Request)[*-1];
    is $sub-req.method, 'resources/subscribe', 'subscribe-resource sends correct method';
    is $sub-req.params<uri>, 'file://test.txt', 'subscribe-resource sends correct uri';
    respond-to-last($transport, {});
    await $sub-p;
    pass 'subscribe-resource completes successfully';

    # Test unsubscribe-resource sends request
    $transport.clear-sent;
    my $unsub-p = $client.unsubscribe-resource('file://test.txt');
    my $unsub-req = $transport.sent.grep(MCP::JSONRPC::Request)[*-1];
    is $unsub-req.method, 'resources/unsubscribe', 'unsubscribe-resource sends correct method';
    is $unsub-req.params<uri>, 'file://test.txt', 'unsubscribe-resource sends correct uri';
    respond-to-last($transport, {});
    await $unsub-p;
    pass 'unsubscribe-resource completes successfully';

    # Test receiving resource update notification
    my $update-received = Promise.new;
    $client.notifications.tap(-> $n {
        if $n.method eq 'notifications/resources/updated' {
            $update-received.keep($n);
        }
    });
    $transport.emit(MCP::JSONRPC::Notification.new(
        method => 'notifications/resources/updated',
        params => { uri => 'file://test.txt' }
    ));
    my $notif = await $update-received;
    is $notif.params<uri>, 'file://test.txt', 'resource update notification received';

    # Test receiving list changed notification
    my $list-changed = Promise.new;
    $client.notifications.tap(-> $n {
        if $n.method eq 'notifications/resources/list_changed' {
            $list-changed.keep($n);
        }
    });
    $transport.emit(MCP::JSONRPC::Notification.new(
        method => 'notifications/resources/list_changed'
    ));
    await $list-changed;
    pass 'resources list changed notification received';
};

subtest 'Client roots support', {
    my $transport = TestTransport::TestTransport.new;

    # Create client with roots configured
    my @roots = [
        { uri => 'file:///home/user/project', name => 'Project' },
        { uri => 'file:///tmp' },
    ];

    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport,
        roots => @roots
    );

    my $connect = $client.connect;
    for ^10 {
        last if $transport.sent.elems > 0;
        sleep 0.1;
    }
    my $init-req = $transport.sent[0];

    # Verify roots capability is advertised
    ok $init-req.params<capabilities><roots>:exists, 'roots capability advertised';
    ok $init-req.params<capabilities><roots><listChanged>, 'roots listChanged is true';

    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'test'
    }));
    await $connect;

    # Test get-roots returns configured roots
    my @client-roots = $client.get-roots;
    is @client-roots.elems, 2, 'get-roots returns 2 roots';
    is @client-roots[0].uri, 'file:///home/user/project', 'first root uri correct';
    is @client-roots[0].name, 'Project', 'first root name correct';
    is @client-roots[1].uri, 'file:///tmp', 'second root uri correct';

    # Test roots/list request from server
    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 'roots-req-1',
        method => 'roots/list'
    ));

    # Wait for response
    for ^10 {
        last if $transport.sent.grep(MCP::JSONRPC::Response).elems > 0;
        sleep 0.1;
    }

    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    is @responses.elems, 1, 'client responded to roots/list';
    my $response = @responses[0];
    is $response.id, 'roots-req-1', 'response has correct id';
    ok $response.result<roots>:exists, 'response has roots';
    is $response.result<roots>.elems, 2, 'response has 2 roots';
    is $response.result<roots>[0]<uri>, 'file:///home/user/project', 'first root in response';

    # Test set-roots updates roots and sends notification
    $transport.clear-sent;
    $client.set-roots([
        MCP::Types::Root.new(uri => 'file:///new/root', name => 'New Root')
    ]);

    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'set-roots sends notification';
    is @notifications[0].method, 'notifications/roots/list_changed', 'notification method correct';

    # Verify roots are updated
    @client-roots = $client.get-roots;
    is @client-roots.elems, 1, 'roots updated to 1';
    is @client-roots[0].uri, 'file:///new/root', 'new root uri correct';

    # Test client without roots doesn't advertise capability
    my $client2 = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli2', version => '0.1'),
        transport => TestTransport::TestTransport.new
    );
    my $connect2 = $client2.connect;
    for ^10 {
        last if $client2.transport.sent.elems > 0;
        sleep 0.1;
    }
    my $init-req2 = $client2.transport.sent[0];
    nok $init-req2.params<capabilities><roots>:exists, 'no roots capability without roots';
};

done-testing;
