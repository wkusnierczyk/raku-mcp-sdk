use v6.d;
use Test;
use lib 'lib';
use lib 't/lib';

use MCP::Client;
use MCP::Types;
need MCP::JSONRPC;
need TestTransport;
use JSON::Fast;

=begin pod
=head1 NAME

06-client.rakutest - Tests for client behavior

=head1 DESCRIPTION

Covers initialization, request/response handling, and content parsing.

=end pod

sub respond-to-last(TestTransport::TestTransport $transport, $payload --> Bool) {
    my $req;
    # Be resilient to scheduler timing: wait briefly for a request to appear.
    for ^1000 {
        for $transport.sent.reverse -> $msg {
            if $msg ~~ MCP::JSONRPC::Request {
                $req = $msg;
                last;
            }
        }
        last if $req.defined;
        sleep 0.01;
    }
    unless $req.defined {
        flunk 'request available to respond';
        diag 'No request to respond to';
        return False;
    }
    $transport.emit(MCP::JSONRPC::Response.success($req.id, $payload));
    True
}

# Helper: round-trip through JSON to ensure proper Hash structures
sub j(%h) { $(from-json(to-json(%h))) }

# Helper: create connected client
sub make-client(:$transport = TestTransport::TestTransport.new, :@roots, :&sampling-handler, :&elicitation-handler, :$capabilities) {
    my %opts = info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'), :$transport;
    %opts<roots> = @roots if @roots;
    %opts<sampling-handler> = &sampling-handler if &sampling-handler;
    %opts<elicitation-handler> = &elicitation-handler if &elicitation-handler;
    %opts<capabilities> = $capabilities if $capabilities;
    my $client = Client.new(|%opts);
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => %(),
        instructions => '',
    }));
    await $connect;
    $client
}

subtest 'Client connect and requests', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    # Wait for initialize request
    $transport.await-sent-and-settle;
    my $init-req = $transport.sent[0];
    isa-ok $init-req, MCP::JSONRPC::Request, 'initialize request sent';

    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'hello'
    }));
    await $connect;

    ok $client.server-capabilities.defined, 'server capabilities set';
    is $client.server-instructions, 'hello', 'server instructions set';
    ok $client.notifications.defined, 'notifications supply available';

    my $tools-p = $client.list-tools;
    my %tool = name => 't', description => 'd', inputSchema => { type => 'object' };
    respond-to-last($transport, {
        tools => [ %tool.item ]
    }) or return;
    my $tools-result = await $tools-p;
    is $tools-result<tools>[0].name, 't', 'list-tools returns Tool';
    nok $tools-result<nextCursor>.defined, 'list-tools has no nextCursor when not paginated';

    # list-tools with outputSchema
    my $tools-p2 = $client.list-tools;
    my %tool-with-schema = name => 'weather', description => 'Get weather',
        outputSchema => { type => 'object', properties => { temp => { type => 'number' } } };
    respond-to-last($transport, {
        tools => [ %tool-with-schema.item ]
    }) or return;
    my $tools-result2 = await $tools-p2;
    ok $tools-result2<tools>[0].outputSchema.defined, 'list-tools parses outputSchema';
    is $tools-result2<tools>[0].outputSchema<type>, 'object', 'outputSchema type preserved';

    my $call-p = $client.call-tool('add', arguments => { a => 1, b => 2 });
    my %content = type => 'text', text => 'ok';
    respond-to-last($transport, {
        content => [ %content.item ],
        isError => False
    }) or return;
    my $call = await $call-p;
    is $call.content[0].text, 'ok', 'call-tool parses content';

    # call-tool with structuredContent
    my $call-p2 = $client.call-tool('weather', arguments => { city => 'NYC' });
    my %sc-content = type => 'text', text => 'sunny 72F';
    respond-to-last($transport, {
        content => [ %sc-content.item ],
        isError => False,
        structuredContent => { temperature => 72, conditions => 'sunny' },
    }) or return;
    my $call2 = await $call-p2;
    ok $call2.structuredContent.defined, 'call-tool parses structuredContent';
    is $call2.structuredContent<temperature>, 72, 'structuredContent temperature';
    is $call2.content[0].text, 'sunny 72F', 'content fallback also present';

    # call-tool without structuredContent
    my $call-p3 = $client.call-tool('echo', arguments => { msg => 'hi' });
    respond-to-last($transport, {
        content => [ { type => 'text', text => 'hi' } ],
        isError => False,
    }) or return;
    my $call3 = await $call-p3;
    nok $call3.structuredContent.defined, 'no structuredContent when absent';

    my $res-p = $client.list-resources;
    my %resource = uri => 'info://x', name => 'X', mimeType => 'text/plain';
    respond-to-last($transport, {
        resources => [ %resource.item ]
    }) or return;
    my $res-result = await $res-p;
    is $res-result<resources>[0].uri, 'info://x', 'list-resources returns Resource';
    nok $res-result<nextCursor>.defined, 'list-resources has no nextCursor when not paginated';

    my $read-p = $client.read-resource('info://x');
    my %contents = uri => 'info://x', mimeType => 'text/plain', text => 'hello';
    respond-to-last($transport, {
        contents => [ %contents.item ]
    }) or return;
    my @contents = await $read-p;
    is @contents[0].text, 'hello', 'read-resource returns contents';

    my $prompts-p = $client.list-prompts;
    my %prompt = name => 'p', description => 'desc', arguments => [];
    respond-to-last($transport, {
        prompts => [ %prompt.item ]
    }) or return;
    my $prompts-result = await $prompts-p;
    is $prompts-result<prompts>[0].name, 'p', 'list-prompts returns Prompt';
    nok $prompts-result<nextCursor>.defined, 'list-prompts has no nextCursor when not paginated';

    my $prompt-p = $client.get-prompt('p', arguments => { });
    my %msg = role => 'user', content => { type => 'text', text => 'hi' };
    respond-to-last($transport, {
        description => 'desc',
        messages => [ %msg.item ]
    }) or return;
    my $prompt = await $prompt-p;
    is $prompt<messages>[0].content.text, 'hi', 'get-prompt parses messages';

    my $ping-p = $client.ping;
    respond-to-last($transport, {}) or return;
    ok await($ping-p), 'ping resolves true';

    my $bad = $client.request('bad');
    my $bad-req = $transport.sent[*-1];
    $transport.emit(MCP::JSONRPC::Response.error(
        $bad-req.id,
        MCP::JSONRPC::Error.from-code(MCP::JSONRPC::InvalidRequest, 'bad')
    ));
    dies-ok { await $bad }, 'error response rejects promise';

    my $note = Promise.new;
    $client.notifications.tap(-> $n { $note.keep($n) });
    $transport.emit(MCP::JSONRPC::Notification.new(method => 'note', params => {}));
    isa-ok await($note), MCP::JSONRPC::Notification, 'notifications emit';

    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(id => 99, method => 'server/request'));
    ok $transport.sent.grep(MCP::JSONRPC::Response).elems == 1, 'client responds to server request';
};

subtest 'Client pagination support', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    my $init-req = $transport.sent[0];
    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'test'
    }));
    await $connect;

    # Test list-tools with nextCursor
    my $tools-p = $client.list-tools;
    my %tool = name => 't1', description => 'd', inputSchema => { type => 'object' };
    respond-to-last($transport, {
        tools => [ %tool.item ],
        nextCursor => 'cursor123'
    }) or return;
    my $tools-result = await $tools-p;
    is $tools-result<tools>[0].name, 't1', 'list-tools returns Tool';
    is $tools-result<nextCursor>, 'cursor123', 'list-tools includes nextCursor';

    # Test list-tools with cursor parameter
    my $tools-p2 = $client.list-tools(cursor => 'cursor123');
    my $req = $transport.sent[*-1];
    is $req.params<cursor>, 'cursor123', 'list-tools sends cursor parameter';
    my %tool2 = name => 't2', description => 'd2', inputSchema => { type => 'object' };
    respond-to-last($transport, {
        tools => [ %tool2.item ]
    }) or return;
    my $tools-result2 = await $tools-p2;
    is $tools-result2<tools>[0].name, 't2', 'list-tools with cursor returns next page';
    nok $tools-result2<nextCursor>.defined, 'last page has no nextCursor';

    # Test list-resources with cursor
    my $res-p = $client.list-resources(cursor => 'rescursor');
    my $res-req = $transport.sent[*-1];
    is $res-req.params<cursor>, 'rescursor', 'list-resources sends cursor parameter';
    my %res = uri => 'info://x', name => 'X', mimeType => 'text/plain';
    respond-to-last($transport, {
        resources => [ %res.item ],
        nextCursor => 'rescursor2'
    }) or return;
    my $res-result = await $res-p;
    is $res-result<nextCursor>, 'rescursor2', 'list-resources includes nextCursor';

    # Test list-prompts with cursor
    my $prompts-p = $client.list-prompts(cursor => 'promptcursor');
    my $prompts-req = $transport.sent[*-1];
    is $prompts-req.params<cursor>, 'promptcursor', 'list-prompts sends cursor parameter';
    my %pmt = name => 'p', description => 'desc', arguments => [];
    respond-to-last($transport, {
        prompts => [ %pmt.item ],
        nextCursor => 'promptcursor2'
    }) or return;
    my $prompts-result = await $prompts-p;
    is $prompts-result<nextCursor>, 'promptcursor2', 'list-prompts includes nextCursor';
};

subtest 'Client cancellation support', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    my $init-req = $transport.sent[0];
    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'test'
    }));
    await $connect;

    # Test cancel-request sends notification
    $transport.clear-sent;
    $client.cancel-request('req-789', reason => 'User cancelled');
    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'cancel-request sends notification';
    is @notifications[0].method, 'notifications/cancelled', 'notification method is correct';
    is @notifications[0].params<requestId>, 'req-789', 'notification has correct requestId';
    is @notifications[0].params<reason>, 'User cancelled', 'notification has correct reason';

    # Test cancel-request for pending request breaks the promise
    $transport.clear-sent;
    my $pending = $client.request('some/method');
    my $req = $transport.sent.grep(MCP::JSONRPC::Request)[*-1];
    $client.cancel-request($req.id, reason => 'Cancelled by test');

    # The promise should be broken
    dies-ok { await $pending }, 'cancelled request breaks promise';

    # And a notification should have been sent
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    ok @notifications.elems >= 1, 'cancellation notification was sent';
    my $cancel-notif = @notifications.first({ $_.method eq 'notifications/cancelled' });
    ok $cancel-notif.defined, 'notifications/cancelled was sent';
};

subtest 'Client resource subscription support', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    my $init-req = $transport.sent[0];
    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => { resources => { subscribe => True } },
        instructions => 'test'
    }));
    await $connect;

    # Test subscribe-resource sends request
    $transport.clear-sent;
    my $sub-p = $client.subscribe-resource('file://test.txt');
    my $sub-req = $transport.sent.grep(MCP::JSONRPC::Request)[*-1];
    is $sub-req.method, 'resources/subscribe', 'subscribe-resource sends correct method';
    is $sub-req.params<uri>, 'file://test.txt', 'subscribe-resource sends correct uri';
    respond-to-last($transport, {}) or return;
    await $sub-p;
    pass 'subscribe-resource completes successfully';

    # Test unsubscribe-resource sends request
    $transport.clear-sent;
    my $unsub-p = $client.unsubscribe-resource('file://test.txt');
    my $unsub-req = $transport.sent.grep(MCP::JSONRPC::Request)[*-1];
    is $unsub-req.method, 'resources/unsubscribe', 'unsubscribe-resource sends correct method';
    is $unsub-req.params<uri>, 'file://test.txt', 'unsubscribe-resource sends correct uri';
    respond-to-last($transport, {}) or return;
    await $unsub-p;
    pass 'unsubscribe-resource completes successfully';

    # Test receiving resource update notification
    my $update-received = Promise.new;
    $client.notifications.tap(-> $n {
        if $n.method eq 'notifications/resources/updated' {
            $update-received.keep($n);
        }
    });
    $transport.emit(MCP::JSONRPC::Notification.new(
        method => 'notifications/resources/updated',
        params => { uri => 'file://test.txt' }
    ));
    my $notif = await $update-received;
    is $notif.params<uri>, 'file://test.txt', 'resource update notification received';

    # Test receiving list changed notification
    my $list-changed = Promise.new;
    $client.notifications.tap(-> $n {
        if $n.method eq 'notifications/resources/list_changed' {
            $list-changed.keep($n);
        }
    });
    $transport.emit(MCP::JSONRPC::Notification.new(
        method => 'notifications/resources/list_changed'
    ));
    await $list-changed;
    pass 'resources list changed notification received';
};

subtest 'Client roots support', {
    my $transport = TestTransport::TestTransport.new;

    # Create client with roots configured
    my @roots = [
        { uri => 'file:///home/user/project', name => 'Project' },
        { uri => 'file:///tmp' },
    ];

    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport,
        roots => @roots
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    my $init-req = $transport.sent[0];

    # Verify roots capability is advertised
    ok $init-req.params<capabilities><roots>:exists, 'roots capability advertised';
    ok $init-req.params<capabilities><roots><listChanged>, 'roots listChanged is true';

    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'test'
    }));
    await $connect;

    # Test get-roots returns configured roots
    my @client-roots = $client.get-roots;
    is @client-roots.elems, 2, 'get-roots returns 2 roots';
    is @client-roots[0].uri, 'file:///home/user/project', 'first root uri correct';
    is @client-roots[0].name, 'Project', 'first root name correct';
    is @client-roots[1].uri, 'file:///tmp', 'second root uri correct';

    # Test roots/list request from server
    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 'roots-req-1',
        method => 'roots/list'
    ));

    # Wait for response
    for ^100 {
        last if $transport.sent.grep(MCP::JSONRPC::Response).elems > 0;
        sleep 0.1;
    }

    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    is @responses.elems, 1, 'client responded to roots/list';
    my $response = @responses[0];
    is $response.id, 'roots-req-1', 'response has correct id';
    ok $response.result<roots>:exists, 'response has roots';
    is $response.result<roots>.elems, 2, 'response has 2 roots';
    is $response.result<roots>[0]<uri>, 'file:///home/user/project', 'first root in response';

    # Test set-roots updates roots and sends notification
    $transport.clear-sent;
    $client.set-roots([
        MCP::Types::Root.new(uri => 'file:///new/root', name => 'New Root')
    ]);

    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'set-roots sends notification';
    is @notifications[0].method, 'notifications/roots/list_changed', 'notification method correct';

    # Verify roots are updated
    @client-roots = $client.get-roots;
    is @client-roots.elems, 1, 'roots updated to 1';
    is @client-roots[0].uri, 'file:///new/root', 'new root uri correct';

    # Test client without roots doesn't advertise capability
    my $client2 = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli2', version => '0.1'),
        transport => TestTransport::TestTransport.new
    );
    my $connect2 = $client2.connect;
    $client2.transport.await-sent-and-settle;
    my $init-req2 = $client2.transport.sent[0];
    nok $init-req2.params<capabilities><roots>:exists, 'no roots capability without roots';
};

subtest 'Client elicitation support', {
    my $transport = TestTransport::TestTransport.new;
    my $elicit-received = False;
    my %elicit-params;

    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport,
        elicitation-handler => -> %params {
            $elicit-received = True;
            %elicit-params = %params;
            MCP::Types::ElicitationResponse.new(
                action => MCP::Types::ElicitAccept,
                content => { name => 'Test User' }
            )
        }
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    my $init-req = $transport.sent[0];

    # Verify elicitation capability is advertised
    ok $init-req.params<capabilities><elicitation>:exists, 'elicitation capability advertised';
    ok $init-req.params<capabilities><elicitation><form>:exists, 'form mode advertised';

    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'test'
    }));
    await $connect;

    # Send elicitation request from server
    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 100,
        method => 'elicitation/create',
        params => {
            mode => 'form',
            message => 'Enter your name',
            requestedSchema => {
                type => 'object',
                properties => { name => { type => 'string' } },
                required => ['name']
            }
        }
    ));

    # Wait for response
    $transport.await-sent-and-settle;

    ok $elicit-received, 'elicitation handler was called';
    is %elicit-params<message>, 'Enter your name', 'handler received message';
    is %elicit-params<mode>, 'form', 'handler received mode';

    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    is @responses.elems, 1, 'response sent';
    is @responses[0].id, 100, 'response has correct id';
    is @responses[0].result<action>, 'accept', 'response action is accept';
    is @responses[0].result<content><name>, 'Test User', 'response has content';

    # Test client without handler rejects elicitation
    my $client2 = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli2', version => '0.1'),
        transport => TestTransport::TestTransport.new
    );
    my $connect2 = $client2.connect;
    $client2.transport.await-sent-and-settle;
    my $init2 = $client2.transport.sent[0];
    nok $init2.params<capabilities><elicitation>:exists, 'no elicitation without handler';

    $client2.transport.emit(MCP::JSONRPC::Response.success($init2.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'test'
    }));
    await $connect2;

    $client2.transport.clear-sent;
    $client2.transport.emit(MCP::JSONRPC::Request.new(
        id => 200,
        method => 'elicitation/create',
        params => { mode => 'form', message => 'test' }
    ));

    $client2.transport.await-sent-and-settle;

    @responses = $client2.transport.sent.grep(MCP::JSONRPC::Response);
    is @responses.elems, 1, 'error response sent';
    ok @responses[0].error.defined, 'response has error';
    is @responses[0].error.code, MCP::JSONRPC::MethodNotFound.value, 'error is MethodNotFound';
};

# Test completion support
subtest 'Completion support', {
    my $transport = TestTransport::TestTransport.new;
    my $client = MCP::Client::Client.new(
        info => MCP::Types::Implementation.new(name => 'test-client', version => '0.1'),
        transport => $transport,
    );

    # Simulate init response in background
    start {
        sleep 0.1;
        respond-to-last($transport, {
            protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
            capabilities => { completions => {} },
            serverInfo => { name => 'test-server', version => '0.1' },
            instructions => 'test',
        }) or return;
    }
    await $client.connect;

    # Test complete-prompt
    start {
        sleep 0.1;
        respond-to-last($transport, {
            completion => { values => ['python', 'perl'], hasMore => False },
        }) or return;
    }
    my $result = await $client.complete-prompt('code-review',
        argument-name => 'language',
        value => 'p',
    );
    ok $result ~~ MCP::Types::CompletionResult, 'result is CompletionResult';
    is $result.values.elems, 2, 'has 2 values';
    is $result.values[0], 'python', 'first value correct';

    # Test complete-resource
    start {
        sleep 0.1;
        respond-to-last($transport, {
            completion => { values => ['file:///a'], total => 5, hasMore => True },
        }) or return;
    }
    my $result2 = await $client.complete-resource('file:///projects',
        argument-name => 'uri',
        value => 'file:',
    );
    is $result2.values.elems, 1, 'resource completion has values';
    is $result2.total, 5, 'has total';
    ok $result2.hasMore, 'hasMore is true';

    # Verify request was sent correctly
    my @requests = $transport.sent.grep(MCP::JSONRPC::Request).grep(*.method eq 'completion/complete');
    is @requests.elems, 2, 'sent 2 completion requests';
    is @requests[0].params<ref><type>, 'ref/prompt', 'first request is prompt ref';
    is @requests[1].params<ref><type>, 'ref/resource', 'second request is resource ref';
};

subtest 'Client set-log-level', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => { logging => {} },
        instructions => '',
    }));
    await $connect;

    # Send set-log-level request
    my $p = $client.set-log-level(MCP::Types::Warning);
    respond-to-last($transport, {}) or return;
    my $result = await $p;
    ok $result ~~ Hash, 'set-log-level returns result';

    # Verify the request sent by the client
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request).grep(*.method eq 'logging/setLevel');
    is @reqs.elems, 1, 'logging/setLevel request sent';
    is @reqs[0].params<level>, 'warning', 'level parameter is correct';
};

subtest 'Client progress supply', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => '',
    }));
    await $connect;

    # Tap the progress supply
    my @received;
    $client.progress.tap(-> $p { @received.push($p) });

    # Emit a progress notification from the server
    $transport.emit(MCP::JSONRPC::Notification.new(
        method => 'notifications/progress',
        params => {
            progressToken => 'tok-1',
            progress => 0.5e0,
            total => 1e0,
            message => 'halfway',
        }
    ));

    # Give the supply time to process
    sleep 0.1;

    is @received.elems, 1, 'received one progress notification';
    isa-ok @received[0], MCP::Types::Progress, 'is a Progress object';
    is @received[0].progressToken, 'tok-1', 'token correct';
    is @received[0].progress, 0.5e0, 'progress value correct';
    is @received[0].total, 1e0, 'total correct';
    is @received[0].message, 'halfway', 'message correct';

    # Non-progress notifications should not appear
    $transport.emit(MCP::JSONRPC::Notification.new(
        method => 'notifications/message',
        params => { level => 'info', data => 'test' }
    ));
    sleep 0.1;

    is @received.elems, 1, 'non-progress notification not in progress supply';
};

subtest 'Client parses all content types', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport);

    $transport.clear-sent;
    my $call-p = $client.call-tool('multi');
    $transport.await-sent;

    my @req = $transport.sent.grep(MCP::JSONRPC::Request);
    $transport.emit(MCP::JSONRPC::Response.success(@req[0].id, {
        content => [
            { type => 'text', text => 'hello' },
            { type => 'image', data => 'abc', mimeType => 'image/png' },
            { type => 'audio', data => 'wav', mimeType => 'audio/wav' },
            { type => 'resource', resource => { uri => 'file:///x', mimeType => 'text/plain', text => 'embedded' } },
            { type => 'resource_link', name => 'doc', uri => 'file:///doc', title => 'Doc', description => 'A doc', mimeType => 'application/pdf', size => 1024 },
            { type => 'tool_use', id => 'tu-1', name => 'calc', input => { x => 1 } },
            { type => 'tool_result', toolUseId => 'tu-1', content => [{ type => 'text', text => 'result' }], isError => False },
        ],
    }));

    my $result = await $call-p;
    is $result.content.elems, 7, '7 content items parsed';
    isa-ok $result.content[0], MCP::Types::TextContent, 'text parsed';
    isa-ok $result.content[1], MCP::Types::ImageContent, 'image parsed';
    isa-ok $result.content[2], MCP::Types::AudioContent, 'audio parsed';
    isa-ok $result.content[3], MCP::Types::EmbeddedResource, 'embedded resource parsed';
    isa-ok $result.content[4], MCP::Types::ResourceLink, 'resource link parsed';
    isa-ok $result.content[5], MCP::Types::ToolUseContent, 'tool_use parsed';
    isa-ok $result.content[6], MCP::Types::ToolResultContent, 'tool_result parsed';
};

subtest 'Client elicitation handler exception', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport,
        elicitation-handler => -> %params { die "Elicitation failed!" },
    );
    $transport.clear-sent;

    $transport.emit(MCP::JSONRPC::Request.new(
        id => 'e-1',
        method => 'elicitation/create',
        params => { mode => 'form', message => 'Enter name', requestedSchema => {} }
    ));

    sleep 0.3;
    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @responses.elems >= 1, 'response sent';
    ok @responses[0].error.defined, 'error response for failed handler';
    is @responses[0].error.code, MCP::JSONRPC::InternalError.value, 'InternalError code';
};

subtest 'Client rejects unknown server request', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport);
    $transport.clear-sent;

    $transport.emit(MCP::JSONRPC::Request.new(
        id => 'unk-1',
        method => 'unknown/serverMethod',
        params => {}
    ));

    sleep 0.3;
    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @responses.elems >= 1, 'response sent';
    ok @responses[0].error.defined, 'error for unknown method';
    is @responses[0].error.code, MCP::JSONRPC::MethodNotFound.value, 'MethodNotFound';
};

subtest 'Client sampling handler exception', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport,
        sampling-handler => -> %params { die "Handler crashed!" },
        capabilities => MCP::Types::ClientCapabilities.new(
            sampling => MCP::Types::SamplingCapability.new,
        ),
    );
    $transport.clear-sent;

    $transport.emit(MCP::JSONRPC::Request.new(
        id => 's-1',
        method => 'sampling/createMessage',
        params => {
            messages => [{ role => 'user', content => { type => 'text', text => 'hi' } }],
            maxTokens => 100,
        }
    ));

    sleep 0.3;
    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @responses.elems >= 1, 'response sent';
    ok @responses[0].error.defined, 'error response for crashed handler';
    is @responses[0].error.code, MCP::JSONRPC::InternalError.value, 'InternalError code';
};

subtest 'Client extensions in initialization', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport,
    );

    $client.register-extension(name => 'test/ext', version => '1.0', settings => { foo => 'bar' });
    dies-ok { $client.register-extension(name => 'bad-no-slash') }, 'extension without / dies';

    my $connect = $client.connect;
    $transport.await-sent-and-settle;

    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    my $init-params = @reqs[0].params;
    ok $init-params<capabilities><experimental><test/ext>:exists, 'extension in init capabilities';

    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => { experimental => { 'test/ext' => { version => '1.0' } } },
        instructions => 'hello',
    }));
    await $connect;

    is $client.server-instructions, 'hello', 'server-instructions accessor';
    ok $client.supports-extension('test/ext'), 'supports-extension';
    nok $client.supports-extension('other/ext'), 'does not support unknown extension';
};

subtest 'Client get-task-result', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport);

    $transport.clear-sent;
    my $p = $client.get-task-result('task-42');
    $transport.await-sent;
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    is @reqs[0].method, 'tasks/result', 'tasks/result method';
    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {
        content => [j(%( type => 'text', text => 'done' ))],
    }));
    my $result = await $p;
    ok $result<content>.elems >= 1, 'result has content';
};

subtest 'Client complete-resource', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport);

    $transport.clear-sent;
    my $p = $client.complete-resource('file:///x', argument-name => 'path', value => '/ho');
    $transport.await-sent;
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    is @reqs[0].method, 'completion/complete', 'completion/complete method';
    is @reqs[0].params<ref><type>, 'ref/resource', 'ref type is resource';
    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {
        completion => j(%( values => ['/home', '/host'] )),
    }));
    my $result = await $p;
    is $result.values.elems, 2, 'completion values';
};

subtest 'Client close', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport);
    await $client.close;
    pass 'client close completes';
};

subtest 'Client request error response via make-client', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport);

    $transport.clear-sent;
    my $p = $client.request('tools/list');
    $transport.await-sent;
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);

    $transport.emit(MCP::JSONRPC::Response.new(
        id => @reqs[0].id,
        error => MCP::JSONRPC::Error.new(code => -32601, message => 'not found'),
    ));
    dies-ok { await $p }, 'error response breaks promise';
};

subtest 'Client list-tools with cursor and nextCursor', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport);

    $transport.clear-sent;
    my $p = $client.list-tools(cursor => 'page2');
    $transport.await-sent;
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    is @reqs[0].params<cursor>, 'page2', 'cursor passed';

    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {
        tools => [j(%( name => 'x', inputSchema => %( type => 'object' ) ))],
        nextCursor => 'page3',
    }));
    my $result = await $p;
    is $result<nextCursor>, 'page3', 'nextCursor returned';
};

subtest 'Client list-tasks with nextCursor', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport);

    $transport.clear-sent;
    my $p = $client.list-tasks(cursor => 'tk1');
    $transport.await-sent;
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {
        tasks => [j(%( taskId => 't1', status => 'working' ))],
        nextCursor => 'tk2',
    }));
    my $result = await $p;
    is $result<nextCursor>, 'tk2', 'nextCursor returned';
};

subtest 'Client sampling handler success with result coercion', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        :$transport,
        sampling-handler => -> %params {
            %(
                role => 'assistant',
                model => 'test-model',
                content => %( type => 'text', text => 'response' ),
                stopReason => 'endTurn',
            )
        },
    );
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => %(),
        instructions => '',
    )));
    await $connect;

    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 100,
        method => 'sampling/createMessage',
        params => %(
            messages => [%( role => 'user', content => %( type => 'text', text => 'hi' ) )],
            maxTokens => 100,
        ),
    ));
    sleep 0.3;

    my @resps = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @resps.elems >= 1, 'sampling response sent';
    ok @resps[0].result.defined, 'result present (not error)';
};

subtest 'Client task methods', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport);

    # call-tool-as-task
    $transport.clear-sent;
    my $task-p = $client.call-tool-as-task('slow-calc', arguments => { x => 1 });
    $transport.await-sent;
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    ok @reqs[0].params<task><ttl> == 30000, 'default ttl';
    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {
        task => j(%( taskId => 'task-1', status => 'working' )),
    }));
    my $task = await $task-p;
    is $task.taskId, 'task-1', 'task created';

    # get-task
    $transport.clear-sent;
    my $get-p = $client.get-task('task-1');
    $transport.await-sent;
    @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {
        taskId => 'task-1', status => 'completed',
    }));
    my $got = await $get-p;
    is $got.status, MCP::Types::TaskCompleted, 'task completed';

    # cancel-task
    $transport.clear-sent;
    my $cancel-p = $client.cancel-task('task-1');
    $transport.await-sent;
    @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {
        taskId => 'task-1', status => 'cancelled',
    }));
    my $cancelled = await $cancel-p;
    is $cancelled.status, MCP::Types::TaskCancelled, 'task cancelled';

    # list-tasks
    $transport.clear-sent;
    my $list-p = $client.list-tasks;
    $transport.await-sent;
    @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {
        tasks => [j(%( taskId => 'task-1', status => 'cancelled' ))],
    }));
    my $list = await $list-p;
    is $list<tasks>.elems, 1, 'list-tasks returns tasks';
};

subtest 'X::MCP::Client error classes', {
    my $err = MCP::JSONRPC::Error.new(code => -32600, message => 'bad');
    my $client-err = X::MCP::Client::Error.new(error => $err);
    ok $client-err.message.contains('bad'), 'Client::Error message';

    my $timeout = X::MCP::Client::Timeout.new(method => 'tools/list');
    ok $timeout.message.contains('tools/list'), 'Timeout message contains method';
};

subtest 'Client get-prompt via make-client', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport);

    $transport.clear-sent;
    my $p = $client.get-prompt('summarize', arguments => { text => 'hello' });
    $transport.await-sent;
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {
        description => 'A summarizer',
        messages => [j(%( role => 'user', content => %( type => 'text', text => 'Summarize: hello' ) ))],
    }));
    my $result = await $p;
    is $result<description>, 'A summarizer', 'description';
    is $result<messages>[0].role, 'user', 'message role';
};

subtest 'Client complete-prompt via make-client', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport);

    $transport.clear-sent;
    my $p = $client.complete-prompt('summarize', argument-name => 'text', value => 'hel');
    $transport.await-sent;
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    is @reqs[0].method, 'completion/complete', 'correct method';
    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {
        completion => j(%( values => ['hello', 'help'], hasMore => False )),
    }));
    my $result = await $p;
    is $result.values.elems, 2, 'completion values';
};

subtest 'Client subscribe/unsubscribe resource via make-client', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport);

    # subscribe
    $transport.clear-sent;
    my $sub-p = $client.subscribe-resource('file:///x');
    $transport.await-sent;
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    is @reqs[0].method, 'resources/subscribe', 'subscribe method';
    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {}));
    await $sub-p;

    # unsubscribe
    $transport.clear-sent;
    my $unsub-p = $client.unsubscribe-resource('file:///x');
    $transport.await-sent;
    @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    is @reqs[0].method, 'resources/unsubscribe', 'unsubscribe method';
    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {}));
    await $unsub-p;
    pass 'subscribe/unsubscribe complete';
};

subtest 'Client notifications supply via make-client', {
    my $transport = TestTransport::TestTransport.new;
    my $client = make-client(:$transport);

    my @notifs;
    $client.notifications.tap(-> $n { @notifs.push($n) });

    $transport.emit(MCP::JSONRPC::Notification.new(
        method => 'notifications/tools/list_changed',
    ));
    sleep 0.1;
    ok @notifs.elems >= 1, 'notification forwarded to supply';
    is @notifs[0].method, 'notifications/tools/list_changed', 'correct notification method';
};

subtest 'Client elicitation with handler returning accept', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport,
        elicitation-handler => -> %params {
            MCP::Types::ElicitationResponse.new(action => MCP::Types::ElicitAccept, content => { name => 'test' })
        },
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    ok @reqs[0].params<capabilities><elicitation>:exists, 'elicitation in init capabilities';

    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => '',
    }));
    await $connect;

    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(id => 50, method => 'elicitation/create',
        params => { message => 'Enter name', requestedSchema => {} }));
    sleep 0.2;

    my @resps = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @resps.elems >= 1, 'elicitation response sent';
    is @resps[0].result<action>, 'accept', 'accept action in response';
};

subtest 'Client roots handling via make-client', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport,
        roots => [MCP::Types::Root.new(uri => 'file:///home', name => 'home')],
    );

    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    ok @reqs[0].params<capabilities><roots>:exists, 'roots in init capabilities';

    $transport.emit(MCP::JSONRPC::Response.success(@reqs[0].id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => '',
    }));
    await $connect;

    my @roots = $client.get-roots;
    is @roots[0].uri, 'file:///home', 'get-roots returns roots';

    $transport.clear-sent;
    $client.set-roots([MCP::Types::Root.new(uri => 'file:///new')]);
    sleep 0.1;
    my @notifs = $transport.sent.grep(MCP::JSONRPC::Notification);
    ok @notifs.grep({ .method eq 'notifications/roots/list_changed' }).elems >= 1,
        'roots list changed notification sent';
};

done-testing;
