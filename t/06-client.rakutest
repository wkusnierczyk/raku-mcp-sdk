use v6.d;
use Test;
use lib 'lib';
use lib 't/lib';

use MCP::Client;
use MCP::Types;
need MCP::JSONRPC;
need TestTransport;

=begin pod
=head1 NAME

06-client.rakutest - Tests for client behavior

=head1 DESCRIPTION

Covers initialization, request/response handling, and content parsing.

=end pod

sub respond-to-last(TestTransport::TestTransport $transport, $payload) {
    my $req;
    for $transport.sent.reverse -> $msg {
        if $msg ~~ MCP::JSONRPC::Request {
            $req = $msg;
            last;
        }
    }
    die "No request to respond to" unless $req.defined;
    $transport.emit(MCP::JSONRPC::Response.success($req.id, $payload));
}

subtest 'Client connect and requests', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    # Wait for initialize request
    for ^10 {
        last if $transport.sent.elems > 0;
        sleep 0.1;
    }
    my $init-req = $transport.sent[0];
    isa-ok $init-req, MCP::JSONRPC::Request, 'initialize request sent';

    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'hello'
    }));
    await $connect;

    ok $client.server-capabilities.defined, 'server capabilities set';
    is $client.server-instructions, 'hello', 'server instructions set';
    ok $client.notifications.defined, 'notifications supply available';

    my $tools-p = $client.list-tools;
    my %tool = name => 't', description => 'd', inputSchema => { type => 'object' };
    respond-to-last($transport, {
        tools => [ %tool.item ]
    });
    my $tools-result = await $tools-p;
    is $tools-result<tools>[0].name, 't', 'list-tools returns Tool';
    nok $tools-result<nextCursor>.defined, 'list-tools has no nextCursor when not paginated';

    my $call-p = $client.call-tool('add', arguments => { a => 1, b => 2 });
    my %content = type => 'text', text => 'ok';
    respond-to-last($transport, {
        content => [ %content.item ],
        isError => False
    });
    my $call = await $call-p;
    is $call.content[0].text, 'ok', 'call-tool parses content';

    my $res-p = $client.list-resources;
    my %resource = uri => 'info://x', name => 'X', mimeType => 'text/plain';
    respond-to-last($transport, {
        resources => [ %resource.item ]
    });
    my $res-result = await $res-p;
    is $res-result<resources>[0].uri, 'info://x', 'list-resources returns Resource';
    nok $res-result<nextCursor>.defined, 'list-resources has no nextCursor when not paginated';

    my $read-p = $client.read-resource('info://x');
    my %contents = uri => 'info://x', mimeType => 'text/plain', text => 'hello';
    respond-to-last($transport, {
        contents => [ %contents.item ]
    });
    my @contents = await $read-p;
    is @contents[0].text, 'hello', 'read-resource returns contents';

    my $prompts-p = $client.list-prompts;
    my %prompt = name => 'p', description => 'desc', arguments => [];
    respond-to-last($transport, {
        prompts => [ %prompt.item ]
    });
    my $prompts-result = await $prompts-p;
    is $prompts-result<prompts>[0].name, 'p', 'list-prompts returns Prompt';
    nok $prompts-result<nextCursor>.defined, 'list-prompts has no nextCursor when not paginated';

    my $prompt-p = $client.get-prompt('p', arguments => { });
    my %msg = role => 'user', content => { type => 'text', text => 'hi' };
    respond-to-last($transport, {
        description => 'desc',
        messages => [ %msg.item ]
    });
    my $prompt = await $prompt-p;
    is $prompt<messages>[0].content.text, 'hi', 'get-prompt parses messages';

    my $ping-p = $client.ping;
    respond-to-last($transport, {});
    ok await($ping-p), 'ping resolves true';

    my $bad = $client.request('bad');
    my $bad-req = $transport.sent[*-1];
    $transport.emit(MCP::JSONRPC::Response.error(
        $bad-req.id,
        MCP::JSONRPC::Error.from-code(MCP::JSONRPC::InvalidRequest, 'bad')
    ));
    dies-ok { await $bad }, 'error response rejects promise';

    my $note = Promise.new;
    $client.notifications.tap(-> $n { $note.keep($n) });
    $transport.emit(MCP::JSONRPC::Notification.new(method => 'note', params => {}));
    isa-ok await($note), MCP::JSONRPC::Notification, 'notifications emit';

    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(id => 99, method => 'server/request'));
    ok $transport.sent.grep(MCP::JSONRPC::Response).elems == 1, 'client responds to server request';
};

subtest 'Client pagination support', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    for ^10 {
        last if $transport.sent.elems > 0;
        sleep 0.1;
    }
    my $init-req = $transport.sent[0];
    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'test'
    }));
    await $connect;

    # Test list-tools with nextCursor
    my $tools-p = $client.list-tools;
    my %tool = name => 't1', description => 'd', inputSchema => { type => 'object' };
    respond-to-last($transport, {
        tools => [ %tool.item ],
        nextCursor => 'cursor123'
    });
    my $tools-result = await $tools-p;
    is $tools-result<tools>[0].name, 't1', 'list-tools returns Tool';
    is $tools-result<nextCursor>, 'cursor123', 'list-tools includes nextCursor';

    # Test list-tools with cursor parameter
    my $tools-p2 = $client.list-tools(cursor => 'cursor123');
    my $req = $transport.sent[*-1];
    is $req.params<cursor>, 'cursor123', 'list-tools sends cursor parameter';
    my %tool2 = name => 't2', description => 'd2', inputSchema => { type => 'object' };
    respond-to-last($transport, {
        tools => [ %tool2.item ]
    });
    my $tools-result2 = await $tools-p2;
    is $tools-result2<tools>[0].name, 't2', 'list-tools with cursor returns next page';
    nok $tools-result2<nextCursor>.defined, 'last page has no nextCursor';

    # Test list-resources with cursor
    my $res-p = $client.list-resources(cursor => 'rescursor');
    my $res-req = $transport.sent[*-1];
    is $res-req.params<cursor>, 'rescursor', 'list-resources sends cursor parameter';
    my %res = uri => 'info://x', name => 'X', mimeType => 'text/plain';
    respond-to-last($transport, {
        resources => [ %res.item ],
        nextCursor => 'rescursor2'
    });
    my $res-result = await $res-p;
    is $res-result<nextCursor>, 'rescursor2', 'list-resources includes nextCursor';

    # Test list-prompts with cursor
    my $prompts-p = $client.list-prompts(cursor => 'promptcursor');
    my $prompts-req = $transport.sent[*-1];
    is $prompts-req.params<cursor>, 'promptcursor', 'list-prompts sends cursor parameter';
    my %pmt = name => 'p', description => 'desc', arguments => [];
    respond-to-last($transport, {
        prompts => [ %pmt.item ],
        nextCursor => 'promptcursor2'
    });
    my $prompts-result = await $prompts-p;
    is $prompts-result<nextCursor>, 'promptcursor2', 'list-prompts includes nextCursor';
};

subtest 'Client cancellation support', {
    my $transport = TestTransport::TestTransport.new;
    my $client = Client.new(
        info => MCP::Types::Implementation.new(name => 'cli', version => '0.1'),
        transport => $transport
    );

    my $connect = $client.connect;
    for ^10 {
        last if $transport.sent.elems > 0;
        sleep 0.1;
    }
    my $init-req = $transport.sent[0];
    $transport.emit(MCP::JSONRPC::Response.success($init-req.id, {
        protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION,
        capabilities => {},
        instructions => 'test'
    }));
    await $connect;

    # Test cancel-request sends notification
    $transport.clear-sent;
    $client.cancel-request('req-789', reason => 'User cancelled');
    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'cancel-request sends notification';
    is @notifications[0].method, 'notifications/cancelled', 'notification method is correct';
    is @notifications[0].params<requestId>, 'req-789', 'notification has correct requestId';
    is @notifications[0].params<reason>, 'User cancelled', 'notification has correct reason';

    # Test cancel-request for pending request breaks the promise
    $transport.clear-sent;
    my $pending = $client.request('some/method');
    my $req = $transport.sent.grep(MCP::JSONRPC::Request)[*-1];
    $client.cancel-request($req.id, reason => 'Cancelled by test');

    # The promise should be broken
    dies-ok { await $pending }, 'cancelled request breaks promise';

    # And a notification should have been sent
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    ok @notifications.elems >= 1, 'cancellation notification was sent';
    my $cancel-notif = @notifications.first({ $_.method eq 'notifications/cancelled' });
    ok $cancel-notif.defined, 'notifications/cancelled was sent';
};

done-testing;
