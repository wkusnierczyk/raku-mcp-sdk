use v6.d;
use Test;
use lib 'lib';
use lib 't/lib';

use MCP::Types;
use MCP::Server::Tool;
use MCP::Server::Resource;
use MCP::Server::Prompt;

=begin pod
=head1 NAME

03-builders.rakutest - Tests for builder DSLs and registered wrappers

=head1 DESCRIPTION

Covers tool/resource/prompt builders and normalization logic.

=end pod

subtest 'Tool builder and normalization', {
    my $built = tool()
        .name('calc')
        .description('calculator')
        .string-param('a', description => 'first', :required)
        .number-param('b', description => 'second')
        .integer-param('c')
        .boolean-param('d')
        .array-param('e', items => { type => 'string' }, :required)
        .annotations(title => 'Calc', :readOnly, :idempotent)
        .handler(-> :%params { "ok: %params<a>" })
        .build;

    is $built.name, 'calc', 'tool name set';
    is $built.description, 'calculator', 'tool description set';
    ok $built.inputSchema<properties><a>:exists, 'string param schema';
    ok $built.inputSchema<properties><e>:exists, 'array param schema';
    ok $built.inputSchema<required>.grep('a'), 'required includes a';
    ok $built.inputSchema<required>.grep('e'), 'required includes e';

    my $tool = $built.to-tool;
    is $tool.name, 'calc', 'to-tool preserves name';
    is $tool.annotations.title, 'Calc', 'annotations set';
    ok $tool.annotations.readOnlyHint, 'readOnly annotation set';
    ok $tool.annotations.idempotentHint, 'idempotent annotation set';

    # Test spec-style naming with *Hint suffixes
    my $spec-style = tool()
        .name('delete')
        .annotations(destructiveHint => True, readOnlyHint => False)
        .handler(-> { 'ok' })
        .build;
    ok $spec-style.to-tool.annotations.destructiveHint, 'destructiveHint naming works';
    nok $spec-style.to-tool.annotations.readOnlyHint, 'readOnlyHint naming works';

    my $result = $built.call({ a => 'x' });
    isa-ok $result, MCP::Types::CallToolResult, 'call returns CallToolResult';
    is $result.content[0].text, 'ok: x', 'string normalized to TextContent';

    my $direct = RegisteredTool.new(
        name => 'direct',
        handler => -> :%params { MCP::Types::CallToolResult.new(content => [MCP::Types::TextContent.new(text => 'hi')]) }
    );
    ok $direct.call({}).isError ~~ Bool, 'accepts CallToolResult directly';

    my $text-tool = RegisteredTool.new(
        name => 'text',
        handler => -> :%params { MCP::Types::TextContent.new(text => 'hey') }
    );
    is $text-tool.call({}).content[0].text, 'hey', 'TextContent normalized';

    my $array-tool = RegisteredTool.new(
        name => 'array',
        handler => -> :%params { [MCP::Types::TextContent.new(text => 'a'), MCP::Types::TextContent.new(text => 'b')] }
    );
    is $array-tool.call({}).content.elems, 2, 'positional normalized to array';

    my $fallback-tool = RegisteredTool.new(
        name => 'fallback',
        handler => -> :%params { 123 }
    );
    is $fallback-tool.call({}).content[0].text, '123', 'fallback uses Str';

    dies-ok { tool().build }, 'tool requires name';
    dies-ok { tool().name('x').build }, 'tool requires handler';

    # Test output schema support
    my $weather = tool()
        .name('get-weather')
        .description('Get weather')
        .output-schema({
            type => 'object',
            properties => {
                temperature => { type => 'number' },
                conditions => { type => 'string' },
            }
        })
        .handler(-> :%params { { temperature => 72, conditions => 'sunny' } })
        .build;

    ok $weather.outputSchema.defined, 'outputSchema set on RegisteredTool';
    is $weather.outputSchema<type>, 'object', 'outputSchema has type';
    my $weather-tool = $weather.to-tool;
    ok $weather-tool.outputSchema.defined, 'outputSchema on Tool definition';
    is $weather-tool.outputSchema<properties><temperature><type>, 'number', 'outputSchema property type';

    # Hash in tool listing
    my %tool-hash = $weather-tool.Hash;
    ok %tool-hash<outputSchema>:exists, 'outputSchema in Hash';

    # Tool with outputSchema returns structuredContent for Hash results
    my $weather-result = $weather.call({});
    ok $weather-result.structuredContent.defined, 'structuredContent set';
    is $weather-result.structuredContent<temperature>, 72, 'structuredContent has temperature';
    is $weather-result.structuredContent<conditions>, 'sunny', 'structuredContent has conditions';
    ok $weather-result.content.elems >= 1, 'content fallback also present';

    # Tool without outputSchema does not set structuredContent for Hash
    my $no-schema = RegisteredTool.new(
        name => 'plain',
        handler => -> :%params { { x => 1 } }
    );
    my $plain-result = $no-schema.call({});
    nok $plain-result.structuredContent.defined, 'no structuredContent without outputSchema';
};

subtest 'Resource builder and normalization', {
    $*TMPDIR.mkdir unless $*TMPDIR.e;
    my $resource = resource()
        .uri('info://test')
        .name('Test')
        .description('desc')
        .mimeType('text/plain')
        .annotations(['user'], priority => 0.5)
        .reader({ 'hello' })
        .build;

    is $resource.to-resource.uri, 'info://test', 'resource uri';
    is $resource.to-resource.name, 'Test', 'resource name';

    # Test resource annotations
    my $res-obj = $resource.to-resource;
    ok $res-obj.annotations.defined, 'resource annotations set';
    is $res-obj.annotations.audience[0], 'user', 'resource audience set';
    is $res-obj.annotations.priority, 0.5, 'resource priority set';

    # Test annotations in Hash serialization
    my %res-hash = $res-obj.Hash;
    ok %res-hash<annotations>:exists, 'annotations in resource Hash';
    is %res-hash<annotations><priority>, 0.5, 'priority in serialized Hash';

    my $contents = $resource.read;
    is $contents[0].text, 'hello', 'string normalized to ResourceContents';

    my $blob-resource = RegisteredResource.new(
        uri => 'blob://bin',
        name => 'Blob',
        reader => { Buf.new(0x41, 0x42) }
    );
    ok $blob-resource.read[0].blob.defined, 'blob normalized';

    my $rc = MCP::Types::ResourceContents.new(
        uri => 'one://',
        mimeType => 'text/plain',
        text => 'one'
    );
    my $pos = RegisteredResource.new(
        uri => 'pos://',
        name => 'Pos',
        reader => { [$rc] }
    );
    is $pos.read[0].text, 'one', 'positional preserved';

    my $tmp = $*TMPDIR.add("mcp-resource-$*PID.txt");
    $tmp.spurt("file");
    my $file = file-resource($tmp);
    is $file.mimeType, 'text/plain', 'file-resource guesses mime type';
    ok $file.uri.starts-with('file://'), 'file-resource sets uri';

    # Test from-file MIME type guessing for various extensions
    my $tmp-dir = $*TMPDIR;
    for <html css js json xml png jpg jpeg gif svg pdf md> -> $ext {
        my $f = $tmp-dir.add("mcp-test-$*PID.$ext");
        $f.spurt("test");
        my $fr = file-resource($f);
        ok $fr.mimeType.defined, "from-file guesses mime for .$ext";
        $f.unlink;
    }

    # Unknown extension falls back to octet-stream
    my $unk = $tmp-dir.add("mcp-test-$*PID.xyz");
    $unk.spurt("test");
    my $fr-unk = file-resource($unk);
    is $fr-unk.mimeType, 'application/octet-stream', 'unknown ext -> octet-stream';
    $unk.unlink;

    # from-file with custom uri/name overrides
    my $f2 = $tmp-dir.add("mcp-test-$*PID.json");
    $f2.spurt('{}');
    my $custom = resource().from-file($f2.IO).uri('custom://x').name('Custom').build;
    is $custom.uri, 'custom://x', 'from-file uri override';
    is $custom.name, 'Custom', 'from-file name override';
    is $custom.mimeType, 'application/json', 'from-file mime still guessed';
    $f2.unlink;

    # Resource reader returning arbitrary object (default fallback)
    my $fallback-res = RegisteredResource.new(
        uri => 'fb://', name => 'Fallback',
        reader => { 42 }
    );
    is $fallback-res.read[0].text, '42', 'fallback normalizes to Str';

    # ResourceContents reader
    my $rc-res = RegisteredResource.new(
        uri => 'rc://', name => 'RC',
        reader => { MCP::Types::ResourceContents.new(uri => 'rc://', text => 'direct') }
    );
    is $rc-res.read[0].text, 'direct', 'ResourceContents preserved';

    dies-ok { resource().build }, 'resource requires uri';
    dies-ok { resource().uri('x').build }, 'resource requires name';
    dies-ok { resource().uri('x').name('y').build }, 'resource requires reader';
};

subtest 'Prompt builder and normalization', {
    my $prompt = prompt()
        .name('p')
        .description('desc')
        .argument('topic', description => 't', required => True)
        .optional-argument('level', description => 'lvl')
        .generator(-> :%params { "hello %params<topic>" })
        .build;

    is $prompt.to-prompt.name, 'p', 'prompt name';
    is $prompt.to-prompt.arguments.elems, 2, 'prompt arguments';
    is $prompt.get({ topic => 'x' })[0].content.text, 'hello x', 'string normalized to PromptMessage';

    my $pm = MCP::Types::PromptMessage.new(
        role => 'user',
        content => MCP::Types::TextContent.new(text => 'hi')
    );
    my $p2 = RegisteredPrompt.new(
        name => 'p2',
        generator => { $pm }
    );
    is $p2.get({})[0].content.text, 'hi', 'PromptMessage preserved';

    my $user = user-message('u');
    my $assistant = assistant-message('a');
    is $user.role, 'user', 'user-message role';
    is $assistant.role, 'assistant', 'assistant-message role';

    # required-argument with description
    my $p3 = prompt()
        .name('q')
        .required-argument('name', description => 'Your name')
        .generator(-> :%params { "Hi %params<name>" })
        .build;
    my $args = $p3.to-prompt.arguments;
    is $args[0].name, 'name', 'required-argument name';
    ok $args[0].required, 'required-argument is required';
    is $args[0].description, 'Your name', 'required-argument description';

    # Generator returning array of PromptMessage
    my $p4 = RegisteredPrompt.new(
        name => 'multi',
        generator => {
            [
                MCP::Types::PromptMessage.new(role => 'user', content => MCP::Types::TextContent.new(text => 'a')),
                MCP::Types::PromptMessage.new(role => 'assistant', content => MCP::Types::TextContent.new(text => 'b')),
            ]
        }
    );
    is $p4.get({})[0].content.text, 'a', 'array of PromptMessage first';
    is $p4.get({})[1].content.text, 'b', 'array of PromptMessage second';

    # Generator returning non-string fallback
    my $p5 = RegisteredPrompt.new(name => 'num', generator => { 99 });
    is $p5.get({})[0].content.text, '99', 'non-string fallback';

    dies-ok { prompt().build }, 'prompt requires name';
    dies-ok { prompt().name('p').build }, 'prompt requires generator';
};

subtest 'Builder title and icon methods', {
    # Tool builder
    my $t = tool()
        .name('icon-tool')
        .title('Icon Tool')
        .icon('https://example.com/icon.png', mimeType => 'image/png', sizes => ['48x48'])
        .icon('https://example.com/icon2.svg')
        .handler(-> { 'ok' })
        .build;

    my $tool-def = $t.to-tool;
    is $tool-def.title, 'Icon Tool', 'tool title set';
    is $tool-def.icons.elems, 2, 'tool has 2 icons';
    is $tool-def.icons[0].src, 'https://example.com/icon.png', 'tool icon src';
    is $tool-def.icons[0].mimeType, 'image/png', 'tool icon mimeType';
    is $tool-def.icons[1].src, 'https://example.com/icon2.svg', 'tool second icon';

    my %th = $tool-def.Hash;
    is %th<title>, 'Icon Tool', 'tool Hash title';
    is %th<icons>.elems, 2, 'tool Hash icons';

    # Resource builder
    my $r = resource()
        .uri('info://x')
        .name('X')
        .title('X Resource')
        .icon('https://example.com/res.png')
        .reader({ 'data' })
        .build;

    my $res-def = $r.to-resource;
    is $res-def.title, 'X Resource', 'resource title set';
    is $res-def.icons.elems, 1, 'resource has 1 icon';

    # Resource template builder
    my $rt = resource-template()
        .uri-template('file:///{path}')
        .name('Files')
        .title('File Browser')
        .icon('https://example.com/file.png')
        .reader(-> %p { 'content' })
        .build;

    my $rt-def = $rt.to-resource-template;
    is $rt-def.title, 'File Browser', 'resource template title set';
    is $rt-def.icons.elems, 1, 'resource template has 1 icon';

    # Prompt builder
    my $p = prompt()
        .name('icon-prompt')
        .title('Icon Prompt')
        .icon('https://example.com/prompt.png', mimeType => 'image/png')
        .generator(-> { 'hello' })
        .build;

    my $prompt-def = $p.to-prompt;
    is $prompt-def.title, 'Icon Prompt', 'prompt title set';
    is $prompt-def.icons.elems, 1, 'prompt has 1 icon';
    is $prompt-def.icons[0].mimeType, 'image/png', 'prompt icon mimeType';
};

subtest 'Tool name validation', {
    # Valid names
    lives-ok { tool().name('my-tool').handler(-> { 'ok' }).build }, 'valid: my-tool';
    lives-ok { tool().name('tool_1').handler(-> { 'ok' }).build }, 'valid: tool_1';
    lives-ok { tool().name('a').handler(-> { 'ok' }).build }, 'valid: single char';
    lives-ok { tool().name('a' x 64).handler(-> { 'ok' }).build }, 'valid: 64 chars';

    # Invalid names
    dies-ok { tool().name('').handler(-> { 'ok' }).build }, 'invalid: empty string';
    dies-ok { tool().name('a' x 65).handler(-> { 'ok' }).build }, 'invalid: 65 chars';
    dies-ok { tool().name('my tool').handler(-> { 'ok' }).build }, 'invalid: space';
    dies-ok { tool().name('tool!').handler(-> { 'ok' }).build }, 'invalid: exclamation';
    dies-ok { tool().name('tool.name').handler(-> { 'ok' }).build }, 'invalid: dot';
};

done-testing;
