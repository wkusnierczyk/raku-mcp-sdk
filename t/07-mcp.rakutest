use v6.d;
use Test;
use lib 'lib';

use MCP;

=begin pod
=head1 NAME

07-mcp.rakutest - Tests for MCP re-exports

=head1 DESCRIPTION

Validates the MCP top-level module exports and helpers.

=end pod

subtest 'MCP exports', {
    ok PROTOCOL_VERSION.defined, 'protocol version exported';
    is Implementation.^name, 'MCP::Types::Implementation', 'Implementation export';
    is TextContent.^name, 'MCP::Types::TextContent', 'TextContent export';
    is Tool.^name, 'MCP::Types::Tool', 'Tool export';

    is Server.^name, 'MCP::Server::Server', 'Server export';
    is Client.^name, 'MCP::Client::Client', 'Client export';

    my $tool = tool()
        .name('t')
        .handler(-> :%params { "ok" })
        .build;
    is $tool.name, 't', 'tool builder available';

    my $resource = resource()
        .uri('info://r')
        .name('R')
        .reader({ 'x' })
        .build;
    is $resource.uri, 'info://r', 'resource builder available';

    my $prompt = prompt()
        .name('p')
        .generator({ 'hi' })
        .build;
    is $prompt.name, 'p', 'prompt builder available';

    # file-resource convenience
    my $tmp = $*TMPDIR.add("mcp-export-test-$*PID.txt");
    $tmp.spurt("exported");
    my $fr = file-resource($tmp);
    ok $fr.uri.starts-with('file://'), 'file-resource exported';
    $tmp.unlink;

    # Additional type exports
    is ImageContent.^name, 'MCP::Types::ImageContent', 'ImageContent export';
    is AudioContent.^name, 'MCP::Types::AudioContent', 'AudioContent export';
    is ResourceLink.^name, 'MCP::Types::ResourceLink', 'ResourceLink export';
    is ToolUseContent.^name, 'MCP::Types::ToolUseContent', 'ToolUseContent export';
    is ToolResultContent.^name, 'MCP::Types::ToolResultContent', 'ToolResultContent export';
    is ModelHint.^name, 'MCP::Types::ModelHint', 'ModelHint export';
    is ModelPreferences.^name, 'MCP::Types::ModelPreferences', 'ModelPreferences export';
    is ToolChoice.^name, 'MCP::Types::ToolChoice', 'ToolChoice export';
    is CreateMessageResult.^name, 'MCP::Types::CreateMessageResult', 'CreateMessageResult export';
    is Task.^name, 'MCP::Types::Task', 'Task export';
    is CreateTaskResult.^name, 'MCP::Types::CreateTaskResult', 'CreateTaskResult export';
    ok StdioTransport.^name.contains('Stdio'), 'StdioTransport export';

    # resource-template builder
    my $rt = resource-template()
        .uri-template('info://items/{id}')
        .name('Item')
        .reader(-> :$id { "item $id" })
        .build;
    is $rt.name, 'Item', 'resource-template builder available';

    # Additional type exports
    is Extension.^name, 'MCP::Types::Extension', 'Extension export';
    is ResourceTemplate.^name, 'MCP::Types::ResourceTemplate', 'ResourceTemplate export';
    is TaskStatus.^name, 'TaskStatus', 'TaskStatus enum export';

    # Log-level constants
    ok Debug.defined, 'Debug log level exported';
    ok Info.defined, 'Info log level exported';
    ok Warning.defined, 'Warning log level exported';
    ok Error.defined, 'Error log level exported';

    # Transport role export
    ok Transport.^name.contains('Transport'), 'Transport role export';

    # StreamableHTTP exports
    ok StreamableHTTPClientTransport.^name.contains('StreamableHTTP'), 'StreamableHTTPClientTransport export';
    ok StreamableHTTPServerTransport.^name.contains('StreamableHTTP'), 'StreamableHTTPServerTransport export';
};

done-testing;
