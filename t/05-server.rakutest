use v6.d;
use Test;
use lib 'lib';
use lib 't/lib';

use MCP::Server;
use MCP::Types;
need MCP::JSONRPC;
use MCP::Server::Tool;
use MCP::Server::Resource;
use MCP::Server::Prompt;
need TestTransport;
use JSON::Fast;
use MIME::Base64;

=begin pod
=head1 NAME

05-server.rakutest - Tests for server dispatch and helpers

=head1 DESCRIPTION

Covers request dispatch, handler registration, and outgoing notifications.

=end pod

use MONKEY-TYPING;
augment class MCP::Server::Server {
    method handle-message-public($msg) { self!handle-message($msg) }
    method handle-response-public($msg) { self!handle-response($msg) }
}

subtest 'Server dispatch and handlers', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport,
        instructions => 'hello'
    );

    $server.add-tool(
        name => 'echo',
        description => 'Echo',
        handler => -> :%params { MCP::Types::TextContent.new(text => %params<msg> // '') }
    );
    $server.add-resource(
        uri => 'info://about',
        name => 'About',
        reader => { 'about' }
    );
    my %arg = name => 'name', required => True;
    $server.add-prompt(
        name => 'greet',
        arguments => [ %arg.item ],
        generator => -> :%params { "Hi %params<name>" }
    );

    my $init = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1,
        method => 'initialize',
        params => { protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION }
    ));
    is $init<protocolVersion>, MCP::Types::LATEST_PROTOCOL_VERSION, 'initialize returns protocol';
    is $init<instructions>, 'hello', 'initialize includes instructions';

    my $ping = $server.dispatch-request(MCP::JSONRPC::Request.new(id => 2, method => 'ping'));
    is-deeply $ping, {}, 'ping response empty';

    my $tools = $server.dispatch-request(MCP::JSONRPC::Request.new(id => 3, method => 'tools/list'));
    is $tools<tools>[0]<name>, 'echo', 'tools/list includes tool';

    my $tool-res = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 4,
        method => 'tools/call',
        params => { name => 'echo', arguments => { msg => 'yo' } }
    ));
    is $tool-res<content>[0]<text>, 'yo', 'tools/call returns content';

    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 5,
            method => 'tools/call',
            params => { }
        ));
    }, 'tools/call requires name';

    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 6,
            method => 'tools/call',
            params => { name => 'missing' }
        ));
    }, 'tools/call unknown tool';

    my $resources = $server.dispatch-request(MCP::JSONRPC::Request.new(id => 7, method => 'resources/list'));
    is $resources<resources>[0]<uri>, 'info://about', 'resources/list includes resource';

    my $read = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 8,
        method => 'resources/read',
        params => { uri => 'info://about' }
    ));
    is $read<contents>[0]<text>, 'about', 'resources/read returns content';

    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 9,
            method => 'resources/read',
            params => { }
        ));
    }, 'resources/read requires uri';

    my $prompts = $server.dispatch-request(MCP::JSONRPC::Request.new(id => 9, method => 'prompts/list'));
    is $prompts<prompts>[0]<name>, 'greet', 'prompts/list includes prompt';

    my $prompt = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 10,
        method => 'prompts/get',
        params => { name => 'greet', arguments => { name => 'Raku' } }
    ));
    is $prompt<messages>[0]<content><text>, 'Hi Raku', 'prompts/get returns message';

    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 11,
            method => 'prompts/get',
            params => { }
        ));
    }, 'prompts/get requires name';

    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 12,
            method => 'prompts/get',
            params => { name => 'missing' }
        ));
    }, 'prompts/get unknown prompt';

    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 13,
            method => 'unknown/method'
        ));
    }, 'unknown method raises error';

    my $req-p = $server.request('ping');
    my $req = $transport.sent[0];
    $server.handle-response-public(MCP::JSONRPC::Response.success($req.id, { ok => True }));
    is (await $req-p)<ok>, True, 'server request resolves';

    $server.notify('notifications/message', { msg => 'hi' });
    $server.log(MCP::Types::Info, 'data', logger => 'test');
    $server.progress(0.5e0, total => 1e0, message => 'half', token => 'token');
    ok $transport.sent.grep(MCP::JSONRPC::Notification).elems >= 3, 'notifications sent';

    $server.handle-message-public(MCP::JSONRPC::Notification.new(method => 'initialized'));
    $server.handle-message-public(MCP::JSONRPC::Notification.new(method => 'cancelled', params => { requestId => 1 }));
};

subtest 'Pagination support', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport,
        page-size => 2  # Small page size for testing
    );

    # Add 5 tools to test pagination
    for 1..5 -> $i {
        $server.add-tool(
            name => "tool$i",
            description => "Tool $i",
            handler => -> { "result$i" }
        );
    }

    # Test first page - should have 2 items and nextCursor
    my $page1 = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1,
        method => 'tools/list'
    ));
    is $page1<tools>.elems, 2, 'first page has 2 items';
    ok $page1<nextCursor>.defined, 'first page has nextCursor';

    # Test using cursor returns next page
    my $page2 = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 2,
        method => 'tools/list',
        params => { cursor => $page1<nextCursor> }
    ));
    is $page2<tools>.elems, 2, 'second page has 2 items';
    ok $page2<nextCursor>.defined, 'second page has nextCursor';

    # Ensure pages have different items
    my @page1-names = $page1<tools>.map(*<name>);
    my @page2-names = $page2<tools>.map(*<name>);
    ok @page1-names ne @page2-names, 'pages have different items';

    # Test last page has no nextCursor
    my $page3 = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 3,
        method => 'tools/list',
        params => { cursor => $page2<nextCursor> }
    ));
    is $page3<tools>.elems, 1, 'last page has 1 item';
    nok $page3<nextCursor>.defined, 'last page has no nextCursor';

    # Test invalid cursor returns InvalidParams error
    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 4,
            method => 'tools/list',
            params => { cursor => 'invalid-cursor' }
        ));
    }, 'invalid cursor raises error';

    # Test malformed base64 cursor
    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 5,
            method => 'tools/list',
            params => { cursor => '!!!' }
        ));
    }, 'malformed cursor raises error';

    # Test empty list returns no nextCursor
    my $empty-server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport,
        page-size => 2
    );
    my $empty-result = $empty-server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 6,
        method => 'tools/list'
    ));
    is $empty-result<tools>.elems, 0, 'empty list has 0 items';
    nok $empty-result<nextCursor>.defined, 'empty list has no nextCursor';

    # Test pagination for resources
    for 1..3 -> $i {
        $server.add-resource(
            uri => "info://res$i",
            name => "Resource $i",
            reader => { "content$i" }
        );
    }
    my $res-page1 = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 7,
        method => 'resources/list'
    ));
    is $res-page1<resources>.elems, 2, 'resources first page has 2 items';
    ok $res-page1<nextCursor>.defined, 'resources first page has nextCursor';

    # Test pagination for prompts
    for 1..3 -> $i {
        $server.add-prompt(
            name => "prompt$i",
            description => "Prompt $i",
            generator => { "message$i" }
        );
    }
    my $prompt-page1 = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 8,
        method => 'prompts/list'
    ));
    is $prompt-page1<prompts>.elems, 2, 'prompts first page has 2 items';
    ok $prompt-page1<nextCursor>.defined, 'prompts first page has nextCursor';
};

subtest 'Cancellation support', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    # Test is-cancelled returns False for unknown request
    nok $server.is-cancelled('unknown-id'), 'is-cancelled returns False for unknown request';

    # Test cancellation notification is handled
    # We need to simulate an in-flight request being cancelled
    # Since dispatch-request is synchronous for simple handlers, we test the notification handling

    # Test that notifications/cancelled is accepted (doesn't throw)
    lives-ok {
        $server.handle-message-public(MCP::JSONRPC::Notification.new(
            method => 'notifications/cancelled',
            params => { requestId => 'some-id', reason => 'test' }
        ));
    }, 'notifications/cancelled is handled without error';

    # Test cancel-request sends notification
    $transport.clear-sent;
    $server.cancel-request('req-123', reason => 'User cancelled');
    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'cancel-request sends notification';
    is @notifications[0].method, 'notifications/cancelled', 'notification method is correct';
    is @notifications[0].params<requestId>, 'req-123', 'notification has correct requestId';
    is @notifications[0].params<reason>, 'User cancelled', 'notification has correct reason';

    # Test cancel-request without reason
    $transport.clear-sent;
    $server.cancel-request('req-456');
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'cancel-request without reason sends notification';
    nok @notifications[0].params<reason>:exists, 'notification has no reason when not provided';

    # Test cancellation of in-flight request suppresses response
    # Use a Promise-based handler that we can control
    my $handler-promise = Promise.new;
    my $handler-vow = $handler-promise.vow;

    my $server2 = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv2', version => '0.1'),
        transport => $transport
    );
    $server2.add-tool(
        name => 'slow-tool',
        description => 'A slow tool for testing cancellation',
        handler => -> {
            await $handler-promise;  # Wait until we signal completion
            'completed'
        }
    );

    $transport.clear-sent;

    # Start request processing in background
    my $request-task = start {
        $server2.handle-message-public(MCP::JSONRPC::Request.new(
            id => 'cancel-test-1',
            method => 'tools/call',
            params => { name => 'slow-tool', arguments => {} }
        ));
    };

    # Give the handler time to start
    sleep 0.1;

    # Verify request is tracked as in-flight
    ok $server2.is-cancelled('cancel-test-1') === False, 'in-flight request is tracked';

    # Send cancellation while handler is running
    $server2.handle-message-public(MCP::JSONRPC::Notification.new(
        method => 'notifications/cancelled',
        params => { requestId => 'cancel-test-1', reason => 'test cancellation' }
    ));

    # Verify request is now marked as cancelled
    ok $server2.is-cancelled('cancel-test-1'), 'is-cancelled returns True after cancellation';

    # Complete the handler
    $handler-vow.keep(True);
    await $request-task;

    # Verify no response was sent (key behavior!)
    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    is @responses.elems, 0, 'cancelled request does not send response';
};

subtest 'Protocol version handling', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    # Verify SUPPORTED_PROTOCOL_VERSIONS constant contains expected versions
    ok MCP::Types::LATEST_PROTOCOL_VERSION eq '2025-11-25', 'latest protocol version is 2025-11-25';
    ok '2025-11-25' ~~ any(MCP::Types::SUPPORTED_PROTOCOL_VERSIONS.list), 'SUPPORTED contains 2025-11-25';
    ok '2025-03-26' ~~ any(MCP::Types::SUPPORTED_PROTOCOL_VERSIONS.list), 'SUPPORTED contains 2025-03-26';
    ok '2024-11-05' ~~ any(MCP::Types::SUPPORTED_PROTOCOL_VERSIONS.list), 'SUPPORTED contains 2024-11-05';

    # Test client with latest protocol version
    my $init-latest = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1,
        method => 'initialize',
        params => { protocolVersion => '2025-11-25' }
    ));
    is $init-latest<protocolVersion>, '2025-11-25',
        'server echoes latest version for 2025-11-25 client';

    # Test client with older supported version (2025-03-26) — server negotiates to client's version
    my $server2 = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv2', version => '0.1'),
        transport => $transport
    );
    my $init-older = $server2.dispatch-request(MCP::JSONRPC::Request.new(
        id => 2,
        method => 'initialize',
        params => { protocolVersion => '2025-03-26' }
    ));
    is $init-older<protocolVersion>, '2025-03-26',
        'server negotiates to client version 2025-03-26';
    ok $init-older<capabilities>:exists, 'server includes capabilities for older client';

    # Test client with even older supported version (2024-11-05)
    my $server3 = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv3', version => '0.1'),
        transport => $transport
    );
    my $init-oldest = $server3.dispatch-request(MCP::JSONRPC::Request.new(
        id => 3,
        method => 'initialize',
        params => { protocolVersion => '2024-11-05' }
    ));
    is $init-oldest<protocolVersion>, '2024-11-05',
        'server negotiates to client version 2024-11-05';
    ok $init-oldest<serverInfo>:exists, 'server includes serverInfo for older client';
    is $init-oldest<serverInfo><name>, 'srv3', 'serverInfo has correct name';

    # Test client with unsupported version — server falls back to latest
    my $server4 = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv4', version => '0.1'),
        transport => $transport
    );
    my $init-unknown = $server4.dispatch-request(MCP::JSONRPC::Request.new(
        id => 4,
        method => 'initialize',
        params => { protocolVersion => '2099-01-01' }
    ));
    is $init-unknown<protocolVersion>, MCP::Types::LATEST_PROTOCOL_VERSION,
        'server falls back to latest version for unsupported client version';
    ok $init-unknown<capabilities>:exists, 'server includes capabilities for unsupported client';
};

subtest 'Annotations in list responses', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    # Add tool with annotations
    $server.add-tool(
        MCP::Server::Tool::tool()
            .name('delete-file')
            .description('Delete a file')
            .annotations(destructiveHint => True, readOnlyHint => False, title => 'File Deleter')
            .handler(-> { 'deleted' })
            .build
    );

    # Add resource with annotations
    $server.add-resource(
        MCP::Server::Resource::resource()
            .uri('info://config')
            .name('Config')
            .description('Configuration')
            .annotations(['user', 'assistant'], priority => 0.8)
            .reader(-> { 'config data' })
            .build
    );

    # Verify tool annotations in tools/list response
    my $tools = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1,
        method => 'tools/list'
    ));
    ok $tools<tools>[0]<annotations>:exists, 'tool annotations in list response';
    is $tools<tools>[0]<annotations><title>, 'File Deleter', 'tool title annotation';
    ok $tools<tools>[0]<annotations><destructiveHint>, 'tool destructiveHint annotation';
    nok $tools<tools>[0]<annotations><readOnlyHint>, 'tool readOnlyHint annotation';

    # Verify resource annotations in resources/list response
    my $resources = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 2,
        method => 'resources/list'
    ));
    ok $resources<resources>[0]<annotations>:exists, 'resource annotations in list response';
    is $resources<resources>[0]<annotations><priority>, 0.8, 'resource priority annotation';
    is-deeply $resources<resources>[0]<annotations><audience>, ['user', 'assistant'], 'resource audience annotation';
};

subtest 'Resource subscriptions', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    # Add resources to subscribe to
    $server.add-resource(
        uri => 'file://test.txt',
        name => 'Test File',
        reader => { 'content' }
    );
    $server.add-resource(
        uri => 'file://other.txt',
        name => 'Other File',
        reader => { 'other content' }
    );

    # Verify capabilities include subscribe
    my $init = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1,
        method => 'initialize',
        params => { protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION }
    ));
    ok $init<capabilities><resources><subscribe>, 'capabilities include subscribe';

    # Test subscribe to resource
    my $sub-result = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 2,
        method => 'resources/subscribe',
        params => { uri => 'file://test.txt' }
    ));
    is-deeply $sub-result, {}, 'subscribe returns empty response';

    # Verify resource is subscribed
    ok $server.is-subscribed('file://test.txt'), 'resource is marked as subscribed';
    nok $server.is-subscribed('file://other.txt'), 'other resource is not subscribed';

    # Test subscribe requires uri
    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 3,
            method => 'resources/subscribe',
            params => {}
        ));
    }, 'subscribe requires uri parameter';

    # Test subscribe to unknown resource
    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 4,
            method => 'resources/subscribe',
            params => { uri => 'file://nonexistent.txt' }
        ));
    }, 'subscribe to unknown resource fails';

    # Test notify-resource-updated sends notification for subscribed resource
    $transport.clear-sent;
    $server.notify-resource-updated('file://test.txt');
    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'notify-resource-updated sends notification';
    is @notifications[0].method, 'notifications/resources/updated', 'notification method is correct';
    is @notifications[0].params<uri>, 'file://test.txt', 'notification has correct uri';

    # Test notify-resource-updated does NOT send for unsubscribed resource
    $transport.clear-sent;
    $server.notify-resource-updated('file://other.txt');
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 0, 'no notification for unsubscribed resource';

    # Test unsubscribe
    my $unsub-result = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 5,
        method => 'resources/unsubscribe',
        params => { uri => 'file://test.txt' }
    ));
    is-deeply $unsub-result, {}, 'unsubscribe returns empty response';
    nok $server.is-subscribed('file://test.txt'), 'resource is no longer subscribed';

    # Test notify-resource-updated after unsubscribe
    $transport.clear-sent;
    $server.notify-resource-updated('file://test.txt');
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 0, 'no notification after unsubscribe';

    # Test unsubscribe requires uri
    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 6,
            method => 'resources/unsubscribe',
            params => {}
        ));
    }, 'unsubscribe requires uri parameter';

    # Test unsubscribe from unknown resource (should succeed silently)
    lives-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 7,
            method => 'resources/unsubscribe',
            params => { uri => 'file://never-subscribed.txt' }
        ));
    }, 'unsubscribe from unknown resource succeeds';

    # Test notify-resources-list-changed
    $transport.clear-sent;
    $server.notify-resources-list-changed();
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'notify-resources-list-changed sends notification';
    is @notifications[0].method, 'notifications/resources/list_changed', 'list changed notification method is correct';

    # Test multiple subscriptions
    $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 8,
        method => 'resources/subscribe',
        params => { uri => 'file://test.txt' }
    ));
    $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 9,
        method => 'resources/subscribe',
        params => { uri => 'file://other.txt' }
    ));
    ok $server.is-subscribed('file://test.txt'), 'first resource still subscribed';
    ok $server.is-subscribed('file://other.txt'), 'second resource now subscribed';

    # Test notifications sent only for subscribed resources when multiple subscribed
    $transport.clear-sent;
    $server.notify-resource-updated('file://test.txt');
    $server.notify-resource-updated('file://other.txt');
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 2, 'both subscribed resources get notifications';

    # Test idempotent subscribe (subscribing twice should succeed)
    lives-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 10,
            method => 'resources/subscribe',
            params => { uri => 'file://test.txt' }
        ));
    }, 'subscribing twice succeeds (idempotent)';
    ok $server.is-subscribed('file://test.txt'), 'still subscribed after double subscribe';

    # Test is-subscribed for completely unknown URI
    nok $server.is-subscribed('file://never-existed.txt'), 'is-subscribed returns false for unknown URI';

    # Test notify-resource-updated for unknown URI (should not send, not throw)
    $transport.clear-sent;
    lives-ok {
        $server.notify-resource-updated('file://unknown-resource.txt');
    }, 'notify-resource-updated for unknown URI does not throw';
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 0, 'no notification sent for unknown URI';
};

subtest 'Prompt list changed notification', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $server.add-prompt(
        name => 'greet',
        description => 'Greeting',
        generator => -> :%params { 'hello' }
    );

    $transport.clear-sent;
    $server.notify-prompts-list-changed();
    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'notify-prompts-list-changed sends notification';
    is @notifications[0].method, 'notifications/prompts/list_changed', 'prompt list changed notification method is correct';
};

subtest 'Server list-roots', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    # Test list-roots sends request to client
    $transport.clear-sent;
    my $roots-promise = $server.list-roots;

    # Verify request was sent
    my @requests = $transport.sent.grep(MCP::JSONRPC::Request);
    is @requests.elems, 1, 'list-roots sends request';
    is @requests[0].method, 'roots/list', 'request method is roots/list';

    # Simulate client response
    $server.handle-response-public(MCP::JSONRPC::Response.success(@requests[0].id, {
        roots => [
            { uri => 'file:///project', name => 'Project' },
            { uri => 'file:///home' },
        ]
    }));

    # Verify promise resolves with Root objects
    my @roots = await $roots-promise;
    is @roots.elems, 2, 'list-roots returns 2 roots';
    isa-ok @roots[0], MCP::Types::Root, 'first item is Root';
    is @roots[0].uri, 'file:///project', 'first root uri correct';
    is @roots[0].name, 'Project', 'first root name correct';
    isa-ok @roots[1], MCP::Types::Root, 'second item is Root';
    is @roots[1].uri, 'file:///home', 'second root uri correct';

    # Test empty roots response
    $transport.clear-sent;
    my $empty-promise = $server.list-roots;
    @requests = $transport.sent.grep(MCP::JSONRPC::Request);
    $server.handle-response-public(MCP::JSONRPC::Response.success(@requests[0].id, {
        roots => []
    }));
    my @empty-roots = await $empty-promise;
    is @empty-roots.elems, 0, 'empty roots returns empty array';
};

subtest 'Server elicitation', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'test', version => '0.1'),
        transport => $transport,
    );

    # Test elicit (form mode)
    $transport.clear-sent;
    my $elicit-promise = $server.elicit(
        message => 'Please enter your name',
        schema => {
            type => 'object',
            properties => {
                name => { type => 'string' }
            },
            required => ['name']
        }
    );

    # Verify request was sent
    my @requests = $transport.sent.grep(MCP::JSONRPC::Request);
    is @requests.elems, 1, 'elicit sends request';
    is @requests[0].method, 'elicitation/create', 'request method is elicitation/create';
    is @requests[0].params<mode>, 'form', 'mode is form';
    is @requests[0].params<message>, 'Please enter your name', 'message is correct';
    ok @requests[0].params<requestedSchema>:exists, 'requestedSchema exists';

    # Simulate client response
    $server.handle-response-public(MCP::JSONRPC::Response.success(@requests[0].id, {
        action => 'accept',
        content => { name => 'Alice' }
    }));

    my $response = await $elicit-promise;
    isa-ok $response, MCP::Types::ElicitationResponse, 'response is ElicitationResponse';
    is $response.action, MCP::Types::ElicitAccept, 'action is accept';
    is $response.content<name>, 'Alice', 'content has name';

    # Test elicit-url (URL mode)
    $transport.clear-sent;
    my $url-promise = $server.elicit-url(
        message => 'Please provide your API key',
        url => 'https://example.com/auth',
        elicitation-id => 'test-123'
    );

    @requests = $transport.sent.grep(MCP::JSONRPC::Request);
    is @requests.elems, 1, 'elicit-url sends request';
    is @requests[0].params<mode>, 'url', 'mode is url';
    is @requests[0].params<url>, 'https://example.com/auth', 'url is correct';
    is @requests[0].params<elicitationId>, 'test-123', 'elicitationId is correct';

    $server.handle-response-public(MCP::JSONRPC::Response.success(@requests[0].id, {
        action => 'accept'
    }));
    my $url-response = await $url-promise;
    is $url-response.action, MCP::Types::ElicitAccept, 'URL elicit returns accept';

    # Test notify-elicitation-complete
    $transport.clear-sent;
    $server.notify-elicitation-complete('test-123');
    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'notification sent';
    is @notifications[0].method, 'notifications/elicitation/complete', 'notification method';
    is @notifications[0].params<elicitationId>, 'test-123', 'notification has elicitationId';
};

# Test tool output schemas
subtest 'Tool output schemas', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'test', version => '0.1'),
        transport => $transport,
    );

    # Add tool with outputSchema via named parameters
    $server.add-tool(
        name => 'weather',
        description => 'Get weather',
        output-schema => {
            type => 'object',
            properties => {
                temperature => { type => 'number' },
                conditions => { type => 'string' },
            },
        },
        handler => -> :%params { { temperature => 72, conditions => 'sunny' } }
    );

    # Add tool without outputSchema
    $server.add-tool(
        name => 'echo',
        description => 'Echo text',
        handler => -> :%params { %params<msg> // 'hello' }
    );

    # tools/list should include outputSchema
    my $list = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1, method => 'tools/list',
    ));
    my @tools = $list<tools>.Array;
    my $weather-def = @tools.grep(*<name> eq 'weather').head;
    my $echo-def = @tools.grep(*<name> eq 'echo').head;

    ok $weather-def<outputSchema>.defined, 'tools/list includes outputSchema';
    is $weather-def<outputSchema><type>, 'object', 'outputSchema type in listing';
    nok $echo-def<outputSchema>.defined, 'no outputSchema for tool without it';

    # tools/call should return structuredContent
    my $call = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 2,
        method => 'tools/call',
        params => { name => 'weather', arguments => {} },
    ));
    ok $call<structuredContent>.defined, 'tools/call has structuredContent';
    is $call<structuredContent><temperature>, 72, 'structuredContent temperature';
    is $call<structuredContent><conditions>, 'sunny', 'structuredContent conditions';
    ok $call<content>.elems >= 1, 'content fallback present';

    # tools/call without outputSchema should not have structuredContent
    my $echo-call = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 3,
        method => 'tools/call',
        params => { name => 'echo', arguments => {} },
    ));
    nok $echo-call<structuredContent>.defined, 'no structuredContent without outputSchema';
};

# Test completion/complete
subtest 'Completion support', {
    my $transport = TestTransport::TestTransport.new;
    my $server = MCP::Server::Server.new(
        info => MCP::Types::Implementation.new(name => 'test', version => '0.1'),
        transport => $transport,
    );

    # Register a prompt completer that returns suggestions
    $server.add-prompt-completer('code-review', -> $arg-name, $value, *%context {
        my @all = <python javascript typescript ruby go rust>;
        my @matched = @all.grep(*.starts-with($value));
        { values => @matched }
    });

    # Register a resource completer
    $server.add-resource-completer('file:///projects', -> $arg-name, $value, *%context {
        <project-a project-b project-c>.grep(*.starts-with($value)).Array
    });

    # Test prompt completion
    my $req1 = MCP::JSONRPC::Request.new(
        id => 1,
        method => 'completion/complete',
        params => {
            ref => { type => 'ref/prompt', name => 'code-review' },
            argument => { name => 'language', value => 'py' },
        },
    );
    $server.handle-message-public($req1);
    my @sent = $transport.sent;
    ok @sent.elems >= 1, 'got response';
    my $resp1 = @sent[*-1];
    ok $resp1 ~~ MCP::JSONRPC::Response, 'response is Response';
    ok $resp1.result<completion>.defined, 'has completion';
    is $resp1.result<completion><values>, ['python'], 'filtered to matching values';

    # Test resource completion returning an Array
    $transport.clear-sent;
    my $req2 = MCP::JSONRPC::Request.new(
        id => 2,
        method => 'completion/complete',
        params => {
            ref => { type => 'ref/resource', uri => 'file:///projects' },
            argument => { name => 'name', value => 'project-a' },
        },
    );
    $server.handle-message-public($req2);
    my $resp2 = $transport.sent[*-1];
    is $resp2.result<completion><values>, ['project-a'], 'resource completion works';

    # Test completion with no completer registered (empty result)
    $transport.clear-sent;
    my $req3 = MCP::JSONRPC::Request.new(
        id => 3,
        method => 'completion/complete',
        params => {
            ref => { type => 'ref/prompt', name => 'unknown-prompt' },
            argument => { name => 'arg', value => 'x' },
        },
    );
    $server.handle-message-public($req3);
    my $resp3 = $transport.sent[*-1];
    is $resp3.result<completion><values>, [], 'unregistered completer returns empty';

    # Test invalid ref type
    $transport.clear-sent;
    my $req4 = MCP::JSONRPC::Request.new(
        id => 4,
        method => 'completion/complete',
        params => {
            ref => { type => 'ref/invalid' },
            argument => { name => 'arg', value => 'x' },
        },
    );
    $server.handle-message-public($req4);
    my $resp4 = $transport.sent[*-1];
    ok $resp4.error.defined, 'invalid ref type returns error';

    # Test capabilities include completions
    my $caps = $server.capabilities;
    ok $caps.completions.defined, 'capabilities include completions';
};

subtest 'Logging level setting and filtering', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'log-srv', version => '0.1'),
        transport => $transport
    );

    # Initialize the server
    $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1,
        method => 'initialize',
        params => { protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION }
    ));
    $transport.clear-sent;

    # Default level is Debug — all messages should be emitted
    $server.log(MCP::Types::Debug, 'debug msg');
    $server.log(MCP::Types::Info, 'info msg');
    $server.log(MCP::Types::Warning, 'warn msg');
    is $transport.sent.elems, 3, 'default level emits all log messages';
    $transport.clear-sent;

    # Set log level to Warning
    my $result = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 2,
        method => 'logging/setLevel',
        params => { level => 'warning' }
    ));
    ok $result ~~ Hash, 'logging/setLevel returns empty result';
    $transport.clear-sent;

    # Debug and Info should be suppressed, Warning and above emitted
    $server.log(MCP::Types::Debug, 'should be suppressed');
    $server.log(MCP::Types::Info, 'should be suppressed');
    $server.log(MCP::Types::Warning, 'should be emitted');
    $server.log(MCP::Types::Error, 'should be emitted');
    is $transport.sent.elems, 2, 'messages below Warning are suppressed';

    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications[0].params<level>, 'warning', 'first emitted is warning';
    is @notifications[1].params<level>, 'error', 'second emitted is error';
    $transport.clear-sent;

    # Set level to Emergency — only Emergency should be emitted
    $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 3,
        method => 'logging/setLevel',
        params => { level => 'emergency' }
    ));
    $transport.clear-sent;

    $server.log(MCP::Types::Critical, 'should be suppressed');
    $server.log(MCP::Types::Alert, 'should be suppressed');
    $server.log(MCP::Types::Emergency, 'should be emitted');
    is $transport.sent.elems, 1, 'only Emergency emitted at Emergency level';
    $transport.clear-sent;

    # Reset to Debug — all messages should be emitted again
    $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 4,
        method => 'logging/setLevel',
        params => { level => 'debug' }
    ));
    $transport.clear-sent;

    $server.log(MCP::Types::Debug, 'debug after reset');
    is $transport.sent.elems, 1, 'all messages emitted after resetting to Debug';
    $transport.clear-sent;

    # Invalid log level returns error
    my $bad-result = try {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 5,
            method => 'logging/setLevel',
            params => { level => 'nonexistent' }
        ));
    };
    ok $! ~~ X::MCP::JSONRPC, 'invalid log level raises error';
};

subtest 'Progress token from _meta', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'progress-srv', version => '0.1'),
        transport => $transport
    );

    # Register a tool that sends progress using the implicit token
    $server.add-tool(
        tool()
            .name('slow-task')
            .description('A slow task')
            .handler(-> {
                $server.progress(0.5e0, total => 1e0, message => 'halfway');
                'done'
            })
            .build
    );

    # Initialize
    $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1,
        method => 'initialize',
        params => { protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION }
    ));
    $transport.clear-sent;

    # Call tool with _meta.progressToken
    $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 2,
        method => 'tools/call',
        params => {
            name => 'slow-task',
            _meta => { progressToken => 'tok-42' }
        }
    ));

    my @progress-notifs = $transport.sent.grep({
        $_ ~~ MCP::JSONRPC::Notification && $_.method eq 'notifications/progress'
    });
    is @progress-notifs.elems, 1, 'one progress notification sent';
    is @progress-notifs[0].params<progressToken>, 'tok-42', 'uses token from _meta';
    is @progress-notifs[0].params<progress>, 0.5e0, 'progress value correct';
    is @progress-notifs[0].params<total>, 1e0, 'total value correct';
    is @progress-notifs[0].params<message>, 'halfway', 'message correct';
    $transport.clear-sent;

    # Call tool without _meta — no progress notification emitted
    $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 3,
        method => 'tools/call',
        params => { name => 'slow-task' }
    ));

    my @no-progress = $transport.sent.grep({
        $_ ~~ MCP::JSONRPC::Notification && $_.method eq 'notifications/progress'
    });
    is @no-progress.elems, 0, 'no progress notification when no _meta token';
    $transport.clear-sent;

    # Explicit token overrides _meta
    $server.add-tool(
        tool()
            .name('explicit-progress')
            .description('Uses explicit token')
            .handler(-> {
                $server.progress(0.75e0, token => 'explicit-tok');
                'done'
            })
            .build
    );
    $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 4,
        method => 'tools/call',
        params => {
            name => 'explicit-progress',
            _meta => { progressToken => 'meta-tok' }
        }
    ));

    my @explicit = $transport.sent.grep({
        $_ ~~ MCP::JSONRPC::Notification && $_.method eq 'notifications/progress'
    });
    is @explicit.elems, 1, 'explicit token progress sent';
    is @explicit[0].params<progressToken>, 'explicit-tok', 'explicit token used over _meta';
};

subtest 'Server create-message', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $transport.clear-sent;
    my $msg-promise = $server.create-message(
        messages => [
            MCP::Types::SamplingMessage.new(role => 'user', content => MCP::Types::TextContent.new(text => 'Hello')),
        ],
        maxTokens => 100,
        systemPrompt => 'Be concise',
        modelPreferences => MCP::Types::ModelPreferences.new(
            hints => [MCP::Types::ModelHint.new(name => 'fast')],
            speedPriority => 0.9e0,
        ),
    );

    my @requests = $transport.sent.grep(MCP::JSONRPC::Request);
    is @requests.elems, 1, 'create-message sends request';
    is @requests[0].method, 'sampling/createMessage', 'method is sampling/createMessage';
    is @requests[0].params<maxTokens>, 100, 'maxTokens passed';
    is @requests[0].params<systemPrompt>, 'Be concise', 'systemPrompt passed';
    ok @requests[0].params<modelPreferences>.defined, 'modelPreferences passed';
    ok @requests[0].params<messages>.elems == 1, 'messages passed';

    # Simulate response
    $server.handle-response-public(MCP::JSONRPC::Response.success(@requests[0].id, {
        role => 'assistant',
        model => 'test-model',
        content => { type => 'text', text => 'Hi there' },
        stopReason => 'endTurn',
    }));

    my $result = await $msg-promise;
    isa-ok $result, MCP::Types::CreateMessageResult, 'returns CreateMessageResult';
    is $result.role, 'assistant', 'role correct';
    is $result.model, 'test-model', 'model correct';
};

subtest 'Server create-message with tools and toolChoice', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $transport.clear-sent;
    my $p = $server.create-message(
        messages => [
            MCP::Types::SamplingMessage.new(role => 'user', content => MCP::Types::TextContent.new(text => 'calc')),
        ],
        tools => [
            MCP::Types::Tool.new(name => 'calc', inputSchema => { type => 'object' }),
        ],
        toolChoice => MCP::Types::ToolChoice.new(mode => 'tool', name => 'calc'),
    );

    my @requests = $transport.sent.grep(MCP::JSONRPC::Request);
    ok @requests[0].params<tools>.elems == 1, 'tools passed';
    is @requests[0].params<tools>[0]<name>, 'calc', 'tool name serialized';
    is @requests[0].params<toolChoice><mode>, 'tool', 'toolChoice serialized';

    $server.handle-response-public(MCP::JSONRPC::Response.success(@requests[0].id, {
        role => 'assistant', model => 'm', stopReason => 'endTurn', content => { type => 'text', text => 'ok' },
    }));
    await $p;
    pass 'create-message with tools completes';
};

subtest 'Logging with logger field', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $transport.clear-sent;
    $server.log(MCP::Types::Info, 'test data', logger => 'myapp');

    my @notifs = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifs.elems, 1, 'log notification sent';
    is @notifs[0].params<level>, 'info', 'level correct';
    is @notifs[0].params<data>, 'test data', 'data correct';
    is @notifs[0].params<logger>, 'myapp', 'logger field present';

    # Without logger
    $transport.clear-sent;
    $server.log(MCP::Types::Warning, 'warn msg');
    @notifs = $transport.sent.grep(MCP::JSONRPC::Notification);
    nok @notifs[0].params<logger>:exists, 'no logger when not provided';
};

subtest 'logging/setLevel missing level param', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $transport.clear-sent;
    $server.handle-message-public(MCP::JSONRPC::Request.new(
        id => 'log-1',
        method => 'logging/setLevel',
        params => {}
    ));

    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @responses[0].error.defined, 'missing level returns error';
    is @responses[0].error.code, MCP::JSONRPC::InvalidParams.value, 'InvalidParams error';
};

subtest 'Server tool handler exception types', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $server.add-tool(
        name => 'mcp-error',
        handler => -> {
            die X::MCP::JSONRPC.new(
                error => MCP::JSONRPC::Error.from-code(
                    MCP::JSONRPC::InvalidParams,
                    "Bad input: missing field"
                )
            );
        }
    );

    $transport.clear-sent;
    $server.handle-message-public(MCP::JSONRPC::Request.new(
        id => 'err-mcp',
        method => 'tools/call',
        params => { name => 'mcp-error', arguments => {} }
    ));

    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @responses[0].error.defined, 'MCP error propagated';
    is @responses[0].error.code, MCP::JSONRPC::InvalidParams.value, 'InvalidParams code preserved';
    ok @responses[0].error.message.contains('Bad input'), 'custom message preserved';
};

subtest 'Server is-cancelled and cancel-request edge cases', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    nok $server.is-cancelled('nonexistent'), 'is-cancelled returns False for nonexistent ID';

    $transport.clear-sent;
    $server.cancel-request('unknown-req');
    my @notifs = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifs.elems, 1, 'cancel-request sends notification even for unknown ID';
};

subtest 'Server resources/read unknown resource', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $transport.clear-sent;
    $server.handle-message-public(MCP::JSONRPC::Request.new(
        id => 'read-1',
        method => 'resources/read',
        params => { uri => 'file://nonexistent' }
    ));

    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @responses[0].error.defined, 'unknown resource returns error';
    ok @responses[0].error.message.contains('Unknown resource'), 'error message mentions unknown';
};

subtest 'Server handles error response from client', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    $transport.clear-sent;
    my $p = $server.request('sampling/createMessage', { messages => [] });
    my @reqs = $transport.sent.grep(MCP::JSONRPC::Request);
    my $req-id = @reqs[0].id;

    $server.handle-response-public(MCP::JSONRPC::Response.error($req-id,
        MCP::JSONRPC::Error.from-code(MCP::JSONRPC::MethodNotFound, 'Not supported')
    ));

    dies-ok { await $p }, 'error response breaks promise';
};

done-testing;
