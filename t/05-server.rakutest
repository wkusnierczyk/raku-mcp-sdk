use v6.d;
use Test;
use lib 'lib';
use lib 't/lib';

use MCP::Server;
use MCP::Types;
need MCP::JSONRPC;
use MCP::Server::Tool;
use MCP::Server::Resource;
use MCP::Server::Prompt;
need TestTransport;
use JSON::Fast;
use MIME::Base64;

=begin pod
=head1 NAME

05-server.rakutest - Tests for server dispatch and helpers

=head1 DESCRIPTION

Covers request dispatch, handler registration, and outgoing notifications.

=end pod

use MONKEY-TYPING;
augment class MCP::Server::Server {
    method handle-message-public($msg) { self!handle-message($msg) }
    method handle-response-public($msg) { self!handle-response($msg) }
}

subtest 'Server dispatch and handlers', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport,
        instructions => 'hello'
    );

    $server.add-tool(
        name => 'echo',
        description => 'Echo',
        handler => -> :%params { MCP::Types::TextContent.new(text => %params<msg> // '') }
    );
    $server.add-resource(
        uri => 'info://about',
        name => 'About',
        reader => { 'about' }
    );
    my %arg = name => 'name', required => True;
    $server.add-prompt(
        name => 'greet',
        arguments => [ %arg.item ],
        generator => -> :%params { "Hi %params<name>" }
    );

    my $init = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1,
        method => 'initialize',
        params => { protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION }
    ));
    is $init<protocolVersion>, MCP::Types::LATEST_PROTOCOL_VERSION, 'initialize returns protocol';
    is $init<instructions>, 'hello', 'initialize includes instructions';

    my $ping = $server.dispatch-request(MCP::JSONRPC::Request.new(id => 2, method => 'ping'));
    is-deeply $ping, {}, 'ping response empty';

    my $tools = $server.dispatch-request(MCP::JSONRPC::Request.new(id => 3, method => 'tools/list'));
    is $tools<tools>[0]<name>, 'echo', 'tools/list includes tool';

    my $tool-res = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 4,
        method => 'tools/call',
        params => { name => 'echo', arguments => { msg => 'yo' } }
    ));
    is $tool-res<content>[0]<text>, 'yo', 'tools/call returns content';

    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 5,
            method => 'tools/call',
            params => { }
        ));
    }, 'tools/call requires name';

    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 6,
            method => 'tools/call',
            params => { name => 'missing' }
        ));
    }, 'tools/call unknown tool';

    my $resources = $server.dispatch-request(MCP::JSONRPC::Request.new(id => 7, method => 'resources/list'));
    is $resources<resources>[0]<uri>, 'info://about', 'resources/list includes resource';

    my $read = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 8,
        method => 'resources/read',
        params => { uri => 'info://about' }
    ));
    is $read<contents>[0]<text>, 'about', 'resources/read returns content';

    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 9,
            method => 'resources/read',
            params => { }
        ));
    }, 'resources/read requires uri';

    my $prompts = $server.dispatch-request(MCP::JSONRPC::Request.new(id => 9, method => 'prompts/list'));
    is $prompts<prompts>[0]<name>, 'greet', 'prompts/list includes prompt';

    my $prompt = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 10,
        method => 'prompts/get',
        params => { name => 'greet', arguments => { name => 'Raku' } }
    ));
    is $prompt<messages>[0]<content><text>, 'Hi Raku', 'prompts/get returns message';

    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 11,
            method => 'prompts/get',
            params => { }
        ));
    }, 'prompts/get requires name';

    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 12,
            method => 'prompts/get',
            params => { name => 'missing' }
        ));
    }, 'prompts/get unknown prompt';

    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 13,
            method => 'unknown/method'
        ));
    }, 'unknown method raises error';

    my $req-p = $server.request('ping');
    my $req = $transport.sent[0];
    $server.handle-response-public(MCP::JSONRPC::Response.success($req.id, { ok => True }));
    is (await $req-p)<ok>, True, 'server request resolves';

    $server.notify('notifications/message', { msg => 'hi' });
    $server.log(MCP::Types::Info, 'data', logger => 'test');
    $server.progress('token', 0.5e0, total => 1e0, message => 'half');
    ok $transport.sent.grep(MCP::JSONRPC::Notification).elems >= 3, 'notifications sent';

    $server.handle-message-public(MCP::JSONRPC::Notification.new(method => 'initialized'));
    $server.handle-message-public(MCP::JSONRPC::Notification.new(method => 'cancelled', params => { requestId => 1 }));
};

subtest 'Pagination support', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport,
        page-size => 2  # Small page size for testing
    );

    # Add 5 tools to test pagination
    for 1..5 -> $i {
        $server.add-tool(
            name => "tool$i",
            description => "Tool $i",
            handler => -> { "result$i" }
        );
    }

    # Test first page - should have 2 items and nextCursor
    my $page1 = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1,
        method => 'tools/list'
    ));
    is $page1<tools>.elems, 2, 'first page has 2 items';
    ok $page1<nextCursor>.defined, 'first page has nextCursor';

    # Test using cursor returns next page
    my $page2 = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 2,
        method => 'tools/list',
        params => { cursor => $page1<nextCursor> }
    ));
    is $page2<tools>.elems, 2, 'second page has 2 items';
    ok $page2<nextCursor>.defined, 'second page has nextCursor';

    # Ensure pages have different items
    my @page1-names = $page1<tools>.map(*<name>);
    my @page2-names = $page2<tools>.map(*<name>);
    ok @page1-names ne @page2-names, 'pages have different items';

    # Test last page has no nextCursor
    my $page3 = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 3,
        method => 'tools/list',
        params => { cursor => $page2<nextCursor> }
    ));
    is $page3<tools>.elems, 1, 'last page has 1 item';
    nok $page3<nextCursor>.defined, 'last page has no nextCursor';

    # Test invalid cursor returns InvalidParams error
    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 4,
            method => 'tools/list',
            params => { cursor => 'invalid-cursor' }
        ));
    }, 'invalid cursor raises error';

    # Test malformed base64 cursor
    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 5,
            method => 'tools/list',
            params => { cursor => '!!!' }
        ));
    }, 'malformed cursor raises error';

    # Test empty list returns no nextCursor
    my $empty-server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport,
        page-size => 2
    );
    my $empty-result = $empty-server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 6,
        method => 'tools/list'
    ));
    is $empty-result<tools>.elems, 0, 'empty list has 0 items';
    nok $empty-result<nextCursor>.defined, 'empty list has no nextCursor';

    # Test pagination for resources
    for 1..3 -> $i {
        $server.add-resource(
            uri => "info://res$i",
            name => "Resource $i",
            reader => { "content$i" }
        );
    }
    my $res-page1 = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 7,
        method => 'resources/list'
    ));
    is $res-page1<resources>.elems, 2, 'resources first page has 2 items';
    ok $res-page1<nextCursor>.defined, 'resources first page has nextCursor';

    # Test pagination for prompts
    for 1..3 -> $i {
        $server.add-prompt(
            name => "prompt$i",
            description => "Prompt $i",
            generator => { "message$i" }
        );
    }
    my $prompt-page1 = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 8,
        method => 'prompts/list'
    ));
    is $prompt-page1<prompts>.elems, 2, 'prompts first page has 2 items';
    ok $prompt-page1<nextCursor>.defined, 'prompts first page has nextCursor';
};

subtest 'Cancellation support', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    # Test is-cancelled returns False for unknown request
    nok $server.is-cancelled('unknown-id'), 'is-cancelled returns False for unknown request';

    # Test cancellation notification is handled
    # We need to simulate an in-flight request being cancelled
    # Since dispatch-request is synchronous for simple handlers, we test the notification handling

    # Test that notifications/cancelled is accepted (doesn't throw)
    lives-ok {
        $server.handle-message-public(MCP::JSONRPC::Notification.new(
            method => 'notifications/cancelled',
            params => { requestId => 'some-id', reason => 'test' }
        ));
    }, 'notifications/cancelled is handled without error';

    # Test cancel-request sends notification
    $transport.clear-sent;
    $server.cancel-request('req-123', reason => 'User cancelled');
    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'cancel-request sends notification';
    is @notifications[0].method, 'notifications/cancelled', 'notification method is correct';
    is @notifications[0].params<requestId>, 'req-123', 'notification has correct requestId';
    is @notifications[0].params<reason>, 'User cancelled', 'notification has correct reason';

    # Test cancel-request without reason
    $transport.clear-sent;
    $server.cancel-request('req-456');
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'cancel-request without reason sends notification';
    nok @notifications[0].params<reason>:exists, 'notification has no reason when not provided';

    # Test cancellation of in-flight request suppresses response
    # Use a Promise-based handler that we can control
    my $handler-promise = Promise.new;
    my $handler-vow = $handler-promise.vow;

    my $server2 = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv2', version => '0.1'),
        transport => $transport
    );
    $server2.add-tool(
        name => 'slow-tool',
        description => 'A slow tool for testing cancellation',
        handler => -> {
            await $handler-promise;  # Wait until we signal completion
            'completed'
        }
    );

    $transport.clear-sent;

    # Start request processing in background
    my $request-task = start {
        $server2.handle-message-public(MCP::JSONRPC::Request.new(
            id => 'cancel-test-1',
            method => 'tools/call',
            params => { name => 'slow-tool', arguments => {} }
        ));
    };

    # Give the handler time to start
    sleep 0.1;

    # Verify request is tracked as in-flight
    ok $server2.is-cancelled('cancel-test-1') === False, 'in-flight request is tracked';

    # Send cancellation while handler is running
    $server2.handle-message-public(MCP::JSONRPC::Notification.new(
        method => 'notifications/cancelled',
        params => { requestId => 'cancel-test-1', reason => 'test cancellation' }
    ));

    # Verify request is now marked as cancelled
    ok $server2.is-cancelled('cancel-test-1'), 'is-cancelled returns True after cancellation';

    # Complete the handler
    $handler-vow.keep(True);
    await $request-task;

    # Verify no response was sent (key behavior!)
    my @responses = $transport.sent.grep(MCP::JSONRPC::Response);
    is @responses.elems, 0, 'cancelled request does not send response';
};

subtest 'Protocol version handling', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    # Verify SUPPORTED_PROTOCOL_VERSIONS constant contains expected versions
    ok MCP::Types::LATEST_PROTOCOL_VERSION eq '2025-11-25', 'latest protocol version is 2025-11-25';
    ok '2025-11-25' ~~ any(MCP::Types::SUPPORTED_PROTOCOL_VERSIONS.list), 'SUPPORTED contains 2025-11-25';
    ok '2025-03-26' ~~ any(MCP::Types::SUPPORTED_PROTOCOL_VERSIONS.list), 'SUPPORTED contains 2025-03-26';
    ok '2024-11-05' ~~ any(MCP::Types::SUPPORTED_PROTOCOL_VERSIONS.list), 'SUPPORTED contains 2024-11-05';

    # Test client with latest protocol version
    my $init-latest = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1,
        method => 'initialize',
        params => { protocolVersion => '2025-11-25' }
    ));
    is $init-latest<protocolVersion>, MCP::Types::LATEST_PROTOCOL_VERSION,
        'server responds with latest version for 2025-11-25 client';

    # Test client with older supported version (2025-03-26)
    my $server2 = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv2', version => '0.1'),
        transport => $transport
    );
    my $init-older = $server2.dispatch-request(MCP::JSONRPC::Request.new(
        id => 2,
        method => 'initialize',
        params => { protocolVersion => '2025-03-26' }
    ));
    is $init-older<protocolVersion>, MCP::Types::LATEST_PROTOCOL_VERSION,
        'server responds with latest version for 2025-03-26 client';
    ok $init-older<capabilities>:exists, 'server includes capabilities for older client';

    # Test client with even older supported version (2024-11-05)
    my $server3 = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv3', version => '0.1'),
        transport => $transport
    );
    my $init-oldest = $server3.dispatch-request(MCP::JSONRPC::Request.new(
        id => 3,
        method => 'initialize',
        params => { protocolVersion => '2024-11-05' }
    ));
    is $init-oldest<protocolVersion>, MCP::Types::LATEST_PROTOCOL_VERSION,
        'server responds with latest version for 2024-11-05 client';
    ok $init-oldest<serverInfo>:exists, 'server includes serverInfo for older client';
    is $init-oldest<serverInfo><name>, 'srv3', 'serverInfo has correct name';
};

subtest 'Annotations in list responses', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    # Add tool with annotations
    $server.add-tool(
        MCP::Server::Tool::tool()
            .name('delete-file')
            .description('Delete a file')
            .annotations(destructiveHint => True, readOnlyHint => False, title => 'File Deleter')
            .handler(-> { 'deleted' })
            .build
    );

    # Add resource with annotations
    $server.add-resource(
        MCP::Server::Resource::resource()
            .uri('info://config')
            .name('Config')
            .description('Configuration')
            .annotations(['user', 'assistant'], priority => 0.8)
            .reader(-> { 'config data' })
            .build
    );

    # Verify tool annotations in tools/list response
    my $tools = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1,
        method => 'tools/list'
    ));
    ok $tools<tools>[0]<annotations>:exists, 'tool annotations in list response';
    is $tools<tools>[0]<annotations><title>, 'File Deleter', 'tool title annotation';
    ok $tools<tools>[0]<annotations><destructiveHint>, 'tool destructiveHint annotation';
    nok $tools<tools>[0]<annotations><readOnlyHint>, 'tool readOnlyHint annotation';

    # Verify resource annotations in resources/list response
    my $resources = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 2,
        method => 'resources/list'
    ));
    ok $resources<resources>[0]<annotations>:exists, 'resource annotations in list response';
    is $resources<resources>[0]<annotations><priority>, 0.8, 'resource priority annotation';
    is-deeply $resources<resources>[0]<annotations><audience>, ['user', 'assistant'], 'resource audience annotation';
};

subtest 'Resource subscriptions', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    # Add resources to subscribe to
    $server.add-resource(
        uri => 'file://test.txt',
        name => 'Test File',
        reader => { 'content' }
    );
    $server.add-resource(
        uri => 'file://other.txt',
        name => 'Other File',
        reader => { 'other content' }
    );

    # Verify capabilities include subscribe
    my $init = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 1,
        method => 'initialize',
        params => { protocolVersion => MCP::Types::LATEST_PROTOCOL_VERSION }
    ));
    ok $init<capabilities><resources><subscribe>, 'capabilities include subscribe';

    # Test subscribe to resource
    my $sub-result = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 2,
        method => 'resources/subscribe',
        params => { uri => 'file://test.txt' }
    ));
    is-deeply $sub-result, {}, 'subscribe returns empty response';

    # Verify resource is subscribed
    ok $server.is-subscribed('file://test.txt'), 'resource is marked as subscribed';
    nok $server.is-subscribed('file://other.txt'), 'other resource is not subscribed';

    # Test subscribe requires uri
    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 3,
            method => 'resources/subscribe',
            params => {}
        ));
    }, 'subscribe requires uri parameter';

    # Test subscribe to unknown resource
    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 4,
            method => 'resources/subscribe',
            params => { uri => 'file://nonexistent.txt' }
        ));
    }, 'subscribe to unknown resource fails';

    # Test notify-resource-updated sends notification for subscribed resource
    $transport.clear-sent;
    $server.notify-resource-updated('file://test.txt');
    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'notify-resource-updated sends notification';
    is @notifications[0].method, 'notifications/resources/updated', 'notification method is correct';
    is @notifications[0].params<uri>, 'file://test.txt', 'notification has correct uri';

    # Test notify-resource-updated does NOT send for unsubscribed resource
    $transport.clear-sent;
    $server.notify-resource-updated('file://other.txt');
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 0, 'no notification for unsubscribed resource';

    # Test unsubscribe
    my $unsub-result = $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 5,
        method => 'resources/unsubscribe',
        params => { uri => 'file://test.txt' }
    ));
    is-deeply $unsub-result, {}, 'unsubscribe returns empty response';
    nok $server.is-subscribed('file://test.txt'), 'resource is no longer subscribed';

    # Test notify-resource-updated after unsubscribe
    $transport.clear-sent;
    $server.notify-resource-updated('file://test.txt');
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 0, 'no notification after unsubscribe';

    # Test unsubscribe requires uri
    dies-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 6,
            method => 'resources/unsubscribe',
            params => {}
        ));
    }, 'unsubscribe requires uri parameter';

    # Test unsubscribe from unknown resource (should succeed silently)
    lives-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 7,
            method => 'resources/unsubscribe',
            params => { uri => 'file://never-subscribed.txt' }
        ));
    }, 'unsubscribe from unknown resource succeeds';

    # Test notify-resources-list-changed
    $transport.clear-sent;
    $server.notify-resources-list-changed();
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'notify-resources-list-changed sends notification';
    is @notifications[0].method, 'notifications/resources/list_changed', 'list changed notification method is correct';

    # Test multiple subscriptions
    $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 8,
        method => 'resources/subscribe',
        params => { uri => 'file://test.txt' }
    ));
    $server.dispatch-request(MCP::JSONRPC::Request.new(
        id => 9,
        method => 'resources/subscribe',
        params => { uri => 'file://other.txt' }
    ));
    ok $server.is-subscribed('file://test.txt'), 'first resource still subscribed';
    ok $server.is-subscribed('file://other.txt'), 'second resource now subscribed';

    # Test notifications sent only for subscribed resources when multiple subscribed
    $transport.clear-sent;
    $server.notify-resource-updated('file://test.txt');
    $server.notify-resource-updated('file://other.txt');
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 2, 'both subscribed resources get notifications';

    # Test idempotent subscribe (subscribing twice should succeed)
    lives-ok {
        $server.dispatch-request(MCP::JSONRPC::Request.new(
            id => 10,
            method => 'resources/subscribe',
            params => { uri => 'file://test.txt' }
        ));
    }, 'subscribing twice succeeds (idempotent)';
    ok $server.is-subscribed('file://test.txt'), 'still subscribed after double subscribe';

    # Test is-subscribed for completely unknown URI
    nok $server.is-subscribed('file://never-existed.txt'), 'is-subscribed returns false for unknown URI';

    # Test notify-resource-updated for unknown URI (should not send, not throw)
    $transport.clear-sent;
    lives-ok {
        $server.notify-resource-updated('file://unknown-resource.txt');
    }, 'notify-resource-updated for unknown URI does not throw';
    @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 0, 'no notification sent for unknown URI';
};

subtest 'Server list-roots', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'srv', version => '0.1'),
        transport => $transport
    );

    # Test list-roots sends request to client
    $transport.clear-sent;
    my $roots-promise = $server.list-roots;

    # Verify request was sent
    my @requests = $transport.sent.grep(MCP::JSONRPC::Request);
    is @requests.elems, 1, 'list-roots sends request';
    is @requests[0].method, 'roots/list', 'request method is roots/list';

    # Simulate client response
    $server.handle-response-public(MCP::JSONRPC::Response.success(@requests[0].id, {
        roots => [
            { uri => 'file:///project', name => 'Project' },
            { uri => 'file:///home' },
        ]
    }));

    # Verify promise resolves with Root objects
    my @roots = await $roots-promise;
    is @roots.elems, 2, 'list-roots returns 2 roots';
    isa-ok @roots[0], MCP::Types::Root, 'first item is Root';
    is @roots[0].uri, 'file:///project', 'first root uri correct';
    is @roots[0].name, 'Project', 'first root name correct';
    isa-ok @roots[1], MCP::Types::Root, 'second item is Root';
    is @roots[1].uri, 'file:///home', 'second root uri correct';

    # Test empty roots response
    $transport.clear-sent;
    my $empty-promise = $server.list-roots;
    @requests = $transport.sent.grep(MCP::JSONRPC::Request);
    $server.handle-response-public(MCP::JSONRPC::Response.success(@requests[0].id, {
        roots => []
    }));
    my @empty-roots = await $empty-promise;
    is @empty-roots.elems, 0, 'empty roots returns empty array';
};

subtest 'Server elicitation', {
    my $transport = TestTransport::TestTransport.new;
    my $server = Server.new(
        info => MCP::Types::Implementation.new(name => 'test', version => '0.1'),
        transport => $transport,
    );

    # Test elicit (form mode)
    $transport.clear-sent;
    my $elicit-promise = $server.elicit(
        message => 'Please enter your name',
        schema => {
            type => 'object',
            properties => {
                name => { type => 'string' }
            },
            required => ['name']
        }
    );

    # Verify request was sent
    my @requests = $transport.sent.grep(MCP::JSONRPC::Request);
    is @requests.elems, 1, 'elicit sends request';
    is @requests[0].method, 'elicitation/create', 'request method is elicitation/create';
    is @requests[0].params<mode>, 'form', 'mode is form';
    is @requests[0].params<message>, 'Please enter your name', 'message is correct';
    ok @requests[0].params<requestedSchema>:exists, 'requestedSchema exists';

    # Simulate client response
    $server.handle-response-public(MCP::JSONRPC::Response.success(@requests[0].id, {
        action => 'accept',
        content => { name => 'Alice' }
    }));

    my $response = await $elicit-promise;
    isa-ok $response, MCP::Types::ElicitationResponse, 'response is ElicitationResponse';
    is $response.action, MCP::Types::ElicitAccept, 'action is accept';
    is $response.content<name>, 'Alice', 'content has name';

    # Test elicit-url (URL mode)
    $transport.clear-sent;
    my $url-promise = $server.elicit-url(
        message => 'Please provide your API key',
        url => 'https://example.com/auth',
        elicitation-id => 'test-123'
    );

    @requests = $transport.sent.grep(MCP::JSONRPC::Request);
    is @requests.elems, 1, 'elicit-url sends request';
    is @requests[0].params<mode>, 'url', 'mode is url';
    is @requests[0].params<url>, 'https://example.com/auth', 'url is correct';
    is @requests[0].params<elicitationId>, 'test-123', 'elicitationId is correct';

    $server.handle-response-public(MCP::JSONRPC::Response.success(@requests[0].id, {
        action => 'accept'
    }));
    my $url-response = await $url-promise;
    is $url-response.action, MCP::Types::ElicitAccept, 'URL elicit returns accept';

    # Test notify-elicitation-complete
    $transport.clear-sent;
    $server.notify-elicitation-complete('test-123');
    my @notifications = $transport.sent.grep(MCP::JSONRPC::Notification);
    is @notifications.elems, 1, 'notification sent';
    is @notifications[0].method, 'notifications/elicitation/complete', 'notification method';
    is @notifications[0].params<elicitationId>, 'test-123', 'notification has elicitationId';
};

done-testing;
