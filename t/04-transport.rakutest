use v6.d;
use Test;
use lib 'lib';

use MCP::JSONRPC;
use MCP::Transport::Stdio;
use MCP::Transport::Base;
use MCP::Transport::StreamableHTTP;
use JSON::Fast;

use MONKEY-TYPING;
augment class MCP::Transport::Stdio::StdioTransport {
    method parse-public(Str $buffer) { self!parse-message($buffer) }
}
use JSON::Fast;

=begin pod
=head1 NAME

04-transport.rakutest - Tests for stdio transport

=head1 DESCRIPTION

Exercises stdio framing and basic transport state handling.

=end pod

subtest 'StdioTransport parse/send/close', {
    $*TMPDIR.mkdir unless $*TMPDIR.e;
    my $json = to-json({
        jsonrpc => '2.0',
        id => 1,
        method => 'ping',
    });
    my $length = $json.encode('utf-8').elems;
    my $payload = "Content-Length: $length\r\n\r\n$json";

    my $out-path = $*TMPDIR.add("mcp-stdio-out-$*PID.txt");
    my $out = $out-path.open(:w);
    my $transport = MCP::Transport::Stdio::StdioTransport.new(
        input => $*IN,
        output => $out
    );

    my ($msg, $rest) = $transport.parse-public($payload);
    isa-ok $msg, MCP::JSONRPC::Request, 'parsed request';
    is $msg.method, 'ping', 'method parsed';
    is $rest, '', 'no remaining buffer';

    my $resp = MCP::JSONRPC::Response.success(1, { ok => True });
    await $transport.send($resp);
    $out.close;

    my $out-text = $out-path.slurp;
    ok $out-text.contains('Content-Length:'), 'output includes content length';
    ok $out-text.contains('"result"'), 'output includes result';

    ok !$transport.is-connected, 'not connected before start';
    my $s = $transport.start;
    ok $transport.is-connected, 'connected after start';
    await $transport.close;
    ok !$transport.is-connected, 'not connected after close';
};

subtest 'StdioTransport ignores invalid JSON', {
    my $json = '{not-json}';
    my $length = $json.encode('utf-8').elems;
    my $payload = "Content-Length: $length\r\n\r\n$json";

    my $transport = MCP::Transport::Stdio::StdioTransport.new(
        input => $*IN,
        output => $*OUT
    );

    my ($msg, $rest) = $transport.parse-public($payload);
    ok !$msg.defined, 'invalid JSON not emitted';
    ok $rest.chars >= 0, 'rest returned';
};

subtest 'Transport error types', {
    my $err = MCP::Transport::Base::X::Transport.new(message => 'oops');
    is $err.message, 'oops', 'base transport message';

    my $conn = MCP::Transport::Base::X::Transport::Connection.new(message => 'nope');
    ok $conn.message.contains('Connection error'), 'connection error prefix';

    my $send = MCP::Transport::Base::X::Transport::Send.new(message => 'nope');
    ok $send.message.contains('Send error'), 'send error prefix';

    # cause property
    my $with-cause = MCP::Transport::Base::X::Transport.new(message => 'fail', cause => 'root');
    is $with-cause.cause, 'root', 'cause property set';

    # Exception hierarchy
    ok $conn ~~ MCP::Transport::Base::X::Transport, 'Connection is-a Transport error';
    ok $send ~~ MCP::Transport::Base::X::Transport, 'Send is-a Transport error';
    ok $conn ~~ Exception, 'Connection is-a Exception';
};


subtest 'StreamableHTTP Stream emit and replay', {
    my $supplier = Supplier.new;
    my @received;
    $supplier.Supply.tap(-> $v { @received.push($v) });

    my $stream = MCP::Transport::StreamableHTTP::Stream.new(
        id => 'test-stream',
        supplier => $supplier,
        history-size => 5,
    );

    # Emit priming event
    my $prime-id = $stream.emit-priming;
    ok $prime-id.starts-with('test-stream:'), 'priming event ID has stream prefix';
    ok @received[0].contains('data:'), 'priming event has data line';

    # Emit message
    my $msg-id = $stream.emit-message('{"jsonrpc":"2.0","method":"ping"}');
    ok $msg-id.starts-with('test-stream:'), 'message event ID has stream prefix';
    ok @received[1].contains('data:'), 'message has data lines';
    ok @received[1].contains('"ping"'), 'message contains JSON payload';
    ok @received[1].contains("id: $msg-id"), 'message contains event ID';

    # Emit several messages to test history truncation
    for ^6 -> $i { $stream.emit-message('{"n":' ~ $i ~ '}') }
    pass 'history truncation did not error';
};

subtest 'StreamableHTTP Stream replay', {
    my $supplier = Supplier.new;
    my @received;
    $supplier.Supply.tap(-> $v { @received.push($v) });

    my $stream = MCP::Transport::StreamableHTTP::Stream.new(
        id => 'replay-test',
        supplier => $supplier,
    );

    # Emit 3 messages
    $stream.emit-priming;
    $stream.emit-message('{"a":1}');
    $stream.emit-message('{"a":2}');

    @received = [];
    $stream.replay-from(1);
    ok @received.elems >= 1, 'replay emitted events after given seq';
};

subtest 'StreamableHTTP exception classes', {
    my $base = X::MCP::Transport::StreamableHTTP.new(message => 'generic');
    is $base.message, 'generic', 'base message';

    my $proto = X::MCP::Transport::StreamableHTTP::Protocol.new(message => 'bad version');
    ok $proto.message.contains('Protocol error'), 'Protocol prefix';

    my $http = X::MCP::Transport::StreamableHTTP::HTTP.new(message => '404');
    ok $http.message.contains('HTTP error'), 'HTTP prefix';
};

done-testing;
