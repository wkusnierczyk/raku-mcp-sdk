use v6.d;
use Test;
use lib 'lib';
use lib 't/lib';
use JSON::Fast;
use MCP::Types;

need TestTransport;
need MCP::JSONRPC;
need MCP::Client;
use MCP::OAuth;
need MCP::OAuth::Client;

my &parse-message = &MCP::JSONRPC::EXPORT::DEFAULT::parse-message;
sub j(%h) { $(from-json(to-json(%h))) }

# =============================================================================
# Types: content .type() methods
# =============================================================================

subtest 'Content type() methods', {
    is TextContent.new(text => 'a').type, 'text', 'TextContent.type';
    is ImageContent.new(data => 'x', mimeType => 'image/png').type, 'image', 'ImageContent.type';
    is AudioContent.new(data => 'y', mimeType => 'audio/wav').type, 'audio', 'AudioContent.type';
    is EmbeddedResource.new(resource => ResourceContents.new(uri => 'x')).type, 'resource', 'EmbeddedResource.type';
    is ResourceLink.new(name => 'a', uri => 'b').type, 'resource_link', 'ResourceLink.type';
    is ToolUseContent.new(id => '1', name => 't', input => %()).type, 'tool_use', 'ToolUseContent.type';
    is ToolResultContent.new(toolUseId => '1').type, 'tool_result', 'ToolResultContent.type';
};

# =============================================================================
# Types: optional fields that are uncovered
# =============================================================================

subtest 'ToolUseContent Hash', {
    my $tu = ToolUseContent.new(id => 'u1', name => 'calc', input => %( a => 1 ));
    my %h = $tu.Hash;
    is %h<type>, 'tool_use', 'type';
    is %h<id>, 'u1', 'id';
    is %h<name>, 'calc', 'name';
    ok %h<input><a> == 1, 'input';
};

subtest 'ToolResultContent Hash with all fields', {
    my $inner = TextContent.new(text => 'ok');
    my $tr = ToolResultContent.new(
        toolUseId => 'u1',
        content => [$inner],
        isError => True,
        structuredContent => %( key => 'val' ),
        meta => %( req => 'x' ),
    );
    my %h = $tr.Hash;
    is %h<type>, 'tool_result', 'type';
    is %h<toolUseId>, 'u1', 'toolUseId';
    ok %h<isError>, 'isError';
    ok %h<structuredContent><key> eq 'val', 'structuredContent';
    ok %h<_meta><req> eq 'x', 'meta';
};

subtest 'ResourceLink with size', {
    my $rl = ResourceLink.new(name => 'doc', uri => 'file:///x', size => 42);
    my %h = $rl.Hash;
    is %h<size>, 42, 'size in Hash';
};

subtest 'ToolAnnotations openWorldHint', {
    my $ta = ToolAnnotations.new(openWorldHint => True);
    ok $ta.Hash<openWorldHint>, 'openWorldHint';
};

subtest 'PromptArgument required', {
    my $pa = PromptArgument.new(name => 'topic', description => 'The topic', required => True);
    my %h = $pa.Hash;
    ok %h<required>, 'required field';
    is %h<description>, 'The topic', 'description';
};

subtest 'Prompt with arguments and icons', {
    my $icon = IconDefinition.new(src => 'https://x/icon.png');
    my $arg = PromptArgument.new(name => 'q', required => True);
    my $p = Prompt.new(name => 'search', title => 'Search', arguments => [$arg], icons => [$icon]);
    my %h = $p.Hash;
    ok %h<arguments>.elems == 1, 'arguments';
    ok %h<icons>.elems == 1, 'icons';
    is %h<title>, 'Search', 'title';

    # from-hash with arguments
    my $p2 = Prompt.from-hash(%(
        name => 'search',
        title => 'Search',
        arguments => [j(%( name => 'q', required => True ))],
        icons => [j(%( src => 'https://x/icon.png' ))],
    ));
    is $p2.arguments[0].name, 'q', 'from-hash arguments';
    ok $p2.arguments[0].required, 'from-hash argument required';
};

subtest 'IconDefinition with sizes', {
    my $icon = IconDefinition.new(src => 'https://x/icon.png', sizes => ['16x16', '32x32']);
    ok $icon.sizes.elems == 2, 'sizes';
};

subtest 'Implementation with icons', {
    my $icon = IconDefinition.new(src => 'https://x/icon.png');
    my $impl = Implementation.new(name => 'test', version => '1.0', icons => [$icon]);
    ok $impl.icons.elems == 1, 'impl icons';
};

subtest 'TaskExecution enum coverage', {
    # All TaskSupport values
    for <forbidden optional required> -> $v {
        my $te = TaskExecution.from-hash(%( taskSupport => $v ));
        is $te.Hash<taskSupport>, $v, "TaskExecution $v";
    }
    # Default fallback
    my $te = TaskExecution.from-hash(%( taskSupport => 'unknown' ));
    is $te.Hash<taskSupport>, 'optional', 'TaskExecution default';
};

subtest 'Task with all fields and from-hash', {
    for <working input_required completed failed cancelled> -> $s {
        my $t = Task.from-hash(%( taskId => 'tid', status => $s ));
        is $t.Hash<status>, $s, "Task status $s";
    }
    # Default fallback
    my $t = Task.from-hash(%( taskId => 'tid', status => 'bogus' ));
    is $t.Hash<status>, 'working', 'Task default status';

    # All optional fields
    my $t2 = Task.new(
        taskId => 'tid', status => TaskWorking,
        statusMessage => 'progress', createdAt => '2024-01-01',
        lastUpdatedAt => '2024-01-02', ttl => 5000, pollInterval => 1000,
    );
    my %h = $t2.Hash;
    is %h<statusMessage>, 'progress', 'statusMessage';
    is %h<pollInterval>, 1000, 'pollInterval';
    is %h<ttl>, 5000, 'ttl';
    is %h<createdAt>, '2024-01-01', 'createdAt';
    is %h<lastUpdatedAt>, '2024-01-02', 'lastUpdatedAt';

    # from-hash with optionals
    my $t3 = Task.from-hash(%(
        taskId => 'x', status => 'working',
        statusMessage => 'hi', createdAt => 'c', lastUpdatedAt => 'u',
        ttl => 3000, pollInterval => 500,
    ));
    is $t3.pollInterval, 500, 'from-hash pollInterval';
    is $t3.ttl, 3000, 'from-hash ttl';
};

subtest 'CreateTaskResult Hash', {
    my $task = Task.new(taskId => 'tid', status => TaskWorking);
    my $ctr = CreateTaskResult.new(task => $task);
    my %h = $ctr.Hash;
    ok %h<task><taskId> eq 'tid', 'task hash';
};

subtest 'Tool with execution and all fields', {
    my $te = TaskExecution.new(taskSupport => TaskOptional);
    my $ta = ToolAnnotations.new(title => 'T', readOnlyHint => True);
    my $icon = IconDefinition.new(src => 'https://x/icon.png');
    my $tool = Tool.new(
        name => 'calc', description => 'Calculate',
        title => 'Calculator', icons => [$icon],
        inputSchema => %( type => 'object' ),
        outputSchema => %( type => 'number' ),
        annotations => $ta, execution => $te,
    );
    my %h = $tool.Hash;
    ok %h<execution><taskSupport> eq 'optional', 'execution in Hash';
    ok %h<outputSchema><type> eq 'number', 'outputSchema in Hash';
    ok %h<icons>.elems == 1, 'icons in Hash';

    # from-hash with execution
    my $t2 = Tool.from-hash(%(
        name => 'calc',
        execution => j(%( taskSupport => 'required' )),
        outputSchema => j(%( type => 'number' )),
        icons => [j(%( src => 'https://x/icon.png' ))],
    ));
    is $t2.execution.Hash<taskSupport>, 'required', 'from-hash execution';
};

subtest 'ModelHint and ModelPreferences', {
    my $hint = ModelHint.new(name => 'claude-3');
    is $hint.Hash<name>, 'claude-3', 'ModelHint name';

    my $prefs = ModelPreferences.new(
        hints => [$hint],
        costPriority => 0.3e0,
        speedPriority => 0.5e0,
        intelligencePriority => 0.9e0,
    );
    my %h = $prefs.Hash;
    ok %h<intelligencePriority> == 0.9, 'intelligencePriority';
    ok %h<hints>.elems == 1, 'hints';
};

subtest 'ToolChoice with name', {
    my $tc = ToolChoice.new(mode => 'tool', name => 'calc');
    my %h = $tc.Hash;
    is %h<name>, 'calc', 'ToolChoice name';
};

subtest 'CreateMessageResult with meta', {
    my $r = CreateMessageResult.new(
        content => TextContent.new(text => 'hi'),
        model => 'm', role => 'assistant',
        stopReason => 'endTurn', meta => %( id => 'x' ),
    );
    my %h = $r.Hash;
    ok %h<_meta><id> eq 'x', 'meta in Hash';
};

subtest 'CompletionResult with hasMore', {
    my $cr = CompletionResult.new(values => <a b>, total => 5, hasMore => True);
    my %h = $cr.Hash;
    ok %h<hasMore>, 'hasMore in Hash';
    is %h<total>, 5, 'total';

    my $cr2 = CompletionResult.from-hash(%( values => ['a'], total => 10, hasMore => True ));
    ok $cr2.hasMore, 'from-hash hasMore';
};

subtest 'Extension with settings', {
    my $ext = Extension.new(name => 'test', version => '1.0', settings => %( key => 'val' ));
    my %h = $ext.Hash;
    ok %h<settings><key> eq 'val', 'settings';

    my $ext2 = Extension.from-hash(%( name => 'test', version => '1.0', settings => %( k => 'v' ) ));
    ok $ext2.settings<k> eq 'v', 'from-hash settings';
};

subtest 'Root with name', {
    my $r = Root.new(uri => 'file:///x', name => 'project');
    is $r.Hash<name>, 'project', 'Root name';
    my $r2 = Root.from-hash(%( uri => 'file:///x', name => 'n' ));
    is $r2.name, 'n', 'from-hash name';
};

subtest 'ElicitationCapability', {
    my $ec = ElicitationCapability.new(form => True, url => True);
    ok $ec.supports-form, 'form';
    ok $ec.supports-url, 'url';
    my %h = $ec.Hash;
    ok %h<url>:exists, 'url in Hash';

    my $ec2 = ElicitationCapability.from-hash(%( form => %() ));
    ok $ec2.supports-form, 'from-hash form';
    nok $ec2.supports-url, 'from-hash no url';

    my $ec3 = ElicitationCapability.from-hash(%());
    ok $ec3.supports-form, 'empty hash = form';
};

subtest 'ElicitationResponse variants', {
    my $accept = ElicitationResponse.new(action => ElicitAccept, content => %( name => 'val' ));
    my %ah = $accept.Hash;
    is %ah<action>, 'accept', 'accept action';
    ok %ah<content><name> eq 'val', 'accept content';

    my $decline = ElicitationResponse.new(action => ElicitDecline);
    is $decline.Hash<action>, 'decline', 'decline';
    nok $decline.Hash<content>:exists, 'no content for decline';

    my $cancel = ElicitationResponse.new(action => ElicitCancel);
    is $cancel.Hash<action>, 'cancel', 'cancel';

    # from-hash
    my $fr = ElicitationResponse.from-hash(%( action => 'decline' ));
    is $fr.action, ElicitDecline, 'from-hash decline';

    my $fr2 = ElicitationResponse.from-hash(%( action => 'bogus' ));
    is $fr2.action, ElicitCancel, 'from-hash default cancel';
};

subtest 'ClientCapabilities Hash', {
    my $caps = ClientCapabilities.new(
        experimental => %( 'test/ext' => True ),
        roots => RootsCapability.new(listChanged => True),
        sampling => SamplingCapability.new(tools => True, context => True),
        elicitation => ElicitationCapability.new(form => True, url => True),
        tasks => %( supported => True ),
    );
    my %h = $caps.Hash;
    ok %h<experimental>:exists, 'experimental';
    ok %h<roots><listChanged>, 'roots';
    ok %h<sampling><tools>:exists, 'sampling tools';
    ok %h<sampling><context>:exists, 'sampling context';
    ok %h<elicitation><url>:exists, 'elicitation url';
    ok %h<tasks><supported>, 'tasks';
};

subtest 'Progress with message', {
    my $p = Progress.new(progressToken => 'tok1', progress => 0.5e0, total => 1.0e0, message => 'Half done');
    my %h = $p.Hash;
    is %h<message>, 'Half done', 'message';
    ok %h<total> == 1.0, 'total';
};

subtest 'LogLevel and log-level-at-or-above', {
    ok log-level-at-or-above(Error, Warning), 'Error >= Warning';
    nok log-level-at-or-above(Debug, Error), 'Debug < Error';
    ok log-level-at-or-above(Emergency, Emergency), 'same level';
};

subtest 'parse-log-level', {
    is parse-log-level('debug'), Debug, 'parse debug';
    is parse-log-level('emergency'), Emergency, 'parse emergency';
    dies-ok { parse-log-level('bogus') }, 'invalid level dies';
};

subtest 'LogEntry with logger and data', {
    my $le = LogEntry.new(level => Info, logger => 'app', data => 'msg');
    my %h = $le.Hash;
    is %h<logger>, 'app', 'logger';
    is %h<data>, 'msg', 'data';
    is %h<level>, 'info', 'level';
};

subtest 'ResourceContents with blob', {
    my $rc = ResourceContents.new(uri => 'file:///x', blob => Buf.new(1,2,3));
    ok $rc.blob.elems == 3, 'blob field';
};

subtest 'Resource with annotations and icons', {
    my $ann = Annotations.new(audience => ['user'], priority => 0.8e0);
    my $icon = IconDefinition.new(src => 'https://x/icon.png');
    my $r = Resource.new(uri => 'x', name => 'r', annotations => $ann, icons => [$icon]);
    my %h = $r.Hash;
    ok %h<annotations><priority> == 0.8, 'annotations';
    ok %h<icons>.elems == 1, 'icons';
};

subtest 'ResourceTemplate with annotations and icons', {
    my $ann = Annotations.new(audience => ['assistant']);
    my $icon = IconDefinition.new(src => 'https://x/icon.png');
    my $rt = ResourceTemplate.new(
        uriTemplate => 'file:///{path}', name => 't',
        title => 'T', annotations => $ann, icons => [$icon],
    );
    my %h = $rt.Hash;
    ok %h<annotations><audience>.elems == 1, 'annotations';
    ok %h<icons>.elems == 1, 'icons';
    is %h<title>, 'T', 'title';
};

# =============================================================================
# Client: parse-content for all types, elicitation handler, await-task, timeout
# =============================================================================

subtest 'Client call-tool parses all content types', {
    my $transport = TestTransport::TestTransport.new;
    my $client = MCP::Client::Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        :$transport,
    );
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => %(),
        instructions => '',
    )));
    await $connect;

    $transport.clear-sent;
    my $p = $client.call-tool('t', arguments => %());
    $transport.await-sent;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        content => [
            j(%( type => 'text', text => 'hi' )),
            j(%( type => 'image', data => 'abc', mimeType => 'image/png' )),
            j(%( type => 'audio', data => 'xyz', mimeType => 'audio/wav' )),
            j(%( type => 'resource', resource => j(%( uri => 'x', mimeType => 'text/plain', text => 'rc' )) )),
            j(%( type => 'resource_link', name => 'rl', uri => 'y', title => 't', description => 'd', mimeType => 'text/plain', size => 100 )),
            j(%( type => 'tool_use', id => 'tu1', name => 'calc', input => j(%( a => 1 )) )),
            j(%( type => 'tool_result', toolUseId => 'tu1', content => [j(%( type => 'text', text => 'ok' ))], isError => False )),
            j(%( type => 'unknown_type' )),
        ],
        isError => False,
    )));
    my $result = await $p;
    is $result.content.elems, 8, '8 content items';
    ok $result.content[0] ~~ TextContent, 'text';
    ok $result.content[1] ~~ ImageContent, 'image';
    ok $result.content[2] ~~ AudioContent, 'audio';
    ok $result.content[3] ~~ EmbeddedResource, 'resource';
    ok $result.content[4] ~~ ResourceLink, 'resource_link';
    ok $result.content[5] ~~ ToolUseContent, 'tool_use';
    ok $result.content[6] ~~ ToolResultContent, 'tool_result';
    ok $result.content[7] ~~ TextContent, 'default fallback';
};

subtest 'Client get-prompt parses messages', {
    my $transport = TestTransport::TestTransport.new;
    my $client = MCP::Client::Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        :$transport,
    );
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => %(),
        instructions => '',
    )));
    await $connect;

    $transport.clear-sent;
    my $p = $client.get-prompt('test');
    $transport.await-sent;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        description => 'A prompt',
        messages => [j(%( role => 'user', content => j(%( type => 'text', text => 'hello' )) ))],
    )));
    my $result = await $p;
    is $result<description>, 'A prompt', 'description';
    is $result<messages>.elems, 1, 'messages';
};

subtest 'Client elicitation handler', {
    my $transport = TestTransport::TestTransport.new;
    my $client = MCP::Client::Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        :$transport,
        elicitation-handler => -> %params {
            ElicitationResponse.new(action => ElicitAccept, content => %( name => 'val' ))
        },
    );
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => %(),
        instructions => '',
    )));
    await $connect;

    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 200,
        method => 'elicitation/create',
        params => %( mode => 'form', message => 'Enter name', requestedSchema => %() ),
    ));
    sleep 0.3;
    my @resps = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @resps.elems >= 1, 'elicitation response sent';
    ok @resps[0].result.defined, 'result defined';
    is @resps[0].result<action>, 'accept', 'accept action';
};

subtest 'Client elicitation URL mode rejected', {
    my $transport = TestTransport::TestTransport.new;
    my $client = MCP::Client::Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        :$transport,
        elicitation-handler => -> %params { %( action => 'cancel' ) },
    );
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => %(),
        instructions => '',
    )));
    await $connect;

    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 201,
        method => 'elicitation/create',
        params => %( mode => 'url' ),
    ));
    sleep 0.3;
    my @resps = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @resps.elems >= 1, 'response sent';
    ok @resps[0].error.defined, 'URL mode rejected';
};

subtest 'Client elicitation no handler', {
    my $transport = TestTransport::TestTransport.new;
    my $client = MCP::Client::Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        :$transport,
    );
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => %(),
        instructions => '',
    )));
    await $connect;

    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 202,
        method => 'elicitation/create',
        params => %( mode => 'form' ),
    ));
    sleep 0.3;
    my @resps = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @resps.elems >= 1, 'response sent';
    ok @resps[0].error.defined, 'no handler error';
};

subtest 'Client elicitation coerce hash result', {
    my $transport = TestTransport::TestTransport.new;
    my $client = MCP::Client::Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        :$transport,
        elicitation-handler => -> %params { %( action => 'decline' ) },
    );
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => %(),
        instructions => '',
    )));
    await $connect;

    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 203,
        method => 'elicitation/create',
        params => %( mode => 'form' ),
    ));
    sleep 0.3;
    my @resps = $transport.sent.grep(MCP::JSONRPC::Response);
    ok @resps[0].result<action> eq 'decline', 'hash result coerced';
};

subtest 'Client elicitation coerce unknown result to cancel', {
    my $transport = TestTransport::TestTransport.new;
    my $client = MCP::Client::Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        :$transport,
        elicitation-handler => -> %params { 'nonsense' },
    );
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => %(),
        instructions => '',
    )));
    await $connect;

    $transport.clear-sent;
    $transport.emit(MCP::JSONRPC::Request.new(
        id => 204,
        method => 'elicitation/create',
        params => %( mode => 'form' ),
    ));
    sleep 0.3;
    my @resps = $transport.sent.grep(MCP::JSONRPC::Response);
    is @resps[0].result<action>, 'cancel', 'unknown result â†’ cancel';
};

subtest 'Client server-capabilities and server-instructions', {
    my $transport = TestTransport::TestTransport.new;
    my $client = MCP::Client::Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        :$transport,
    );
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => %( tools => %( listChanged => True ) ),
        instructions => 'Be helpful',
    )));
    await $connect;

    ok $client.server-capabilities.defined, 'server-capabilities';
    is $client.server-instructions, 'Be helpful', 'server-instructions';
};

subtest 'Client call-tool-as-task', {
    my $transport = TestTransport::TestTransport.new;
    my $client = MCP::Client::Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        :$transport,
    );
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => %(),
        instructions => '',
    )));
    await $connect;

    $transport.clear-sent;
    my $p = $client.call-tool-as-task('calc');
    $transport.await-sent;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        task => j(%( taskId => 't1', status => 'working' )),
    )));
    my $task = await $p;
    is $task.taskId, 't1', 'taskId';
};

subtest 'Client get-task and cancel-task', {
    my $transport = TestTransport::TestTransport.new;
    my $client = MCP::Client::Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        :$transport,
    );
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => %(),
        instructions => '',
    )));
    await $connect;

    # get-task
    $transport.clear-sent;
    my $p = $client.get-task('t1');
    $transport.await-sent;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        taskId => 't1', status => 'completed',
    )));
    my $task = await $p;
    ok $task.is-terminal, 'completed is terminal';

    # cancel-task
    $transport.clear-sent;
    my $p2 = $client.cancel-task('t1');
    $transport.await-sent;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        taskId => 't1', status => 'cancelled',
    )));
    my $t2 = await $p2;
    ok $t2.is-terminal, 'cancelled is terminal';
};

subtest 'Client set-log-level', {
    my $transport = TestTransport::TestTransport.new;
    my $client = MCP::Client::Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        :$transport,
    );
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => %(),
        instructions => '',
    )));
    await $connect;

    $transport.clear-sent;
    my $p = $client.set-log-level(Warning);
    $transport.await-sent;
    my $req = $transport.sent[0];
    is $req.method, 'logging/setLevel', 'method';
    $transport.emit(MCP::JSONRPC::Response.success($req.id, %()));
    await $p;
    pass 'set-log-level completes';
};

subtest 'Client set-roots', {
    my $transport = TestTransport::TestTransport.new;
    my $client = MCP::Client::Client.new(
        info => Implementation.new(name => 'cli', version => '0.1'),
        :$transport,
        roots => [Root.new(uri => 'file:///a')],
    );
    my $connect = $client.connect;
    $transport.await-sent-and-settle;
    $transport.emit(MCP::JSONRPC::Response.success($transport.sent[0].id, %(
        protocolVersion => LATEST_PROTOCOL_VERSION,
        capabilities => %(),
        instructions => '',
    )));
    await $connect;

    $transport.clear-sent;
    $client.set-roots([Root.new(uri => 'file:///b', name => 'B')]);
    sleep 0.1;
    my @notifs = $transport.sent.grep(MCP::JSONRPC::Notification);
    ok @notifs.elems >= 1, 'notification sent';
    is @notifs[0].method, 'notifications/roots/list_changed', 'roots changed notification';

    my @roots = $client.get-roots;
    is @roots[0].uri, 'file:///b', 'roots updated';
};

# =============================================================================
# OAuth: exception messages, Hash methods, PKCE
# =============================================================================

subtest 'OAuth exception messages', {
    my $e1 = X::MCP::OAuth::Unauthorized.new(message => 'No token');
    is $e1.message, 'No token', 'Unauthorized message';

    my $e2 = X::MCP::OAuth::Forbidden.new(message => 'No scope', scopes => ['read']);
    ok $e2.scopes.elems == 1, 'Forbidden scopes';

    my $e3 = X::MCP::OAuth::Discovery.new(message => 'Not found');
    is $e3.message, 'Not found', 'Discovery message';

    my $e4 = X::MCP::OAuth::Registration.new(
        message => 'Failed', error => 'invalid_client', error-description => 'Bad client',
    );
    ok $e4.message.contains('Failed'), 'Registration message';

    my $e5 = X::MCP::OAuth::TokenExchange.new(
        message => 'Failed', error => 'bad_grant', error-description => 'Bad grant',
    );
    ok $e5.message.contains('Failed'), 'TokenExchange message';
};

subtest 'TokenResponse is-expired', {
    my $tr = TokenResponse.new(access-token => 'tok', expires-in => 3600);
    nok $tr.is-expired, 'not expired';

    my $tr2 = TokenResponse.new(access-token => 'tok', expires-in => 0);
    ok $tr2.is-expired, 'expired';

    my $tr3 = TokenResponse.new(access-token => 'tok');
    nok $tr3.is-expired, 'no expires-in = not expired';
};

subtest 'TokenExchangeResponse from-hash', {
    my $ter = TokenExchangeResponse.from-hash(%(
        issued_token_type => 'urn:ietf:params:oauth:token-type:id-jag',
        access_token => 'jag-tok',
        token_type => 'N_A',
        scope => 'read',
        expires_in => 300,
    ));
    is $ter.access-token, 'jag-tok', 'access-token';
    is $ter.scope, 'read', 'scope';
    is $ter.expires-in, 300, 'expires-in';
};

subtest 'ClientRegistrationRequest Hash', {
    my $req = ClientRegistrationRequest.new(
        redirect-uris => ['http://localhost/cb'],
        grant-types => ['authorization_code'],
        response-types => ['code'],
        token-endpoint-auth-method => 'none',
        software-version => '1.0',
    );
    my %h = $req.Hash;
    ok %h<redirect_uris>.elems == 1, 'redirect_uris';
    is %h<software_version>, '1.0', 'software_version';
};

subtest 'ClientRegistrationResponse Hash', {
    my $resp = ClientRegistrationResponse.new(
        client-id => 'cid', client-secret => 'sec', scope => 'read write',
    );
    my %h = $resp.Hash;
    is %h<client_id>, 'cid', 'client_id';
    is %h<client_secret>, 'sec', 'client_secret';
    is %h<scope>, 'read write', 'scope';
};

subtest 'AuthServerMetadata with all fields Hash', {
    my $asm = AuthServerMetadata.new(
        issuer => 'https://auth.example.com',
        authorization-endpoint => 'https://auth.example.com/auth',
        token-endpoint => 'https://auth.example.com/token',
        registration-endpoint => 'https://auth.example.com/register',
        grant-types-supported => ['authorization_code'],
        response-types-supported => ['code'],
        scopes-supported => ['read', 'write'],
        code-challenge-methods-supported => ['S256'],
    );
    my %h = $asm.Hash;
    ok %h<code_challenge_methods_supported>.elems == 1, 'code challenge methods';
    ok %h<scopes_supported>.elems == 2, 'scopes supported';
};

subtest 'ProtectedResourceMetadata with scopes', {
    my $prm = ProtectedResourceMetadata.new(
        resource => 'https://mcp.example.com',
        authorization-servers => ['https://auth.example.com'],
        scopes-supported => ['read', 'write'],
    );
    my %h = $prm.Hash;
    ok %h<scopes_supported>.elems == 2, 'scopes_supported';
};

# =============================================================================
# OAuth Client: construction and authorization-url (no HTTP needed)
# =============================================================================

subtest 'OAuthClientHandler authorization-url', {
    my $handler = MCP::OAuth::Client::OAuthClientHandler.new(
        resource-url => 'https://mcp.example.com',
        client-id => 'my-app',
        redirect-uri => 'http://localhost:8080/callback',
        scopes => ['read', 'write'],
        authorization-callback => -> $url { 'auth-code-123' },
    );

    # Set auth-metadata so authorization-url works without discover()
    $handler.auth-metadata = AuthServerMetadata.new(
        issuer => 'https://auth.example.com',
        authorization-endpoint => 'https://auth.example.com/authorize',
        token-endpoint => 'https://auth.example.com/token',
    );

    my $url = $handler.authorization-url;
    ok $url.starts-with('https://auth.example.com/authorize?'), 'starts with auth endpoint';
    ok $url.contains('response_type=code'), 'response_type';
    ok $url.contains('client_id=my-app'), 'client_id';
    ok $url.contains('code_challenge_method=S256'), 'S256';
    ok $url.contains('scope=read%20write'), 'scope';
    ok $handler.pkce-verifier.defined, 'pkce-verifier set';
};

subtest 'OAuthClientHandler authorization-url without discover dies', {
    my $handler = MCP::OAuth::Client::OAuthClientHandler.new(
        resource-url => 'https://mcp.example.com',
        client-id => 'my-app',
        authorization-callback => -> $url { 'code' },
    );
    dies-ok { $handler.authorization-url }, 'dies without discover';
};

subtest 'OAuthClientHandler refresh without token dies', {
    my $handler = MCP::OAuth::Client::OAuthClientHandler.new(
        resource-url => 'https://mcp.example.com',
        client-id => 'my-app',
        authorization-callback => -> $url { 'code' },
    );
    my $p = $handler.refresh;
    dies-ok { await $p }, 'refresh without token dies';
};

subtest 'OAuthM2MClient request-token without discover dies', {
    my $client = MCP::OAuth::Client::OAuthM2MClient.new(
        resource-url => 'https://mcp.example.com',
        client-id => 'my-app',
        client-secret => 'sec',
    );
    my $p = $client.request-token;
    dies-ok { await $p }, 'request-token without discover dies';
};

subtest 'OAuthEnterpriseClient exchange-token without subject dies', {
    my $client = MCP::OAuth::Client::OAuthEnterpriseClient.new(
        resource-url => 'https://mcp.example.com',
        client-id => 'app',
        idp-token-endpoint => 'https://idp.example.com/token',
        idp-client-id => 'idp-app',
    );
    my $p = $client.exchange-token;
    dies-ok { await $p }, 'exchange-token without subject dies';
};

subtest 'OAuthEnterpriseClient exchange-token without discover dies', {
    my $client = MCP::OAuth::Client::OAuthEnterpriseClient.new(
        resource-url => 'https://mcp.example.com',
        client-id => 'app',
        idp-token-endpoint => 'https://idp.example.com/token',
        idp-client-id => 'idp-app',
        subject-token => 'some-jwt',
    );
    my $p = $client.exchange-token;
    dies-ok { await $p }, 'exchange-token without discover dies';
};

subtest 'OAuthEnterpriseClient request-token without id-jag dies', {
    my $client = MCP::OAuth::Client::OAuthEnterpriseClient.new(
        resource-url => 'https://mcp.example.com',
        client-id => 'app',
        idp-token-endpoint => 'https://idp.example.com/token',
        idp-client-id => 'idp-app',
    );
    my $p = $client.request-token;
    dies-ok { await $p }, 'request-token without id-jag dies';
};

subtest 'OAuthClientHandler register without discover dies', {
    my $handler = MCP::OAuth::Client::OAuthClientHandler.new(
        resource-url => 'https://mcp.example.com',
        client-id => 'my-app',
        authorization-callback => -> $url { 'code' },
    );
    my $p = $handler.register;
    dies-ok { await $p }, 'register without discover dies';
};

subtest 'OAuthClientHandler register without registration-endpoint dies', {
    my $handler = MCP::OAuth::Client::OAuthClientHandler.new(
        resource-url => 'https://mcp.example.com',
        client-id => 'my-app',
        authorization-callback => -> $url { 'code' },
    );
    $handler.auth-metadata = AuthServerMetadata.new(
        issuer => 'https://auth.example.com',
        token-endpoint => 'https://auth.example.com/token',
    );
    my $p = $handler.register;
    dies-ok { await $p }, 'register without registration endpoint dies';
};

subtest 'PKCE generate and verify', {
    my $pkce = PKCE.new;
    my $verifier = $pkce.generate-verifier;
    ok $verifier.chars >= 43, 'verifier length';
    my $challenge = $pkce.generate-challenge($verifier);
    ok $challenge.chars > 0, 'challenge generated';
};

subtest 'SUPPORTED_PROTOCOL_VERSIONS', {
    ok SUPPORTED_PROTOCOL_VERSIONS.elems >= 1, 'at least one version';
    ok LATEST_PROTOCOL_VERSION (elem) SUPPORTED_PROTOCOL_VERSIONS, 'latest in supported';
};

done-testing;
